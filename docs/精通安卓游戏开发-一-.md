# 精通安卓游戏开发（一）

> 原文：[`zh.annas-archive.org/md5/021B82B2841EB90A5AA147BA73C3393A`](https://zh.annas-archive.org/md5/021B82B2841EB90A5AA147BA73C3393A)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 前言

这本书是学习高级 Android 应用开发的实用指南。本书帮助掌握 Android 的核心概念，并在实际项目中快速应用知识。在整本书中，创建了一个应用，并在每一章中不断进化，以便读者可以轻松地跟随并吸收概念。

本书分为十二章。前三章专注于应用的设计，解释了设计的基本概念以及 Android 中使用的编程模式。接下来的几章旨在改进应用，访问服务器端以下载要在应用中显示的信息。一旦应用功能完成，它将使用 Material Design 组件和其他第三方库进行改进。

在完成之前，应用中添加了额外的服务，如位置服务、分析、崩溃报告和盈利化。最后，导出应用，解释不同的构建类型和证书，并将其上传到 Play 商店，准备进行分发。

# 本书涵盖的内容

第一章, *入门*, 介绍了 Android 6 Marshmallow 的基础知识和 Material Design 的重要概念。我们将设置开始开发所需的工具，并且可选地安装一个比 Android 默认模拟器更快的超快模拟器，这将帮助我们在书中测试我们的应用。

第二章, *设计我们的应用*, 介绍了创建应用的第一步——设计导航——以及不同的导航模式。我们将应用带有滑动屏幕的标签页模式，解释并使用 Fragments，这是 Android 应用开发的一个关键组件。

第三章, *从云端创建和访问内容*, 涵盖了在我们的应用中显示互联网信息所需的一切。这些信息可以在外部服务器或 API 上。我们将使用 Parse 创建自己的服务器，并使用 Volley 和 OKHttp 进行高级网络请求来访问它，处理信息并使用 Gson 将其转换为可用的对象。

第四章, *并发和软件设计模式*, 讨论了 Android 中的并发性和处理它的不同机制，如 AsyncTask、服务、加载器等。本章的下半部分讨论了在 Android 中最常见的编程模式。

第五章, *列表和网格*, 讨论了列表和网格，从 ListViews 开始。它解释了这一组件如何在 RecyclerView 中演变，并作为一个示例，展示了如何创建带有不同类型元素的列表。

第六章，*CardView 和材料设计*，专注于从用户界面角度改进应用，并引入材料设计，解释并实现如 CardView、Toolbar 和 CoordinatorLayout 等功能。

第七章，*图像处理和内存管理*，主要讨论了如何在我们应用中显示从互联网上下载的图片，使用不同的机制，如 Volley 或 Picasso。它还涵盖了不同类型的图像，如矢量可绘制图像和 Nine patch。最后，它讨论了内存管理以及预防、检测和定位内存泄漏。

第八章，*数据库和加载器*，主要解释了安卓中数据库的工作原理，内容提供者是什么，以及如何使用 CursorLoaders 让数据库直接与视图通信。

第九章，*推送通知和分析*，讨论了如何使用 Google Cloud Messaging 和 Parse 实现推送通知。章节的下半部分讨论了分析，这对于理解用户如何与我们的应用互动，捕获错误报告以及保持应用无虫至关重要。

第十章，*位置服务*，通过在应用中实现一个示例来介绍 MapView，从开发者控制台初始设置到应用中最终显示位置标记的地图视图。

第十一章，*在安卓上的调试和测试*，主要讨论测试。它涵盖了单元测试、集成测试和用户界面测试。还讨论了使用市场上不同的工具和最佳实践，通过自动化测试开发可维护的应用程序。

第十二章，*货币化、构建过程和发布*，展示了如何实现应用的货币化，并解释了广告货币化的关键概念。它展示了如何导出具有不同构建类型的应用，并最终如何在 Google Play 商店上传和推广此应用。

# 阅读本书所需的条件

你的系统必须具备以下软件才能执行本书中提到的代码：

+   安卓工作室 1.0 或更高版本

+   Java 1.7 或更高版本

+   安卓 4.0 或更高版本

# 本书的目标读者

如果你是一名有 Gradle 经验的 Java 或项目开发者，并希望成为专家，那么这本书就是为你而写的。对 Gradle 的基本了解是必不可少的。

# 约定

在这本书中，你会发现多种文本样式，用于区分不同类型的信息。以下是一些样式示例及其含义的解释。

文本中的代码字、数据库表名、文件夹名、文件名、文件扩展名、路径名和虚拟 URL 将如下显示："我们可以通过使用`include`指令包含其他上下文。"

代码块设置如下：

```java
<uses-permission android:name="android.permission.INTERNET" /> <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /> <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /> 
```

当我们需要引导您关注代码块中的特定部分时，相关的行或项目会以粗体显示：

```java
<uses-permission android:name="android.permission.INTERNET" /> <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /> <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /> 
```

**新术语**和**重要词汇**以粗体显示。您在屏幕上看到的词，例如菜单或对话框中的，会像这样在文本中显示："点击**下一步**按钮，将进入下一个屏幕。"

### 注意

警告或重要提示会以这样的框显示。

### 提示

技巧和诀窍会像这样显示。

# 读者反馈

我们始终欢迎读者的反馈。请告诉我们您对这本书的看法——您喜欢或不喜欢的地方。读者的反馈对我们很重要，因为它能帮助我们开发出您真正能从中获得最大收益的图书。

要向我们发送一般反馈，只需将电子邮件发送至`<feedback@packtpub.com>`，并在邮件的主题中提及书籍的标题。

如果您在某个主题上有专业知识，并且有兴趣撰写或参与编写书籍，请查看我们的作者指南：[www.packtpub.com/authors](http://www.packtpub.com/authors)。

# 客户支持

既然您已经拥有了 Packt 的一本书，我们有许多方法可以帮助您从购买中获得最大收益。

## 下载示例代码

您可以从您的账户[`www.packtpub.com`](http://www.packtpub.com)下载所有您购买的 Packt Publishing 书籍的示例代码文件。如果您在别处购买了这本书，您可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，以便直接将文件通过电子邮件发送给您。

## 下载本书的彩色图片

我们还为您提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图片。彩色图片将帮助您更好地理解输出的变化。您可以从[`www.packtpub.com/sites/default/files/downloads/4221OS_ColorImages.pdf`](http://www.packtpub.com/sites/default/files/downloads/4221OS_ColorImages.pdf)下载此文件。

## 勘误

尽管我们已经竭尽全力确保内容的准确性，但错误仍然在所难免。如果您在我们的书中发现了一个错误——可能是文本或代码中的错误——如果您能向我们报告，我们将不胜感激。这样做，您可以避免其他读者的困扰，并帮助我们改进本书后续版本。如果您发现任何勘误信息，请通过访问[`www.packtpub.com/submit-errata`](http://www.packtpub.com/submit-errata)，选择您的书籍，点击**Errata Submission Form**链接，并输入您的勘误详情。一旦您的勘误信息被核实，您的提交将被接受，并且勘误信息将被上传到我们的网站或添加到该标题下现有勘误列表中。

要查看之前提交的勘误信息，请访问[`www.packtpub.com/books/content/support`](https://www.packtpub.com/books/content/support)，并在搜索字段中输入书名。所需信息将显示在**勘误**部分下。

## 盗版

网络上对版权材料的盗版行为是所有媒体持续面临的问题。在 Packt，我们非常重视对我们版权和许可的保护。如果您在互联网上以任何形式遇到我们作品的非法副本，请立即提供其位置地址或网站名称，以便我们可以寻求补救措施。

如果您发现疑似盗版材料，请通过`<copyright@packtpub.com>`与我们联系，并提供链接。

我们感谢您帮助保护我们的作者以及我们为您带来有价值内容的能力。

## 问题

如果您对这本书的任何方面有问题，可以通过`<questions@packtpub.com>`联系我们，我们将尽力解决问题。


# 第一章：开始入手

我们将以 Material Design 和 Android 6 Marshmallow 的概述来开篇。谷歌推出的新的 Material Design 概念，在应用的外观和感觉上带来了一场革命。

在本书的进行过程中，我们将构建一个名为 `MasteringAndroidApp` 的应用。在本章中，我们将解释这个应用的内容。在这个应用中，我们将实践所有章节中解释的概念和理论。在本书结束时，我们应该拥有一个丰富的应用，功能齐全，可以轻松修改以创建您自己的版本，并上传到 Google Play 商店。

我们将确保拥有所有必要的工具，下载最新版本的 Android 并介绍**Genymotion**，这是本书强烈推荐的最快的 Android 模拟器。

+   Material Design

+   Android 6 Marshmallow 的关键要点

+   应用概述

+   准备工具

    +   Android Studio

    +   SDK 管理器

+   Genymotion

# 介绍 Material Design

如前所述，Material Design 在应用的外观和感觉上带来了一场革命。你可能之前听说过这个概念，但确切来说它是什么呢？

Material Design 是由谷歌创建的一种新的视觉语言，它被用在所有基于材料、有意义的过渡、动画和响应式交互的平台、网站和移动设备上。

材料是一个可以在表面看到的元素的隐喻，它由可以具有不同高度和宽度的层组成，但它们的厚度始终是一个单位，就像纸张一样。我们可以将材料一个放在另一个上面，为视图引入深度元素，一个*Z*坐标。同样，我们可以在另一张纸上放置一张纸，投下阴影，定义视觉优先级。

内容显示在材料上，但它们不会增加其厚度。内容可以以任何形状和颜色显示；它可以是一个纯背景色、文本、视频，还有许多其他东西。它被限制在材料的边界内。

材料可以扩展，内容也可以随之扩展，但内容永远不能超过材料的扩展范围。我们不能有两个处于同一*Z*位置的材质。其中一个总是要在另一个下面或者上面。如果我们与材料互动，我们总是在最顶层进行。例如，触摸事件将在最顶层执行，不会穿透到底层。你可以改变材料的尺寸和形状，两种材料可以合并成一个，但它们不能弯曲或折叠。

![介绍 Material Design](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_01.jpg)

这是一个使用 Material Design 风格的应用示例；我们可以看到带有阴影的卡片、不同的内容和一个带有导航抽屉的应用栏。所有这些组件都将在本书中进行解释，我们将致力于使用相同风格构建一个应用。

材料设计也带来了重要的用户界面元素，如 `RecyclerView`。这是一个视图，将替代早期 Android 中的 `ListView`，以创建任何类型的可滚动元素列表。我们将在第五章 *列表和网格*中处理这些组件，从 `ListView` 的基本版本开始，演进到理解 `RecyclerView` 是如何诞生的，并以一个示例结束。

`CardView` 是另一个引入的主要用户界面元素。我们可以在前面的图片中看到一个；这是一个带有背景和阴影的组件，可以自定义以适应我们想要的所有内容。我们将在第六章 *CardView 和材料设计*中处理它，在那里我们还将介绍下一个组件——设计支持库。

设计支持库是一个包含动画、**FAB**（**浮动操作按钮**）和导航抽屉的*必备*库。你可能已经在其他应用中见过从左侧滑出的滑动菜单。设计支持库为旧版 Android 提供了这些组件的支持，使我们能够在旧版本中使用材料设计特性。

所有上述内容都是从用户界面和编程的角度来看的特性，但材料设计还为我们的手机引入了不同的功能，例如带有不同优先级级别的新通知管理系统。例如，我们可以指定哪些通知是重要的，并建立一个时间段，在这个时间段内我们不想被打扰。

![介绍材料设计](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_02.jpg)

另一个我们不能忽视的是这一版本在电池消耗方面的改进，与之前的 Android 版本相比，它可以节省高达 90 分钟的电池电量，这是由于一个新的 Android 运行时 ART。用非技术性的方式来解释，它将应用程序翻译成一种语言，当应用程序安装时，Android 可以更快地理解这种语言。之前的运行时 **Dalvik** 在执行我们的应用程序时必须进行这种翻译，而不是只在安装时翻译一次。这有助于应用程序消耗更少的电池并运行得更快。

# 介绍 Android 6 Marshmallow

这一版本的主要变化之一与应用程序的权限有关。在 Android M 之前，我们习惯于在下载应用程序之前接受应用程序的权限；播放商店向我们展示了应用程序具有的权限列表，我们需要接受它们才能下载和安装。

![介绍 Android 6 Marshmallow](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_03.jpg)

## 运行时权限

随着运行时权限的引入，这一切都改变了。这里的理念是只在需要时接受权限。例如，当你拨打电话或留下语音信息之前，WhatsApp 可能不需要访问你的麦克风。

![运行时权限](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_04.jpg)

这是在我们开发应用时需要考虑的一件事；这对开发者来说是一个改变，现在需要控制如果用户不接受权限，应该做什么。以前，我们不需要进行任何控制，因为在安装时这是一个全有或全无的选择；现在，我们必须要考虑运行时用户的决定。

### 提示

**下载示例代码**

您可以从您在[`www.packtpub.com`](http://www.packtpub.com)的账户下载您购买的所有 Packt Publishing 图书的示例代码文件。如果您在别处购买了这本书，可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)注册，我们会将文件直接通过电子邮件发送给您。

## 节能优化

自从 Lollipop 版本以来，我们的手机电池寿命有了另外一项改进；这次，谷歌引入了两种新的状态：**休眠模式**和**应用待机**。

休眠模式提高了空闲设备的睡眠效率。如果我们关闭屏幕且没有使用手机，我们将进入空闲状态。以前，应用可以在后台进行网络操作并继续工作；现在，随着休眠模式的引入，系统会定期允许我们的应用在后台工作一段时间，并执行其他挂起的操作。这同样在开发时带来了一些考虑；例如，在这种模式下，我们的应用无法访问网络。

![节能优化](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_05.jpg)

应用待机是一种针对一段时间未被使用且后台没有运行任何进程的应用的诱导空闲模式。如果一个应用没有显示任何通知，且用户没有明确要求它免除优化，那么就会为这个应用启用待机模式。这种空闲模式防止应用访问网络和执行挂起的任务。当连接电源线时，所有处于待机状态的应用都会被释放，空闲限制也会被移除。

## 文本选择

在之前的版本中，当用户选择文本时，动作栏上会出现一组操作，如复制、剪切和粘贴。在这个版本中，我们可以在一个浮动的栏中显示这些操作以及更多内容，该浮动栏将显示在选定内容的上方：

![文本选择](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_06.jpg)

## 指纹验证

在这个版本的 Android 中，我们可以验证指纹的使用。这种验证可以在设备级别进行，以解锁手机，而不仅仅是解锁某个特定的应用；因此，我们可以根据用户最近解锁设备的情况，在我们的应用中验证用户。

我们有一个新的可用对象，`FingerprintManager`，它将负责身份验证，并允许我们显示一个请求指纹的对话框。我们需要一个带有指纹传感器的设备才能使用这个功能。

![指纹验证](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_07.jpg)

## 直接分享

直接分享是一个新增加的功能，用以简化内容分享过程。以前，如果我们处于图库中，并希望将图片分享给 WhatsApp 中的联系人，我们必须点击**分享**，在应用列表中找到 WhatsApp，然后在 WhatsApp 中找到联系人来分享内容。这个过程将被简化，直接显示一个你可以直接分享信息的联系人列表：

![直接分享](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_08.jpg)

这些是与 Android 6 Marshmallow 一起发布的主要新功能；完整列表可以在[`developer.android.com/preview/index.html`](http://developer.android.com/preview/index.html)查看。

# 创建 MasteringAndroidApp

既然我们已经了解了最新 Android 版本的主要功能，我们可以介绍在本书中将要开发的应用程序了。这个应用程序将包括这些功能的大部分，但我们也会花时间在之前 Android 版本中广泛使用的组件上。

要掌握 Android，我们应该准备好理解遗留代码；例如，我们可能需要在仍然使用`ListView`而不是新出的`RecyclerView`的应用程序上工作。我们不会总是用最新的组件从零开始创建应用程序，特别是如果我们是专业的 Android 开发者。同时，查看之前的组件将帮助我们理解这些组件的自然演变，以便更好地了解它们现在的样子。

我们将从零开始创建这个应用程序，从最初的设计开始，看看在 Android 中最常用的设计和导航模式，比如顶部的标签，左侧的滑动菜单等等。

我们将要开发的`MasteringAndroidApp`应用程序，是一个与服务器端交互的应用程序。这个应用程序将展示存储在云中的信息，我们将创建云组件，使我们的应用程序能够与之通信。我们为应用程序选择的主题是职位公告板，我们将在服务器端创建职位邀请，应用程序的用户可以阅读这些邀请并接收通知。

您可以轻松地自定义主题；这将是一个示例，您可以更改信息并使用相同的结构创建自己的应用程序。实际上，如果你能想出自己的点子会更好，因为我们将讨论如何在 Play 商店发布应用程序以及如何实现盈利；我们将添加广告，当用户点击广告时会产生收入。所以，如果你使用自己的想法来应用所学内容，等到你读完这本书时，你将拥有一个准备发布的应用程序。

我们将开发一个解释在 Android 中最常用的编程模式以及并发技术和连接到 REST API 或服务器不同方法的应用程序。

我们不仅关注后端，也关注 UI；通过有效的方式展示信息，使用列表和网格，从互联网上下载图片，以及使用最新的材料设计特性来自定义字体和视图。

我们将学习如何调试我们的应用，管理日志，并在学习如何识别和防止内存泄漏时考虑内存使用情况。

我们的应用将有一个基于数据库的离线模式，我们将把云中的内容存储在这里。这样，如果手机失去连接，我们仍然可以显示上次在线时可用信息。

为了完善我们的应用，我们将添加额外的功能，如推送通知、崩溃报告和分析。

最后，我们将了解 Android 构建系统的工作原理，以不同版本导出我们的应用，同时混淆代码以保护它，防止被反编译。

我们压缩了大量信息，这将帮助您在本书结束时掌握 Android；然而，在开始我们的应用之前，让我们先准备好工具。

# 准备工具

在本书中，我们将需要的工具包括最新版本的 Android Studio、更新至 Android M 或更高版本的 Android SDK。还建议您使用**Genymotion**，这是一个用于测试应用的模拟器。

### 注意

首先，我们需要下载并安装 Android Studio，这是在 Android 上进行开发的官方工具。可以从[`developer.android.com/sdk/index.html`](http://developer.android.com/sdk/index.html)下载。

在网站顶部，您可以根据您的操作系统版本找到一个下载链接。

![准备工具](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_09.jpg)

安装完成后，我们需要下载一个 Android M SDK，它将提供开发特定 Android 版本应用所需的全部类和资源。这是通过 SDK 管理器完成的，它是 Android Studio 内包含的一个工具。

我们可以点击**工具** | **Android** | **SDK 管理器**，或者在 Android Studio 最上方的工具栏中找到快捷方式。

![准备工具](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_10.jpg)

一旦我们打开 SDK 管理器，我们会看到可用 SDK 平台和 SDK 工具的列表。我们需要确保已安装最新版本。

![准备工具](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_11.jpg)

这样，我们就有了我们开发应用所需的一切。为了测试它，理想情况下应该有 Genymotion，这是一个 Android 模拟器，它将帮助我们测试应用在不同设备上的运行情况。

我们选择使用这个模拟器而不是 Android 默认模拟器的主要原因在于速度。在 Genymotion 中部署应用甚至比使用物理设备还要快。除此之外，我们还受益于其他功能，比如可调整大小的窗口、从我们的电脑复制和粘贴内容，以及一些在使用默认模拟器时会消耗时间的小细节。可以从[`www.genymotion.com`](https://www.genymotion.com)下载。

我们需要做的就是安装它，一旦打开，我们就可以添加具有现有设备包含功能的模拟器。

![准备工具](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_01_12.jpg)

# 总结

在本章中，我们回顾了最新 Android 版本中的重要变化，重点介绍了 Android Marshmallow 和 Material Design。

我们解释了在本书的学习过程中将要构建的应用程序中的功能以及创建它所需的工具。

在下一章中，我们将研究 Android 中现有的设计模式并开始设计我们的应用程序。


# 第二章：设计我们的应用程序

在本章中，我们将为应用程序想出一个创意，并将这个创意转化为真实的应用程序，创建要在屏幕上显示的基本结构，并选择适当的导航模式在它们之间移动。

在查看最常用的导航模式之后，我们将继续实施由片段和`ViewPager`组成的标签页模式。

在此过程中，我们将回顾我们关于片段的知识，以便能够解释高级概念。我们还将讨论`FragmentManager`和片段回退栈的重要性。

最后，我们将在屏幕过渡中添加一些美观的动画。因此，在本章中我们将介绍以下主题：

+   选择应用程序导航模式

+   精通片段

+   实施标签页和 ViewPager

+   屏幕之间的动画过渡

# 选择应用程序导航模式

想象一下，有一天你醒来时充满灵感；你有一个应用程序的创意，你相信它可能比 WhatsApp 更受欢迎。不要浪费时间，你会想要将这个应用程序创意变为现实！这就是为什么学习如何设计应用程序并选择最合适的导航模式对你很重要。不是要让你失去灵感，但你会发现你的 99%的创意已经在 Google Play 商店里了。事实上，有数十万的应用程序可供选择，而且数量还在不断增加！所以，你可以选择改进已有的应用程序，或者继续头脑风暴，直到你有一个原创的创意。

为了将应用程序变为现实，第一步是在心中可视化应用程序；为此，我们需要确定基本组件。我们需要在屏幕上简化想法，并且我们需要在屏幕之间移动。

请记住，你是在为 Android 用户创建这个应用程序。这些用户习惯于使用像 Gmail、Facebook 和 Spotify 等应用程序中的滑动面板导航模式。

我们将研究三种不同的、常用的导航模式，以确保用户在使用我们的应用程序时不会迷路，并能立即理解应用程序的结构。

## 基本结构

为了绘制我们的屏幕（请注意，我这里不是指活动或片段；所谓屏幕是指用户在我们应用程序执行期间任何时候实际可以看到的内容），我们需要确定我们创意的关键点。我们需要用软件开发术语来确定用例。

让我们先为我们将在本书过程中构建的应用程序**MasteringAndroidApp**赋予形状。一开始很难在脑海中想象出所有细节，所以我们将从确定我们肯定需要的组件开始，稍后再填补可能存在的空白。

我们从上一章知道，我们有一个演示屏幕，它会在需要时从互联网下载数据的同时显示应用程序的标志几秒钟。

在这个应用中，我们还将有一个来自互联网的信息列表屏幕，用户可以点击单个项目获取更详细的信息。

作为主要选项，我们将显示一个带有`MapView`的联系人屏幕，显示我的位置和联系数据。

最后，我们需要一个**偏好设置**或**设置**屏幕，在这里我们可以打开或关闭通知，禁用广告或购买额外内容。

现在，我们已经准备好创建一个草图。请看以下图片：

![基本结构](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_01.jpg)

在顶部，我们有应用程序的入口点，即启动屏幕。这里的导航很直接；我们可以直接导航到下一个屏幕，并且没有按钮或任何其他可能的流程。

在下一层，我们有项目列表的屏幕（这是一个包含联系信息的屏幕）、地图视图和设置屏幕。这三个屏幕在我们的应用中处于同一级别，因此它们具有同等的重要性。

最后，我们还有一个第三层导航，这是列表中一个条目的详细视图。

我们打开这个屏幕的唯一方式是点击列表中的一个元素；因此，这个屏幕的入口点是列表屏幕。

现在我们已经创建了一个基本的结构和流程，我们将研究不同的广泛使用的导航模式，以决定哪一种最适合我们的应用。

### 注意

有关应用结构和有关材料设计类似信息的更多信息，请参考以下链接：

[`developer.android.com/design/patterns/app-structure.html`](https://developer.android.com/design/patterns/app-structure.html)

[`www.google.com/design/spec/patterns/app-structure.html#`](http://www.google.com/design/spec/patterns/app-structure.html#)

## 仪表板模式

仪表板模式是 Android 中最早使用的模式之一。它由一组在主屏幕上以图标矩阵形式显示的元素组成。在下面的图片中，我们可以看到左侧是 Facebook 应用的一个早期版本，而在右侧，是 Motor Trend 对这个模式的定制：

![仪表板模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_02.jpg)

这种视图非常适合那些旨在清晰显示非常有限选项的应用；每行不超过两个元素，行数适合屏幕显示。

这些图标清晰地显示了主要功能的符号，所有选项都在同一级别。它非常适合目标受众广泛的应用程序；它简单明了，一目了然，任何人都可以导航。

尽管这个设计看起来很古老，考虑到它曾在 Android 的早期版本中被广泛使用，而现在使用较少，但它的使用取决于你的需求，所以不要因此放弃。前面图片中显示的 Motor Trends 应用对这个模式有一个非常原始的实现。

如果元素不适合屏幕，我们需要滚动才能发现它们，我们需要重新考虑这个模式。当我们有太少的元素时，情况也是如此；这些情况下有更好的选择。在我们的具体示例中，我们有三个主要元素，所以我们不会使用这个模式。

## 滑动面板

这种模式因 Gmail 和 Facebook 等应用而广为人知。它在用户界面的顶层展示一个布局；当我们执行滑动手势或点击左上或右上按钮时，屏幕会从左或右侧滑出，这个按钮通常是一个显示三条水平线的图标，也被称为汉堡图标。

如果我们的应用在同一层级有大量选项，这种模式是完美的，并且它可以与其他模式结合使用，例如**标签模式**。

这个面板的实现可以通过`DrawerLayout`类完成，它由两个子视图组成：一个带有内容和导航抽屉的`FrameLayout`，导航抽屉可以是`ListView`或任何其他包含选项的自定义布局。

为此，执行以下代码：

```java
<android.support.v4.widget.DrawerLayout    
   android:id="@+id/drawer_layout"   
   android:layout_width="match_parent"   
   android:layout_height="match_parent" >   

   <FrameLayout   
    android:id="@+id/frame_container"   
    android:layout_width="match_parent"   
    android:layout_height="match_parent" />   

   <ListView   
    android:id="@+id/drawer_list"   
    android:layout_width="240dp" 
    android:background="#fff"  
    android:layout_height="match_parent"   
    android:layout_gravity="start" />   

  </android.support.v4.widget.DrawerLayout>
```

一旦我们在侧边栏选择了一个元素，屏幕中央就会出现一个子元素；这个子元素可以帮助你导航到子子元素，但不能导航到主菜单的元素。子元素和子子元素的导航可以通过后退按钮或在操作栏中使用向上导航来管理。

我们可以通过点击一个项目来关闭面板，并通过设置一个抽屉监听器`ActionBarDrawerToggle`来知道面板是关闭还是打开，它包含`onDrawerClosed(View drawerView)`和`onDrawerOpened(View drawerView)`方法。

确保你使用了来自`android.support.v7.app`的`ActionBarDrawerToggle`；v4 中包含的已弃用。

这种模式的另一个大优点是，它允许通过菜单上的一个主项目进行分组导航，可以展开成子项目。正如在以下示例中可以看到，项目 4 在下拉菜单中有三个选项：

![滑动面板](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_03.jpg)

抽屉布局的一个示例

这种模式不适合我们的应用，因为我们没有足够的选项来充分利用这个模式。此外，由于这个模式可以与标签模式结合，从教育角度来看，用这个模式开发我们的示例更有意义。

## 标签

标签模式是一种你可能之前见过并使用过的模式。

它显示了一个具有同一层级的组件的固定菜单。请注意，当我们有标签时，菜单总是可见的，这在滑动和仪表板模式中不会发生。这看起来与网页界面非常相似，并且非常用户友好，考虑到用户可能已经熟悉这个模式。

以下模式有两个变体：固定标签和滑动标签。如果我们只有少量可以一次显示在屏幕上的菜单项，第一个变体将是最合适的，因为它可以一次向用户展示所有项目。

![标签](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_04.jpg)

当所有项目不适合屏幕或当前适合但知道未来会增加更多项目而无法容纳时，通常会使用滑动标签。

两种变体的实现略有不同，因此在决定变体时我们需要考虑未来的变化。在这里，我们可以看到一个滑动变体的实现：

![标签](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_05.jpg)

### 提示

请记住，为了平台的一致性，我们必须将标签放置在屏幕顶部；否则，人们会认为您是 iOS 开发者！

以下是一些来自材料设计指南的功能和格式规范供您遵循：

+   将标签作为单行呈现。如果需要，将标签文本换行到第二行，然后截断。

+   不要在标签内包含一组标签化内容。

+   高亮显示与可见内容对应的标签。

+   按层次结构将标签分组。将一组标签与其内容连接起来。

+   保持标签与其内容相邻。这有助于减少两者之间的歧义，保持关系。

在以下图片中，我们可以看到一个带有子菜单的滚动/滑动标签的示例：

![标签](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_06.jpg)

### 注意

设计标签时的图形规范以及有关标签规范更多信息可以在 [`www.google.com/design/spec/components/tabs.html#`](http://www.google.com/design/spec/components/tabs.html#) 找到。

既然我们已经知道了应用程序导航的基础知识，我们可以探索实现这些模式所需的组件。如您所知，主要组件是活动和碎片。我们将实现带有三个碎片的滑动标签的示例。

# 碎片（Fragments）

在本节中，我们将简要回顾碎片的关键概念，以解释高级功能和组件，如碎片管理器和碎片后退栈。

在我们的示例中，我们将创建一个名为 `MainActivity` 的活动以及四个碎片：`ListFragment`、`ContactFragment`、`SettingsFragment` 和 `DetailsFragment`。为此，您可以创建一个 `fragments` 包，双击该包以进入 **新建** | **碎片** | **空白碎片**。看看以下对话框：

![碎片](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_07.jpg)

目前，您可以不使用碎片工厂方法和接口回调来创建它们。我们将在本章后面介绍这些内容。

到目前为止，我们的项目在**项目**视图中应该看起来像这样：

![碎片](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_08.jpg)

## 理解碎片的重要性

一个碎片代表活动中的一个行为或用户界面部分。您可以在单个活动中组合多个碎片以构建多窗格 UI，并在多个活动中重用碎片。您可以认为碎片是活动的一个模块化部分，它有自己的生命周期并接收自己的输入事件，您可以在活动运行时添加或删除（有点像可以在不同活动中重用的*子活动*）。

![理解片段的重要性](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_09.jpg)

片段的生命周期与活动的生命周期略有不同。我们注意到的第一个区别是使用了 `OnAttach()` 和 `OnDetach()` 方法，它们将片段连接到活动中。

使用 `onCreate()`，我们可以在 `OnCreateView()` 中创建视图；在这之后，我们可以在片段中调用 `getView()`，它将不会是 null。

`onActivityCreated()` 方法告诉片段其活动已经在它自己的 `Activity.onCreate()` 中完成。

有两种方法可以显示片段：

第一种方法是在我们的布局 XML 中包含片段。当包含它的视图被填充时，这将创建我们的片段。执行以下代码：

```java
<LinearLayout 
    android:orientation="horizontal"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">

    <fragment android:name="com.example.android.MyFragment"
              android:id="@+id/headlines_fragment"
android:layout_width="match_parent"
              android:layout_height="match_parent" />
</LinearLayout>
```

第二种方法是程序化地创建我们的片段，并告诉片段管理器在容器中显示它。为此，你可以使用以下代码：

```java
<LinearLayout 
    android:orientation="horizontal"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent">

    <Framelayout android:id="@+id/fragment_container"
android:layout_width="match_parent"
             android:layout_height="match_parent" />

</LinearLayout>
```

之后，使用以下代码行填充一个 `FrameLayout` 容器，片段将被插入其中：

```java
Myfragment fragment = MyFragment.newInstance();
getSupportFragmentManager().beginTransaction()
                    .add(R.id.fragment_container, fragment).commit();
```

为了结束关键概念，解释为什么 Android 示例使用 `MyFragment.newInstance(params)` 工厂方法而不是默认的 `new MyFragment(params)` 构造函数来创建片段是很重要的。看看以下代码：

```java
public class MyFragment extends Fragment {

 // Static factory method that returns a new fragment
 // receiving a   parameter and initializing the fragment's arguments

    public static MyFragment newInstance(int param) {
        MyFragment fragment = new MyFragment();
        Bundle args = new Bundle();
        args.putInt("param", param);
        fragment.setArguments(args);
        return fragment;
    }
}
```

这种模式背后的原因是，Android 只会使用默认构造函数重新创建片段；因此，如果我们有一个带参数的构造函数，它将被忽略，参数也将丢失。

### 提示

请注意，我们将参数作为参数包发送，这样如果片段需要被重新创建（由于设备方向改变，我们使用后退导航），片段就可以检索参数。

## 片段管理器

片段管理器是一个接口，用于与活动内的片段进行交互。这意味着任何操作，如添加、替换、移除或查找片段，都必须通过它来完成。

为了获得片段管理器，我们的 `Activity` 需要从 `FragmentActivity` 继承，这将允许我们调用 `getFragmentManager()` 或 `getSupportFragmentManager()`，最好是使用 `Android.support.v4` 中包含的保持向后兼容的片段管理器。

如果我们想要使用嵌套片段，可以通过 `getChildFragmentManager()` 来管理它们。当布局包含 `<fragment>` 时，我们不能将布局填充到片段中。只有动态添加到片段中的时候，嵌套片段才是支持的。

现在，我们将讨论一些在我们使用片段时会迟早遇到的情况。假设我们有一个带有两个片段 A 和 B 的活动。

一个典型的情况是，我们处于一个片段中，想要从活动中执行一个方法。在这种情况下，我们有两个选择；一个是实现在 `MyActivity` 中的 `public` 方法，例如 `doSomething()`，这样我们就可以将 `getActivity` 强制类型转换为我们的活动，并调用 `((MyActivity)getActivity).doSomething();` 方法。

第二种方法是让我们的活动实现碎片中定义的接口，并在`onAttach(Activity)`方法中将活动的实例设置为该接口的监听器。我们将在第四章中解释这种软件模式，*并发与软件设计模式*。反过来，如果要让活动与碎片通信（如果我们没有在活动中将碎片 A 实例化到一个变量中），我们可以通过管理器找到碎片。我们可以在以下部分查看如何使用容器 ID 或标签找到碎片：

```java
FragmentManager fm = getSupportFragmentManger();
FragmentA fragmentA = fm.findFragmentById(R.id.fragment_container);
fragmentA.doSomething(params);
```

最后一种情况是在碎片 A 中与 B 对话；为此，我们只需从活动中获取管理器并找到碎片。运行以下代码：

```java
FragmentManager fm = getActivity().getSupportFragmentManger();
FragmentA fragmentA = fm.findFragmentById(R.id.fragment_container);
fragmentA.doSomething(params);
```

## 碎片堆叠

我们一直在讨论在碎片管理器中查找碎片，这是由于碎片管理器的碎片堆栈，我们可以在事务期间添加或删除碎片。

当我们想要动态显示一个碎片时，我们可以决定是否要将碎片添加到堆栈中。将碎片放在堆栈上可以让我们返回到上一个碎片。

这对于我们的示例非常重要；如果用户在第一个标签上，点击列表中的项目，我们希望他/她看到详情屏幕，即`DetailsFragment`。现在，如果用户在`DetailsFragment`上，点击返回按钮，我们不希望他/她离开应用；我们希望应用返回到碎片堆叠。这就是为什么我们在添加`DetailsFragment`时，必须包含`addToBackStack(String tag)`选项。标签可以为 null，也可以是允许我们通过标签找到这个新碎片的`String`类型。它将类似于以下内容：

```java
FragmentTransaction ft = getFragmentManager().beginTransaction();
ft.replace(R.id.simple_fragment, newFragment);
ft.addToBackStack(null);
ft.commit();
```

为了进一步澄清，如果我们想在三个碎片之间导航，从*A 到 B 再到 C*，然后返回，拥有堆栈将允许我们从*C 到 B 再到 A*。然而，如果我们不将碎片添加到返回堆栈中，或者在同一容器中添加或替换它们，*A 到 B 再到 C*，这将只留下 C 碎片，并且无法返回导航。

现在，为了在`DetailsFragment`中实现返回导航，我们需要让活动知道当我点击返回时，我想先在碎片中返回，然后再退出应用，这是默认的行为。如果堆栈中不止一个碎片，可以通过重写`onKeyDown`并处理碎片导航来实现这一点。运行以下命令：

```java
@Override
public boolean onKeyDown(int keyCode, KeyEvent event) {
if (keyCode == KeyEvent.KEYCODE_BACK && getSupportFragmentManager.getBackStackEntryCount > 1) {
getSupportFragment.popBackStack();
return true;
}
return super.onKeyDown(keyCode, event);
}
```

# 视图翻页

继续我们的示例，在`MainActivity`中，我们有两种在碎片之间导航的方法：一种是点击标签，另一种是滑动碎片。为了实现这一点，我们将使用`ViewPager`，包括其中的滑动标签，这是一个非常优雅的解决方案，代码量最小，并且包括滑动和标签之间的同步。

`ViewPager`可用于滑动任何类型的视图。我们可以使用`ViewPager`创建一个图片画廊；在首次运行某些应用时，经常会看到教程，你可以滑动屏幕查看应用操作说明，这是通过`ViewPager`实现的。要将`ViewPager`添加到`MainActivity`，我们可以简单复制并粘贴以下代码：

```java
<?xml version="1.0" encoding="utf-8"?>
<android.support.v4.view.ViewPager

android:id="@+id/pager"
android:layout_width="match_parent"
android:layout_height="match_parent" />
```

在`ViewPager`部分末尾，我们将了解如何使用不同的第三方库来改善标签页的体验，以及如果我们想要自定义解决方案，如何手动创建这些标签页。

## 适配器

`ViewPager`与适配器一起工作；适配器是负责创建我们滑动的每个*页面*的元素。在滑动片段的特殊情况下，有`Adapter`类的扩展名为`FragmentPagerAdapter`和`FragmentStatePagerAdapter`，我们可以使用：

+   `FragmentStatePagerAdapter`保存页面的状态，在屏幕上不显示时销毁它，并在需要时重新创建，这与`ListView`对其行的处理类似。

+   `FragmentPagerAdapter`将所有页面保存在内存中；因此，在滑动时没有与保存和恢复状态相关的计算成本。我们可以拥有的页面数量取决于内存。

根据元素数量，我们可以选择其中之一。如果我们正在创建一个阅读新闻的应用，你可以在很多带有图片和不同内容的新闻文章之间滑动，我们不会尝试将它们全部保存在内存中。

我们有三个固定的标签页，因此我们将选择`FragmentPagerAdapter`。我们将创建一个包装适配器，并创建一个名为`MyPagerAdapter`的类，这个类将扩展`FragmentPagerAdapter`。在扩展它的时候，我们需要重写`getCount()`和`getItem(int i)`方法，这些方法返回项目数量和在给定位置返回一个项目。

创建构造函数并完成方法后，我们的类将类似于以下代码：

```java
public class MyPagerAdapter extends FragmentPagerAdapter {

    public MyPagerAdapter(FragmentManager fm) {
        super(fm);
    }

    @Override
    public Fragment getItem(int i) {
        switch (i) {
            case 0 :
                return new ListFragment();
            case 1 :
                return new ContactFragment();
            case 2 :
                return new SettingsFragment();
            default:
                return null;
        }
    }

    @Override
    public int getCount() {
        return 3;
    }
}
```

最后，我们需要在`MainActivity`中将适配器设置到翻页器中。执行以下代码：

```java
public class MainActivity extends FragmentActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        MyPagerAdapter adapter = new MyPagerAdapter(getSupportFragmentManager());
        ViewPager viewPager = (ViewPager) findViewById(R.id.pager);
        viewPager.setAdapter(adapter);

    }

}
```

## 滑动标签

在我们的示例中，此时我们已经能够在片段之间滑动。现在，我们将使用`PagerTabStrip`或`PagerTitleStrip`添加标签页。

实现这一点有一个非常优雅的方法，即在`ViewPager`的 XML 标签中包含`PageTabStrip`。执行以下代码：

```java
<?xml version="1.0" encoding="utf-8"?>
<android.support.v4.view.ViewPager

android:id="@+id/pager"
android:layout_width="match_parent"
android:layout_height="wrap_content">

    <android.support.v4.view.PagerTabStrip
        android:id="@+id/pager_title_strip"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="top"
        android:background="#33b5e5"
        android:textColor="#fff"
        android:textSize="20dp"
        android:paddingTop="10dp"
        android:paddingBottom="10dp" />

</android.support.v4.view.ViewPager>
```

在这里，`PagerTabStrip`将找到页面的标题，并为每个页面显示一个标签。我们需要在`MyPagerAdapter`中添加`getPageTitle`方法，它将为每个页面返回一个字符串。在我们的例子中，这将是一下部分的名字：列表、联系人和设置。为此，你可以使用以下代码：

```java
@Override
public CharSequence getPageTitle(int position) {
  switch (position) {
    case 0 :
    return "LIST";
    case 1 :
    return "CONTACT";
    case 2 :
    return "SETTINGS";
    default:
    return null;
  }
}
```

运行应用，瞧！我们轻松实现了一个流畅的标签页和滑动导航支持，支持 Android 1.6（API 4）：

![滑动标签](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_02_10.jpg)

## 定制标签页

Android 中的标签页背后有一个很长的故事；最初，标签页是通过`TabActivity`实现的，但在 API 13 中被废弃，并演变成了`FragmentTabHost`。

因此，我按照 Android 文档，高兴地使用`TabHost`开发了一个应用，然后意识到这一点必须改变。起初，我抱着侥幸心理，希望废弃不会影响我的应用，直到一些用户抱怨应用崩溃。然后，不可避免地，我必须移除废弃的`TabHost`并寻找新的方法。

一开始，`FragmentTabHost`似乎是一个实现固定标签页的好方法，但它不允许在标签上使用图标。在遇到这个问题，并在 Stack Overflow 上发现其他人也有同样的问题（一个可以提问和找到关于 Android 和其他主题答案的网站），我决定寻找另一种方法。

在 API 11 中，出现了`ActionBar.Tab`的概念，这是一个允许我们向操作栏添加标签页的类。最终，我找到了在我的应用中实现标签页的方法，这让用户们感到高兴！但这种喜悦并没有持续太久；`ActionBar.Tab`又被废弃了！

这件事会让任何开发者的耐心耗尽；这让我决定在`LinearLayout`中以按钮的形式创建自己的标签页。在按钮上设置点击监听器，点击标签页时，我将`ViewPager`滑动到正确的页面，反之，当检测到`ViewPager`页面滑动时，我会选择正确的标签页。这样做是值得的，因为它让我在设计标签页时拥有完全的自由度，更重要的是，它给了我一种满足感，除非有一天`LinearLayout`或`Button`被废弃，否则它将一直有效。

你总是可以把自定义实现作为最后的选择。如今，如果你不喜欢滑动标签页的设计，你可以使用第三方库的其他替代方案，比如`ViewPagerIndicator`和`PagerSlidingTabStrip`。

### 备注

要了解更多信息，你可以查看以下链接：

[JakeWharton 的 ViewPagerIndicator](https://github.com/JakeWharton/ViewPagerIndicator)

[astuetz 的 PagerSlidingTabStrip](https://github.com/astuetz/PagerSlidingTabStrip)

# 过渡效果

像是创建我们自己的屏幕过渡动画这样的小细节，将使我们的应用更加精致，看起来更加专业。

我们的示例非常适合讨论过渡，因为我们有两种类型的屏幕过渡：

+   第一个是活动之间的过渡，从`SplashActivity`到`MainActivity`。

+   第二个（尚未实现）是碎片之间的过渡，其中`ListFragment`被`DetailsFragment`替换。

对于活动之间的过渡，我们需要在启动新活动之前调用`overridePendingTransition`。该方法接收两个动画作为参数，这些动画可以是我们创建的 XML 文件中的，也可以是从 Android 中已经创建的动画中选择。运行以下命令：

```java
overridePendingTransition(android.R.anim.fade_in, android.R.anim.fade_out);
```

在我们的示例中，我们不允许可返回导航到`SplashActivity`；然而，如果我们处于需要点击返回时具有相同过渡的活动之间的过渡，我们将不得不重写返回键按下并设置我们的过渡。为此，您可以运行以下命令： 

```java
@Override public void onBackPressed() {
   super.onBackPressed();        overridePendingTransition(android.R.anim.fade_in,  android.R.anim.fade_out); 
}
```

在处理片段时，我们需要在`FragmentTransaction`对象中指定转换。使用对象动画师，我们可以在两个文件中定义这一点：`enter.xml`和`exit.xml`。执行以下代码：

```java
FragmentTransaction transaction = getFragmentManager().beginTransaction();
transaction.setCustomAnimations(R.animator.enter, R.animator.exit);
transaction.replace(R.id.container, new DetailsFragment());
transaction.commit();

enter.xml

<?xml version="1.0" encoding="utf-8"?>
<set>
     <objectAnimator

         android:duration="1000"
         android:propertyName="y"
         android:valueFrom="2000"
         android:valueTo="0"
         android:valueType="floatType" />
</set>

exit.xml 
<?xml version="1.0" encoding="utf-8"?>
<set>
    <objectAnimator

        android:duration="1000"
        android:propertyName="y"
        android:valueFrom="0"
        android:valueTo="-2000"
        android:valueType="floatType" />
</set>
```

对于 Android Lollipop 及更高版本，您可以直接为片段设置过渡。使用以下代码片段：

```java
Fragment f = new MyFragment();
f.setEnterTransition(new Slide(Gravity.RIGHT));
f.setExitTransition(new Slide(Gravity.LEFT));
```

# 总结

在本章结束时，您应该了解基本的导航模式，并能将心中应用程序的想法转化为 Android 应用程序的实际结构。片段是 Android 开发中的关键概念，我们在本章中通过复习片段管理器和片段回退堆栈，以及学习如何应对它们之间的通信等常见问题，已经足够时间掌握它们。我们考虑了一个带有`PagerTabStrip`的`ViewPager`的工作示例，它将页面标题显示为标签，现在您知道如果需要如何自定义它。我们有一个应用程序的框架；这个项目可以在这一阶段保存，并用作您未来开发的模板。我们已经准备好继续发展我们的应用程序。

在下一章中，我们将了解如何创建和访问将填充我们的片段和`ViewPager`的内容，使我们的应用程序生动起来。


# 第三章：从云端创建和访问内容

在本章中，我们将学习如何通过我们的应用程序从网络消费内容；这些内容可以是 XML 或 JSON 文件中的项目列表（我们希望展示的东西），从互联网上获取。例如，如果我们正在构建一个显示当前天气状况的应用，我们将需要联系外部 API 来获取所需的所有信息。

我们将在 Parse 中创建自己的云端数据库，这项服务允许我们非常快速地完成这一操作，而无需创建和维护自己的服务器。除此之外，我们将在`MasteringAndroidApp`中填充数据库，以展示信息。

我们还将介绍关于使用 Google Volley 进行网络请求的最佳实践，使用超快的 HTTP 库 OkHttp，以及使用 Gson 高效解析请求的对象。我们将在本章中介绍以下主题：

+   创建你自己的云端数据库

+   使用 Parse 消费内容

+   Google Volley 和 OkHttp

+   使用 Gson 解析对象

# 创建你自己的云端数据库

在项目的这个阶段，我们必须开始构建我们自己的版本的`MasteringAndroidApp`。随意开发你自己的想法，并将数据库用于你自己的数据。以这个示例作为指导，你不必严格按照我写的代码逐行复制。实际上，如果你在本书的最后开发你自己的示例，你将得到一些你可以使用的东西。例如，你可以创建一个供个人使用的应用，如任务提醒、旅行日记、个人照片画廊，或任何适合在云端存储的东西。

你也可以尝试将这个应用货币化；在这种情况下，你应该尝试开发一些对用户来说有趣的东西。例如，可以是新闻源阅读器或是食谱阅读器；可以是任何可以提交内容到云端并通知用户有新内容可用的应用。

在此过程中，我们将解释`Application`类的重要性，该类用于在我们的项目中设置 Parse。

## Parse

如果你每秒的请求少于 30 次，Parse 是免费的。我想，如果你的应用有足够的用户每秒请求信息 30 次，也就是每分钟 1800 次，你肯定能负担得起升级到付费账户，甚至构建自己的服务器！这项服务是一种非常简单且可靠的方式来为你的应用覆盖服务器端。它还提供推送通知服务和分析，这也是它的一个优点。

我们将开始创建一个新的账户；之后，我们需要在 Parse 中为我们的应用命名。在这里，我将使用`MasteringAndroid`。命名应用后，你将进入账户的主页。我们需要导航到 **数据服务** | **移动** | **Android** | **原生 Java**。

下图展示了作为云的数据服务：

![Parse](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_03_01.jpg)

## 将 Parse SDK 添加到我们的项目中

为了从我们的应用访问数据服务，我们需要安装**Parse SDK**（**系统开发工具包**）。为此，Parse 指引我们查看一个快速入门指南，其中包含所有代码，包括我们应用的 API 密钥，这些代码可以直接复制并粘贴到我们的项目中。

基本上，我们需要完成两个步骤：

1.  第一步是下载一个`.jar`库文件，我们需要将其复制到我们项目中的`libs`文件夹内。复制后，我们需要告诉我们的构建系统在应用程序中包含这个库。为此，我们需要在我们应用文件夹中找到`build.gradle`文件（注意，我们的项目中有两个`build.gradle`文件），并添加以下几行：

    ```java
    dependencies {
      compile 'com.parse.bolts:bolts-android:1.+'
      compile fileTree(dir: 'libs', include: 'Parse-*.jar')
    }
    ```

1.  在下面的图片中，你可以看到两个名为`build.gradle`的文件；被选中的是正确的那个：![将 Parse SDK 添加到我们的项目](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_03_02.jpg)

1.  第二步是在我们的项目中初始化 Parse SDK；为此，我们可以直接导航到[`www.parse.com/apps/quickstart?app_id=masteringandroidapp`](https://www.parse.com/apps/quickstart?app_id=masteringandroidapp)。在链接中替换你自己的应用 ID，或者通过点击你的主页找到链接，如下面的截图所示：![将 Parse SDK 添加到我们的项目](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_03_03.jpg)

1.  点击**快速入门指南**后，转到**数据** | **移动** | **Android** | **原生** | **现有项目**。

1.  如果尚未添加，它会要求你在`AndroidManifest.xml`文件中添加`INTERNET`和`ACCESS_NETWORK_STATE`权限。

## Android 的 Application 类

接下来我们要注意的一点是，我们需要将初始化 Parse 的代码添加到我们的`Application`类中；然而，我们的项目中默认并没有创建`Application`类。我们需要创建并了解`Application`类是什么以及它是如何工作的。

要创建一个 Application 类，我们将右键点击我们的包，并创建一个名为`MAApplication`的新 Java 类，继承`Application`。一旦继承了`Application`，我们可以重写`onCreate`方法。然后，我们将在**类** | **生成.** | **重写方法** | **onCreate**中右键点击。

这将重写`onCreate`方法，我们将准备好在那里实现我们自己的功能。每次创建我们的`Application`时都会调用`onCreate`方法；因此，这是初始化我们的库和第三方 SDK 的正确位置。现在，你可以按照快速入门指南中所示复制并粘贴 Parse 初始化行：

### 提示

注意，这是唯一的，并且对于你自己的账户，你应该有自己的密钥。

```java
Parse.initialize(this, "yourKeyHere", "yourKeyHere");
```

为了完成，我们需要告诉我们的应用有一个新的`Application`类，并且这是我们想要使用的那个；如果我们不这样做，我们的`Application`类将不会被识别，`onCreate`也不会被调用。

在我们的清单文件中，我们需要在`<application>`标签内设置属性名称以匹配我们自己的应用。执行以下代码：

```java
<application
    android:name="MApplication "
    android:icon="@drawable/ic_launcher"
    android:label="@string/app_newname"
>
```

应用程序类封装了应用中的所有内容；活动包含在应用程序中，随后，片段包含在**活动**中。如果我们需要在应用中访问所有活动/片段的全局变量，这将是一个合适的位置。在下一章中，我们将了解如何创建这个全局变量。下面的图表是应用程序的图形结构：

![Android 的应用程序类](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_03_04.jpg)

## 创建数据库

众所周知，在本书中我们将创建的示例应用是一个包含与 Android 相关职位招聘的应用；因此，我们需要创建一个数据库来存储这些职位信息。

在开发过程中可以更改数据库（当应用程序发布并拥有用户时，这将变得更加困难）。然而，现在我们将从大局出发，创建整个系统，而不是拥有一个包含所有字段完成的数据库的最终版本。

要创建表，请点击如下截图所示的**Core**部分：

![创建数据库](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_03_05.jpg)

首先，通过点击**+ 添加类**按钮创建一个表，并将其命名为**JobOffer**，并添加以下属性，可以通过点击**Col+**按钮添加：

+   `objectId`：这是默认创建的：`String`

+   `title`：这是工作标题：`String`

+   `description`：这是工作描述：`String`

+   `salary`：这表示薪水或日薪：`String`

+   `company`：这表示提供工作的公司：`String`

+   `type`：这表示员工的类型，是永久性、合同工还是自由职业者：`String`

+   `imageLink`：这是公司的图片：`String`。

+   `Location`：这表示工作的地点：`String`

+   `createdAt`，`updatedAt`：这是工作的日期；列是使用默认日期创建的

要向表中添加数据，请选择左侧的表并点击**+ 行**。我们只需要完成我们创建的列；默认创建的列，如 ID 或日期，将自动完成。到目前为止，我们的表应该如下所示：

![创建数据库](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_03_06.jpg)

可以随意添加更多详细信息，例如联系人、电子邮件和手机号码。你也可以添加更多表；例如，一个新的`JobType`表，其中包含工作的类型和字段类型，而不是`String`，应该是`Relation<JobType>`。

我们已经有了示例所需的内容；接下来要做的就是使用我们的应用程序来消费这些数据。

# 在 Parse 中存储和消费内容

Parse 是一个非常强大的工具，它不仅让我们能够轻松地消费内容，还能将内容从我们的设备存储到云数据库中，如果使用传统方法来完成这项工作则是非常繁琐的。

例如，如果我们想从设备上传图片到自定义服务器，我们得创建一个`POST`请求并发送一个正确编码的表单，同时将图片作为`FileBody`对象附加在`MultiPartEntity`中，并导入 Apache HTTP 库：

```java
HttpClient httpclient = new DefaultHttpClient();
HttpPost httppost = new HttpPost("URL TO SERVER");

MultipartEntity mpEntity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);
File file = new File(filePath);
mpEntity.addPart("imgField", new FileBody(file, "application/octet"));

httppost.setEntity(mpEntity);
HttpResponse response = httpclient.execute(httppost);
```

现在，让我们看看 Parse 的替代方案：

```java
ParseFile imgFile = new ParseFile ("img.png", ImgByteArray);

ParseObject myParseObject = new ParseObject ("ParseClass");    
 myParseObject.put("imageField", imgFile);
 myParseObject.saveInBackground();
```

让我们不要忘记在 Parse 上处理错误。你可以非常优雅地简单编写：

```java
imageObj.saveInBackground(new SaveCallback() {
  @Override
  public void done(ParseException e) {
    if (e == null) {
      //Successful
    } else {
      //Error
    }
  }
});
```

## 存储内容

为了详细阐述 Parse 的简洁性，我们将从我们的应用程序将职位信息上传到 Parse 云。

为此，我们可以在联系片段内创建一个按钮，在应用的最终版本中设置为不可见，因为我们不希望用户自己上传职位信息。

通过这个按钮，我们将创建一个`ParseObject`，这类似于一个映射。我们将添加我们想要完成的字段，在这之后，我们将调用`saveInBackground()`方法，这个方法是用来上传对象的。执行以下代码：

```java
view.findViewById(R.id.addJobOffer).setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View view) {

    ParseObject jobOffer = new ParseObject("JobOffer");

    jobOffer.put("title", "Android Contract");
    jobOffer.put("description", "6 months rolling    contract. /n The client" +
    "is a worldwide known digital agency");
    jobOffer.put("type", "Contract");
    jobOffer.put("salary", "450 GBP/day");
    jobOffer.put("company", "Recruiters LTD");
    jobOffer.put("imageLink", "http://.....recruitersLTD_logo.png");
    jobOffer.put("location","Reading, UK");

    jobOffer.saveInBackground();
  }
});
```

如果在你的`MasteringAndroidApp`版本中，你想让用户上传内容，你可以为每个字段显示一个带有`EditText`的对话框，让用户编写职位信息，点击上传，然后你发送带有用户编写的字段的`jobOffer`对象。

运行应用，导航到**联系**，并点击按钮。如果数据正确上传，在浏览器中打开 Parse 云数据库时，你应该能看到刚刚上传的职位信息新增的一行。

### 提示

记得在`AndroidManifest.xml`中添加权限，`android.permission.ACCESS_NETWORK_STATE`和`android.permission.INTERNET`。

## 消费内容

我们在 Parse 云中的对象默认有一个对象标识符，它是`objectId`字段。让我们通过 ID 获取一个对象，之后，我们可以获取带有和没有过滤器的所有对象列表。运行以下代码：

```java
ParseQuery<ParseObject> query = ParseQuery.getQuery("JobOffer");
query.getInBackground("yourObjectID", new GetCallback<ParseObject>() {
  public void done(ParseObject object, ParseException e) {
    if (e == null) {
      // object will be our job offer
    } else {
      // something went wrong
    }
  }
});
```

当网络请求完成时，`ParseQuery`对象将异步执行网络查询。回调中包含的方法；`done (the ParseObject object, ParseException e)`将被执行。

检验结果的一个好方法是打印日志；在异常为`null`的情况下，意味着一切正常。

```java
if (e == null) {
  Log.d("PARSE_TEST",object.getString("Title"));
} else {
  // something went wrong
}
```

我们可以从`ParseObject`中提取每个字段，并在我们的应用中使用一个构造函数创建一个`JobOffer`类，其参数与对象的字段相匹配。使用以下代码片段：

```java
JobOffer myJobOffer = new JobOffer(object.getString("title), object.getString("description"), … );
```

然而，还有一种更好的方法。我们可以创建一个`JobOffer`类，它继承自`ParseObject`，并且所有字段都会自动转换成我们类中的变量。这样，我们就可以非常方便地使用我们自己的类，而不是`ParseObject`：

```java
public void done(JobOffer jobOffer, ParseException e) 
```

在类的顶部不要忘记添加`@ParseClassName("Name")`注解，让 Parse 知道我们要实例化云中的哪个对象，并在`MAApplication`中初始化 Parse 之前注册这个子类：

```java
public class MAApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();

        // Enable Local Datastore.
        Parse.enableLocalDatastore(this);

        ParseObject.registerSubclass(JobOffer.class);

        Parse.initialize(this, "KEY", "KEY");
    }

}

@ParseClassName("JobOffer")
public class JobOffer extends ParseObject {

    public JobOffer() {
        // A default constructor is required.
    }

    public String getTitle() {
        return getString("title");
    }

    public void setTitle(String title) {
        put("title", title);
    }

    public String getDescription() {
        return getString("description");
    }

    public void setDescription(String description) {
        put("description", description);
    }

    public String getType() {
        return getString("type");
    }

    public void setType(String type) {
        put("type", type);
    }
    //Continue with all the fields..

}
```

既然我们已经创建了自定义类，获取所有职位列表就更加容易了。如果我们愿意，可以用一个参数来过滤它。例如，我可以使用以下查询检索所有永久职位：

```java
ParseQuery< JobOffer > query = ParseQuery.getQuery("JobOffer");
query.whereEqualTo("type", "Permanent");
query.findInBackground(new FindCallback<JobOffer>() {
    public void done(List<JobOffer> jobsList, ParseException e) {
        if (e == null) {
            Log.d("score", "Retrieved " + jobsList.size() + " jobs");
        } else {
            Log.d("score", "Error: " + e.getMessage());
        }
    }
});
```

## 显示内容

一旦检索到对象列表，就可以创建`ListView`和一个接收对象作为参数的`Adapter`。为了结束对 Parse 的使用，我们将使用另一个功能，它允许我们直接从查询结果创建适配器；这样，我们就不必自己创建一个`Adapter`类了。

在这两种情况下，我们需要创建`ListView`和列表行的视图。现在，只需显示标题和描述的第一行即可。我们将在第七章《图像处理和内存管理》中自定义此内容并添加图像。按照以下方式创建`row_job_offer.xml`布局：

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout 
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:padding="10dp">

    <TextView
        android:id="@+id/rowJobOfferTitle"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="Title"
        android:textColor="#555"
        android:textSize="18sp"
        />

    <TextView
        android:id="@+id/rowJobOfferDesc"
        android:layout_marginTop="5dp"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:text="Description"
        android:textColor="#999"
        android:textSize="16sp"
        android:maxLines="1"
        android:ellipsize="marquee"
        />

</LinearLayout>
```

我们现在可以创建`ParseQueryAdapter`并自定义`getItemView()`方法了。这个适配器的一大优势在于，我们不需要通过查询下载数据，因为它是自动完成的；基本上，我们可以通过创建一个适配器来从云端展示项目列表。从未如此简单！

要覆盖类中的方法——在本例中，我们想要覆盖`getItemView`——我们可以创建一个子类，一个扩展`ParseQueryAdapter`的`MyQueryAdapter`类，并在该子类中覆盖方法。这是一个很好的解决方案，特别是如果我们想要在应用程序中多次实例化对象。

然而，有一种方法可以在不扩展类的情况下覆盖方法；我们可以在对象实例化后添加`{ }`。例如，参考以下代码：

```java
Object object = new Object() {

 //Override methods here

 }
```

使用这种方法，我可以创建一个新的`ParseQueryAdapter`并自定义`getItemView`，如下面的代码所示：

```java
ParseQueryAdapter<JobOffer> parseQueryAdapter = new ParseQueryAdapter<JobOffer>(getActivity(),"JobOffer") {

  @Override
  public View getItemView(JobOffer jobOffer, View v, ViewGroup parent) {

    if (v == null) {
      v = View.inflate(getContext(), R.layout.row_job_offer, null);
    }

    super.getItemView(jobOffer, v, parent);

    TextView titleTextView = (TextView) v.findViewById(R.id.rowJobOfferTitle);
    titleTextView.setText(jobOffer.getTitle());
    TextView descTextView = (TextView) v.findViewById(R.id.rowJobOfferDesc);
    descTextView.setText(jobOffer.getDescription());

    return v;
  }

};
```

我们现在将在`ListFragment`的布局中创建`ListView`，在`OnCreateView`中找到这个视图，为列表设置适配器，就这么多。不需要更多代码来检索项目并显示它们。如果您的列表为空，请确保在`MyPagerAdapter`中导入`com.packtpub.masteringandroidapp.fragments.ListFragment;`而不是`android.support.v4.app.ListFragment`；它们是不同的对象，使用后者将导致显示一个空的内置`ListFragment`。

![显示内容](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_03_07.jpg)

# Google Volley 和 OkHttp

要掌握 Android，我们不能依赖于像 Parse 这样的解决方案。作为开发者，我们必须准备面对不同的服务器端解决方案。我们不能总是使用`ParseObjects`，因为我们需要能够进行 HTTP `Post`请求并消费 JSON 或 XML 格式的数据。然而，这并不意味着我们必须手动完成所有这些工作；我们可以使用谷歌的官方库来帮助我们解析数据和网络请求。

为此，我们将研究强大的库**Google Volley**来管理我们的网络请求。我们还将讨论超快的 HTTP 客户端**OkHttp**，并将两者结合起来，为网络请求提供一个惊人的解决方案。

## Google Volley

根据官方定义和功能列表来自[`developer.android.com/training/volley/index.html`](https://developer.android.com/training/volley/index.html)的说明，"*Volley 是一个 HTTP 库，它让 Android 应用程序的网络通信变得更加简单，最重要的是，更快*”。

Volley 提供以下好处：

+   自动调度网络请求

+   支持多个并发网络连接

+   具有标准 HTTP 缓存一致性的透明磁盘和内存响应缓存

+   支持请求优先级

+   取消请求 API；这意味着你可以取消单个请求，或者设置要取消的请求块或作用域

+   易于定制；例如，重试和退避策略

+   强有序性，这使得你可以轻松地用从网络异步获取的数据正确填充 UI。

+   调试和跟踪工具

在 Volley 诞生之前，在 Android 中管理网络请求是一项艰巨的任务。几乎每个应用程序都会执行网络请求。诸如自定义重试（如果连接失败，我们需要再次尝试）以及管理并发网络连接等功能通常需要开发者手动实现。如今，我们习惯了这类库，但如果我们回想几年前的情形，Volley 是解决这一问题的绝佳方案。

在了解如何创建请求之前，我们需要理解 Volley 请求队列对象的概念，`RequestQueue`。Volley 执行的每个请求都必须添加到这个队列中，以便执行。这个想法是为了在我们的应用程序中有一个单一的请求队列，所有的网络请求都可以添加到其中，并且可以从应用程序的任何部分访问。我们将在第四章，*并发与软件设计模式*中看到如何拥有一个可以全局访问的对象实例。先看以下请求：

```java
// Instantiate the RequestQueue.
RequestQueue queue = Volley.newRequestQueue(this);
```

如果设备的 Android 版本晚于 Gingerbread，这个请求队列将只使用以下`HttpURLConnection`或`AndroidHttpClient`方法；在 Gingerbread 之前的版本中，`HttpURLConnection`是不可靠的。

```java
// If the device is running a version >= Gingerbread...
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {
    // ...use HttpURLConnection for stack.
} else {
    // ...use AndroidHttpClient for stack.
}
```

当请求队列实例化时，我们只需要向其中添加一个请求。例如，一个网络请求[`www.google.com`](https://www.google.com)，它会记录响应：

```java
String url ="https://www.google.com";

// Request a string response from the provided URL.
StringRequest stringRequest = new StringRequest(Request.Method.GET, url,
            new Response.Listener<String>() {
    @Override
    public void onResponse(String response) {
        // Display the first 500 characters of the response string.
        Log.d("Volley","Response is: "+ response.substring(0,500));
    }
}, new Response.ErrorListener() {
    @Override
    public void onErrorResponse(VolleyError error) {
        Log.d("Volley","That didn't work!");
    }
});

// Add the request to the RequestQueue.
queue.add(stringRequest);
```

请求将被执行，并且在应用程序主线程（也称为 UI 线程）中调用`onResponse(…)`或`onErrorResponse(…)`方法。我们将在第四章，*并发与软件设计模式*中更详细地解释 Android 中的线程。

## OkHttp

OkHttp 是来自 Square 公司的 Android 和 Java 的 HTTP 和 SPDY 客户端。它不是 Volley 的替代品，因为它不包括请求队列。实际上，我们可以将 OkHttp 作为 Volley 的底层，我们将在下一节中看到这一点。

根据官方定义，"*HTTP 是现代应用程序联网的方式。它是我们交换数据和媒体的方法。高效地处理 HTTP 能让你的东西加载得更快，节省带宽*”。

如果我们不需要处理队列中的请求，优先处理请求，或者安排请求，我们可以在应用程序中直接使用 OkHttp；我们不一定需要 Volley。

例如，以下方法打印给定 URL 响应的内容：

```java
OkHttpClient client = new OkHttpClient();

String run(String url) throws IOException {

  Request request = new Request.Builder()
      .url(url)
      .build();

  Response response = client.newCall(request).execute();
  return response.body().string();

}
```

除了比使用`AsyncTask`或`HttpUrlConnection`进行请求更为简单之外，让我们决定使用 OkHttp 的是 SPDY（**快速**）协议，它处理、标记化、简化和压缩 HTTP 请求。

## 极速的网络

如果我们想要保留 Volley 的特性，以便拥有灵活可管理的请求队列，并使用 SPDY 协议快速连接，我们可以结合使用 Volley 和 OkHttp。

这很容易做到；在实例化请求队列时，我们可以指定我们想要的`HttpStack`方法：

```java
RequestQueue queue = Volley.newRequestQueue(this, new OkHttpStack());
```

在这里，`OkHttpStack`是一个我们将通过扩展`HurlStack`自己创建的类，它将使用`OkUrlFactory`。这个`OkUrlFactory`将打开一个 URL 连接；这将在内部完成，无需重写`createConnection`方法：

```java
/**
 * An HttpStack subclass
 * using OkHttp as transport layer.
 */
public class OkHttpStack extends HurlStack {

    private final OkUrlFactory mFactory;

    public OkHttpStack() {
        this(new OkHttpClient());
    }

    public OkHttpStack(OkHttpClient client) {
        if (client == null) {
            throw new NullPointerException("Null client.");
        }
        mFactory = new OkUrlFactory(client);
    }
}
```

# JSON 和 Gson

作为一名 Android 开发者，迟早你将不得不处理 JSON 格式的网络请求。在某些情况下，你也可能会发现 XML，这使得将其转换为对象更加繁琐。了解如何通过发送 JSON 格式的参数执行网络请求以及如何以 JSON 格式消费数据是非常重要的。

JSON 和 GSON 是两回事；我们需要了解它们之间的区别。JSON，或 JavaScript 对象表示法，是一种开放标准格式，使用人类可读的文本传输由属性-值对组成的数据对象。它主要用于服务器和 Web 应用程序之间传输数据，作为 XML 的替代品。这是一个 JSON 文件的例子；如你所见，我们可以有不同类型的属性，我们还可以有嵌套的 JSON 结构：

```java
{
  "firstName": "Antonio",
  "lastName": "Smith",
  "isDeveloper": true,
  "age": 25,
  "phoneNumbers": [
    {
      "type": "home",
      "number": "212 555-1234"
    },
    {
      "type": "office",
      "number": "646 555-4567"
    }
  ],
  "children": [],
  "spouse": null
}
```

下面是两个带有参数的 JSON 格式发送网络请求的例子。这些例子涵盖了本章前面讨论过的 Volley 和 OkHttp：

```java
//With Volley

public void post(String param1, String param2, String url) {

  Map<String, String> params = new HashMap<String, String>();
  params.put("param1",param1);
  params.put("param2",param2);

  JsonObjectRequest stringRequest = new  JsonObjectRequest(Request.Method.POST, url, new JSONObject(params),  new Response.Listener<JSONObject>() {

    @Override
    public void onResponse(JSONObject responseJSON) {

    }, new Response.ErrorListener() {

      @Override
      public void onErrorResponse(VolleyError error) {
      }
    });

    // Add the request to the RequestQueue.
    requestQueue.add(stringRequest);
  }

  //With OkHttp

  public static final MediaType JSON
  = MediaType.parse("application/json; charset=utf-8");

  String post(String url, String json) throws IOException {
    RequestBody body = RequestBody.create(JSON, json);
    Request request = new Request.Builder()
    .url(url)
    .post(body)
    .build();
    Response response = client.newCall(request).execute();
    return response.body().string();

  }

  //To create a JSONObject from a string

  JSONObject responseJSON = new JSONObject(String json);
```

**Gson**（**谷歌 Gson**）是一个开源的 Java 库，用于将 Java 对象序列化和反序列化为（或从）JSON。

如果我们从自定义服务器以 JSON 格式下载应用程序的工作机会，格式将是以下这样：

```java
{
  "title": "Senior Android developer",
  "description": "A developer is needed for…",
  "salary": "25.000 € per year",
  .
  .
  .
}
```

同样，我们不想手动创建一个新对象并从 JSON 中获取所有参数进行设置；我们想要的是从 JSON 创建一个`JobOffer`对象。这称为**反序列化**。

要使用这个功能，我们需要在 `build.gradle` 中将 GSON 库作为依赖项导入：

```java
dependencies {
compile 'com.google.code.gson:gson:2.2.4'
}
```

Gson 有 `fromJSON` 和 `toJSON` 方法来分别进行序列化和反序列化。`fromJson` 方法接受要转换的 JSON 代码，以及我们希望转换成的对象的类作为输入。使用以下代码：

```java
Gson gson = new Gson();
JobOffer offer = gson.fromJson(JSONString, JobOffer.class);
```

如果我们请求数据时遇到的是一个列表而不是单一对象，这是典型的情况，我们就需要额外一步来获取类型：

```java
Gson gson = new Gson();
Type listType = new TypeToken<List<JobOffer>>(){}.getType();
List<JobOffer> listOffers = gson.fromJson(JSONString, listType);
```

最后，如果我们希望类的字段在反序列化时与 JSON 代码的字段名称不同，我们可以使用如下注解：

```java
import com.google.gson.annotations.SerializedName;

public class JobOffer extends ParseObject {

    @SerializedName("title")
    private String title;

    @SerializedName("description")
    private String desc;

    @SerializedName("salary")
    private String salary;
```

# 本章总结

在本章结束时，你应该能够自己在 Parse 中创建数据库并从应用程序中消费内容。你也应该掌握使用 Volley 和 OkHttp 进行网络请求的所有必要知识，特别是在执行网络请求和以 JSON 格式交换数据时。

在下一章中，我们将更详细地解释本章中用于 HTTP 库的一些模式。例如，我们将了解回调是什么以及它遵循的模式，以及在 Android 中其他常用的软件模式。


# 第四章：并发和软件设计模式

作为开发者，你不仅要编写可以工作的代码，而且要尽可能使用现有的解决方案，以便将来可以更好地维护你的代码。如果其他开发者需要在你项目中工作，他们会很快理解你在做什么。这要归功于软件设计模式。

为了正确理解这些模式，我们需要了解 Android 中并发工作原理的基本概述。我们将阐明 UI 线程是什么，并讨论在线程中延迟事件的不同机制。

我们将介绍在 Android 中最常用的模式，这将帮助我们进一步了解 Android 功能和开发技术，并成为更好的开发者。

+   并发

    +   处理器和线程

    +   AsyncTask

    +   服务

    +   IntentService

    +   加载器

+   Android 中的模式

    +   单例

    +   适配器和持有者

    +   观察者

# Android 中的并发

如果你是一个 Android 用户，你可能会对 ANR 消息有所了解。这可能不会让你立刻明白，所以请看以下图片：

![Android 中的并发](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_04_01.jpg)

**活动无响应**（**ANR**）发生在 UI 或主线程中运行代码时，阻止用户交互超过 5 秒钟。

在 Android 中，一个应用程序运行一个单一的线程，称为用户界面线程。我们将解释线程是什么，即使是没有编程背景的读者也能理解。我们可以将线程视为由 CPU 执行的指令或消息列。这些指令来自不同的地方；它们来自我们的应用程序以及操作系统。这个线程用于处理用户的响应、生命周期方法和系统回调。

CPU 逐个顺序地处理消息；如果它很忙，消息将在队列中等待执行。因此，如果我们在应用程序中执行长时间的操作并向 CPU 发送许多消息，我们将不会让 UI 消息得到执行，这将导致用户感受到手机无响应。

![Android 中的并发](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_04_02.jpg)

这个问题的解决方案似乎很明显：如果一个线程不够用，我们可以使用多个。例如，如果我们发起一个网络请求，这将在另一个线程中完成，并且当它结束时，它会与主线程通信以显示所请求的数据。

只有主线程或 UI 线程可以访问 UI；因此，如果我们 在另一个线程中执行任何后台计算，我们必须告诉主线程显示这些计算的结果，因为我们不能直接从那里做。

## 处理器和线程

我们之前描述的消息在一个名为`MessageQueue`的队列中运行，这个队列是每个线程独有的。一个处理器可以向这个队列发送消息。当我们创建一个处理器时，它与创建它的线程的`MessageQueue`相关联。

处理器用于两种情况：

+   向同一线程发送延迟消息

+   向另一个线程发送消息

这就是为什么在我们的`SplashActivity`中，我们将使用以下代码：

```java
new Handler().postDelayed(new Runnable() {
  @Override
  public void run() {

    Intent intent = new Intent(SplashActivity.this, MainActivity.class)

    startActivity(intent);
  }
},3000);
```

### 提示

当你创建一个新的`Handler()`方法时，请确保导入`Android.OS`处理程序。

在这里，我们使用了`postDelayed(Runnable, time)`方法来发送一个延迟的消息。在这种情况下，消息是一个可运行对象，表示可以执行的命令。

当`runOnUIThread()`活动内部有一个方法，允许我们向 UI 线程发送一个可运行对象时，就不需要创建处理程序与它通信。当我们有活动的上下文并且想在 UI 上运行某些内容时，这非常有用，例如从在后台执行的任务中向 UI 发布更新。

如果我们查看 Android 源代码中的方法，我们可以看到它只是简单地使用处理程序在 UI 线程中发布可运行对象：

```java
public final void runOnUiThread(Runnable action) {
  if (Thread.currentThread() != mUiThread) {
    mHandler.post(action);
  } else {
    action.run();
  }
}
```

通常，当我们想要在后台执行长时间任务并想要管理并行线程执行时，会手动创建线程。线程有一个`run()`方法，在其中执行指令，并在创建后启动以执行`run()`：

```java
Thread thread = new Thread(){

  @Override
  public void run() {
    super.run();
  }
};

thread.start();
```

创建线程和处理程序以执行后台任务的缺点是手动处理，如果我们有太多这样的任务，很容易导致应用程序变得难以阅读。Android 有其他机制来执行任务，如`AsyncTask`。

## 介绍 AsyncTasks

这可能是你在初学者级别看到的内容，但我们将从并发性的角度来查看它。`Asynctask`基于线程和处理程序，旨在轻松地在后台执行任务并发布 UI 更新。

要使用`AsyncTask`，需要对其进行子类化，它有四个可以被覆盖的方法：`onPreExecute`，`doInBackground`，`onProgressUpdate`和`onPostExecute`。

`OnPreExecute`方法在后台执行任何工作之前调用；这意味着它仍在 UI 线程上，并用于在开始任务前初始化变量和进度。

`doInBackground`方法在后台线程中执行。在这里，你可以调用`onProgressUpdate`，它向 UI 线程发布一个更新，例如，通过增加`ProgressBar`的值来显示任务的进度。

最后一个方法，`onPostExecute`，在后台任务完成并且在 UI 线程上运行时被调用。

以一个例子来说明：一个`AsyncTask`在后台运行需要*x*秒完成，并且每秒更新一次进度。进度条对象作为参数在构造函数中传递，秒数作为参数在`execute`方法中传递，在`doInBackground`中检索。请注意，在以下代码中，`<Integer,Integer,Void>`类型分别指的是输入参数、进度更新和后执行阶段的类型：

```java
public class MyAsyncTask extends AsyncTask<Integer,Integer,Void> {

  ProgressBar pB;

  MyAsyncTask(ProgressBar pB) {
    this.pB = pB;
  }

  @Override
  protected void onPreExecute() {
    super.onPreExecute();
    pB.setProgress(0);
  }

  @Override
  protected void onProgressUpdate(Integer... values) {
    super.onProgressUpdate(values);
    pB.setProgress(values[0]);
  }

  @Override
  protected Void doInBackground(Integer... integers) {
    for (int i = 0; i < 10; i++){
      try {
        Thread.sleep(1000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      onProgressUpdate(new Integer[]{i});
    }
    return null;
  }

  @Override
  protected void onPostExecute(Void o) {
    super.onPostExecute(o);
    Log.d("AsyncTask","Completed");
  }

}
```

创建了`AsyncTask`类后，以下是我们可以执行它的方式：

```java
new MyAsyncTask( progressBar ).execute(new Integer[]{10});
```

如果我们同时执行一个以上的`AsyncTask`，从 Android 3.0 版本开始，它们默认会按顺序运行。如果我们想要并行运行它们，将不得不创建一个执行器，并使用`THREAD_POOL_EXECUTOR`参数调用`executeOnExecutor()`。

至于限制，我们应该提到`AsyncTask`必须始终从主线程执行，并且不能在同一个对象中两次调用`execute()`；因此，它们不能循环。

## 了解服务

当下载文件或执行任何短操作时，`AsyncTask`是理想的，你可以在任务完成时通知 UI。然而，在 Android 中，有些情况你需要执行一个非常长的任务，可能不需要 UI 交互。例如，你可以有一个应用在服务器上打开一个套接字（直接通道），用于流式传输音频，以便于收听广播应用。

即使应用不在屏幕上显示，服务仍然可以运行；它默认在后台运行，但使用的是主线程。因此，如果我们想要执行长时间的任务，需要在服务内部创建一个线程。它必须在清单文件中声明，如果我们将其声明为公开，也可以从另一个应用中使用。

与`AsyncTask`相反，服务可以从任何线程触发；它们通过`onStartService()`方法触发，并通过`onStopService()`停止。

可选地，服务可以绑定到一个组件；一旦你绑定了组件，就会调用`onBind()`。当绑定发生时，我们有一个接口可供组件与服务交互。

### 一种服务类型 – `IntentService`

`IntentService`是`services`的一个子类，可以从一个意图触发。它创建一个线程并包含回调，以了解任务何时完成。

`IntentService`背后的想法是，如果你不需要并行运行任务，实现一个接收意图并顺序处理它们的服务，并在任务完成时通知，会更容易。

当我们调用`onStart`时，服务会不断运行；然而，`IntentService`被创建后，只在收到意图并完成任务的小时间段内运行。

一个真实的例子，我们可以考虑一个应用，在应用不在屏幕上显示时，需要在后台执行短任务。这可能是新闻阅读器应用的情况，它将新闻存储在您的设备上，以便您在没有网络连接的情况下离线访问。这可能是一个每天发布文章的报纸应用，允许用户在没有网络连接的飞机上或在通勤的火车上阅读文章。

想法是，当文章发布时，应用在后台运行时用户会收到推送通知。这个通知将触发一个意图去下载文章，这样用户下次打开应用时，不需要任何额外交互，文章就已经在那里了。

下载文章是一个小而重复的任务，需要在应用在后台、在线程中运行时完成，无需并行操作，这正是`IntentService`完美适用的场景。

## 引入装载器（Introducing loaders）

在结束并发部分之前，我们将快速了解一下`Loader`类。装载器的目的是在活动中更容易地异步加载数据，因此在片段中也是如此。从 Android 3.0 开始，每个活动都有`LoaderManager`来管理在其中使用的装载器。在基于片段导航的应用程序中，即使在你切换片段之间，也可以在活动级别执行后台操作。

装载器（Loaders）从数据源加载数据；当这个数据源发生变化时，它会自动刷新信息，这也是为什么装载器与数据库配合使用堪称完美。例如，一旦我们将装载器连接到数据库，这个数据库就可能被修改，而装载器将捕获这些更改。这将允许我们即时刷新用户界面，让用户立即看到变化。

在第八章《数据库和装载器》中，我们将实现`CursorLoader`来查询我们将在`MasteringAndroidApp`中创建的数据库。

# 模式的重要性（The importance of patterns）

当软件开发者需要开发具有特定功能的功能或组件时，通常可以用不同的方法来做；可以用不同的代码或不同的结构来实现。很可能同样的问题已经被其他开发者解决了无数次，以至于解决方案从具体实现中抽象出来，变成了一个模式。与其重新发明轮子，不如了解并实施这些模式。

在 Android 开发中，我们每天都在使用模式，即使我们没有意识到这一点。大多数时候，我们使用的是 Android 内置的模式实现。例如，当我们想要对按钮执行点击操作并设置`OnClickListener`时——换句话说，就是等待`onClick()`方法被调用——我们使用的是观察者模式实现。如果我们创建一个弹出窗口`AlertDialog`，我们使用的是`AlertDialog.Builder`，它使用了生成器模式（Builder pattern）。有许多这样的例子，但我们希望的是能够将这些解决方案应用到我们自己的问题中。

有不同类型的模式分为四类，以下是在开发 Android 应用时我们可能会遇到的一些例子：

+   创建（Creation）

    +   单例（Singleton）

    +   生成器（Builder）

    +   工厂方法（Factory method）

+   行为型（Behavioral）

    +   观察者（Observer）

    +   策略（Strategy）

    +   迭代器（Iterator）

+   结构型（Structural）

    +   适配器（Adapter）

    +   门面（Façade）

    +   装饰器（Decorator）

+   并发（Concurrency）

    +   锁（Lock）

    +   调度器（Scheduler）

    +   读写锁（Read-write lock）

为了完成`MasteringAndroidApp`，我们需要实现前三个组的模式。关于第四组（并发），我们需要了解 Android 中的并发概念，但我们不需要自己实现一个并发模式。

### 提示（Tip）

模式通常由 UML 图表示。

根据维基百科（[`en.wikipedia.org/wiki/Class_diagram`](http://en.wikipedia.org/wiki/Class_diagram)），“*在软件工程中，统一建模语言（UML）中的类图是一种静态结构图，通过显示系统的类，它们的属性，操作（或方法）以及对象之间的关系来描述系统的结构*”。

## 单例模式

软件设计模式中的单例（Singleton），限制了对象的创建，使其只能有一个实例。想法是全局访问这个单一对象。

这种模式通过如果之前没有创建过对象就创建对象，如果已经创建过就返回现有实例来实现。以下是 UML 图：

![单例模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_04_03.jpg)

在某些情况下，我们希望一个对象能够全局访问，并且我们希望它在应用程序中是唯一的。例如，在使用 Volley 时，我们希望保持一个唯一的请求队列，以便所有请求都在同一个队列中，并且我们希望它能够全局访问，因为我们需要从任何片段或活动中添加请求。

这是一个单例实现的基本示例：

```java
public class MySingleton {

    private static MySingleton sInstance;

    public static MySingleton getInstance(){
        if (sInstance == null) {
            sInstance = new MySingleton();
        }
        return sInstance;
    }
}
```

为了理解实现，请记住在 Java 中，静态变量与类相关联，而不是与对象相关联。同样，静态方法可以在不创建类实例的情况下调用。

拥有一个静态方法意味着它可以从应用程序的任何地方被调用。我们可以调用 `MySingleton.getInstance()`，它将始终返回相同的实例。第一次调用时，它会创建并返回它；后续调用时，它会返回已创建的实例。

使用单例和测试框架有一个缺点；我们将在第十一章，*在 Android 上调试和测试*中讨论这个问题。

### 应用程序类中的单例

我们可以将单例实现适配到 Android。鉴于在 `Application` 类中的 `onCreate` 方法在我们打开应用程序时只被调用一次，且 `Application` 对象不会被销毁，我们可以在应用程序中实现 `getInstance()` 方法。

应用这些更改后，我们的应用程序类将类似于以下结构：

```java
public class MAApplication extends Application {

  private static MAApplication sInstance;

  @Override
  public void onCreate() {
    super.onCreate();

    sInstance = this;

    // Enable Local Datastore.
    Parse.enableLocalDatastore(this);

    ParseObject.registerSubclass(JobOffer.class);

    Parse.initialize(this, "KEy", "KEY");
  }

  private static MAApplication getInstance(){
    return sInstance;
  }
}
```

现在，我可以在应用程序的任何地方调用 `MAAplication.getInstance()`，并在应用程序类中创建成员变量，通过单例 `MAAplication` 对象全局访问这些变量。例如，在 Volley 的情况下，我可以在 `OnCreate()` 中创建 `RequestQueue`，然后随时从 `MAAplication` 对象中获取它。执行以下代码：

```java
private RequestQueue mRequestQueue;

@Override
public void onCreate() {
  super.onCreate();

  sIntasnce = this;

  mRequestQueue = Volley.newRequestQueue(this);
  .
  .
  .
}

public RequestQueue getRequestQueue(){
  return mRequestQueue;
}
```

采用这种方法，我们有一个单例，即我们的 `Application` 类；其余的全局可访问对象都是成员变量。另一种选择是创建一个新的单例类来存储 Volley 请求队列以及每个需要全局访问的新请求单例。

### 提示

不要在`Application`类中使用这种方法来持久化数据。例如，如果我们点击主页按钮进入后台，过了一段时间后，Android 可能需要内存，会杀死应用。因此，下次打开应用时，即使看起来我们回到了上一个实例，也会创建一个新的实例。如果你在`onCreate`中重新初始化所有变量，并且后来不改变它们的状态，这样做是可以的。为了避免这种情况，请避免使用 setters。

## 观察者模式

这种模式在 Android 中得到了广泛的使用。我们讨论的大多数网络库都实现了这种模式，如果你是 Android 开发者，你肯定已经多次使用过它——我们需要实现它，甚至是为了检测按钮的点击。

观察者模式基于一个对象，即观察者，它注册其他对象来通知它们状态变化；在这里，监听状态变化的对象就是*观察者*。这种模式可以用来创建一个发布/订阅系统：

![观察者模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_04_04.jpg)

以下是一个注册多个观察者的模式的实现：

```java
public class MyObserved {

  public interface ObserverInterface{
    public void notifyListener();
  }

  List<ObserverInterface> observersList;

  public MyObserved(){
    observersList = new ArrayList<ObserverInterface>();
  }

  public void addObserver(ObserverInterface observer){
    observersList.add(observer);
  }

  public void removeObserver(ObserverInterface observer){
    observersList.remove(observer);
  }

  public void notifyAllObservers(){
    for (ObserverInterface observer : observersList){
      observer.notify();
    }
  }
}

public class MyObserver
implements MyObserved.ObserverInterface {

  @Override
  public void notify(){
    //Do something
  }
}
```

你会注意到，观察者可以是任何实现了接口—`ObserverInterface`的对象。这个接口是在被观察对象中定义的。

如果我们将这个与在 Android 中处理按钮点击的方式进行比较，我们执行`myButton.setOnClickListener(observer)`。在这里，我们添加了一个等待点击的观察者；这个观察者实现了`OnClick()`方法，这是在我们的案例中通知的方法。

在 Volley 中，当我们创建一个网络请求时，必须指定两个作为参数的监听器：`Response.Listener`和`Response.ErrorListener`，它们分别调用`onResponse()`和`onErrorResponse()`。这是观察者模式的清晰实现。

我们将在第六章，*CardView 和材料设计*中实现观察者模式的一个变体，即发布/订阅模式的例子。

## 介绍适配器模式

**适配器**是我们在创建`ListView`或`ViewPager`时在 Android 中使用的元素，但它也是一个众所周知的设计模式。我们将看看两者的定义及其关系。

一方面，适配器作为一种设计模式，它充当两个不兼容接口之间的桥梁。它允许两个不同的接口一起工作。这就像现实世界中的适配器，比如 SD 卡到 micro SD 卡的适配器，它允许两个不兼容的系统一起工作。如图所示，适配器被调用新的所需方法，但在内部，它调用来自*被适配者*的旧方法。

![介绍适配器模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_04_05.jpg)

另一方面，来自`android.widget.Adapter`的适配器是一个对象，我们用它为列表的每一行或视图分页的每一页创建视图。因此，它适配数据、一组元素和一组视图。

要实现一个适配器，我们必须扩展`BaseAdapter`并重写`getView()`和`getCount()`方法。通过这两个方法，适配器将知道它需要创建多少个视图以及如何创建这些视图。

在下一章中，我们将更深入地探讨这个主题，同时使用`ListViews`，我们还将讨论`ViewHolder`模式，这是在 Android 中使用适配器和列表时的一种特殊模式。

# 总结

在本章结束时，你应该能够理解 Android 中的并发性以及与之工作的所有不同机制。你应该知道有一个主线程用于更新 UI，我们可以创建后台线程来执行其他任务。你还必须知道让应用在后台（换句话说，不在屏幕上）执行任务与在后台线程中执行任务的区别。你也应该知道软件设计模式的重要性，并能够实现其中的一些。

在下一章中，我们将学习如何使用列表视图，我们将实现一个适配器，并发现一种新模式`ViewHolder`，它将是理解从 Android Lollipop 开始引入的`ListView`和`RecyclerView`之间区别的关键。


# 第五章：列表和网格

在本章中，我们将处理列表和网格。几乎在市场上的每个应用中都可以找到列表或元素矩阵。在 Android 上显示元素列表是你在基础层面需要学习的东西；然而，还有很多需要扩展和了解的内容。

了解我们可以在这里使用哪些模式，如何回收视图，以及如何在同一个列表中用不同的视图显示不同类型的元素是非常重要的。

有了这个想法，我们将能够理解为什么 `RecyclerView` 是 `ListView` 的继任者，并且我们将学习如何使用这个组件实现列表。因此，在本章中我们将涵盖以下内容：

+   从列表开始

    +   ListView

    +   自定义适配器

    +   视图回收

    +   使用 ViewHolder 模式

+   介绍 RecyclerView

    +   列表、网格或堆叠

    +   实现

+   OnItemClick

# 从列表开始

如果你听说过 `RecyclerView`，你可能会想知道为什么我们要学习 `ListView`。`RecyclerView` 小部件是新的，它随着 Android Lollipop 一起出现，在显示项目列表时是一场革命；它可以垂直和水平显示列表或网格，或者带有漂亮的动画以及其他改进。

回答这个问题，即使 `RecyclerView` 在某些情况下更有效和灵活，它需要额外的编码来实现相同的结果，所以仍然有使用 `ListView` 的理由。例如，`RecyclerView` 中没有用于项目选择的 `onItemClickListener()`，点击项目时也没有视觉反馈。如果我们不需要定制和动画，例如一个简单的数据选择器弹出窗口，这可能是一个我们只需要选择一个国家的对话框。在这种情况下，使用 `ListView` 而不是 `RecyclerView` 是完全没问题的。

另一个从 `ListView` 开始的原因是 `RecyclerView` 解决了与 `ListViews` 一起工作时出现的多数问题。因此，通过从 `ListView` 开始并解决这些问题，我们将完全理解 `RecyclerView` 的工作原理以及为什么要以这种方式实现它。因此，我们将单独解释使用的模式，以便对组件有一个全局的了解。

这是一个基本的 `AlertDialog` 示例，目的是选择一个项目；在这种情况下，使用 `ListView` 是非常有意义的：

![Starting with lists](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_01.jpg)

## 使用内置视图的 ListViews

当你第一次实现 `ListView` 时，可能会觉得它微不足道且简单；然而，当你花更多时间在 Android 上时，你会意识到它会变得多么复杂。仅仅通过每一行都有图片的大量元素列表，你就很容易发现性能和内存问题。如果你尝试实现复杂的 UI，比如让同一个列表显示不同的项目，创建具有不同视图的不同行，甚至尝试对某些项目进行分组同时显示一个节标题，这些都可能让人头疼。

让我们从最简单的方式来实现一个列表开始，使用 Android 内置的条目布局，这是为了在之前讨论的简单列表中使用而创建的。为了显示列表，我们将在 `AlertDialog` 中包含它，当我们点击设置片段中的按钮时，它将显示出来。我会将按钮的文本设置为 `Lists Example`（列表示例）。

第一步是在 `settings_fragment.xml` 中创建按钮；一旦创建，我们就可以为按钮设置点击监听器。现在，我们对于软件模式有了更多的了解，而不是以下这种方式设置点击监听器：

```java
view.findViewById(R.id.settingsButtonListExample).setOnClickListener(new View.OnClickListener() {
  @Override
  public void onClick(View view) {
    //Show the dialog here
  }
});
```

我们将以更有条理的方式进行操作，尤其是因为我们知道在设置屏幕上，将会有很多按钮，我们希望在同一地方处理所有的点击事件。我们不会在方法调用内部创建 `onClickListener`，而是通过将 `onClickListener` 设置为 `this` 来让 `Fragment` 实现 `OnClikListener`。这里的 `this` 关键字指的是整个片段，因此片段将在 `onClick` 方法中监听点击事件，一旦 `Fragment` 实现 `View.OnClickListener`，这是必须实现的。

`OnClick()` 方法接收一个视图，即被点击的视图。如果我们将该视图的 ID 与按钮的 ID 进行比较，我们就会知道是按钮还是设置了 `clickListener` 的其他视图被点击了。

在定义类时只需键入 `implements View.OnClickListener`，你将被要求实现必填的方法：

```java
/**
* Settings Fragment
*/
public class SettingsFragment extends Fragment implements View.OnClickListener {

  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container,
  Bundle savedInstanceState) {
    // Inflate the layout for this fragment
    View view = inflater.inflate(R.layout.fragment_settings, container, false);

    view.findViewById(R.id.settingsButtonListExample).setOnClickListener(this);

    view.findViewById(R.id.ViewX).setOnClickListener(this);

    view.findViewById(R.id.imageY).setOnClickListener(this);

    return view;
  }

  @Override
  public void onClick(View view) {
    switch (view.getId()){
      case (R.id.settingsButtonListExample) :
      showDialog();
      break;
      case (R.id.viewX) :
      //Example
      break;
      case (R.id.imageY) :
      //Example
      break;

      //...
    }
  }

  public void showListDialog(){
    //Show Dialog here
  }
}
```

你会注意到，我们将显示列表对话框的逻辑也移动到了一个外部方法中，这样在 `onClick();` 中结构更容易阅读。

继续关于对话框的讨论，我们可以显示一个具有 `setAdapter()` 属性的 `AlertDialog`，它自动将内部 `ListView` 的条目绑定在一起。或者，我们可以为对话框创建一个带有 `ListView` 的视图，然后将适配器设置给那个 `ListView`：

```java
/**
*  Show a dialog with different options to choose from
*/
public void showListDialog(){

  AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());

  final ArrayAdapter<String> arrayAdapter = new ArrayAdapter<String>(
  getActivity(),
  android.R.layout.select_dialog_singlechoice);
  arrayAdapter.add("Option 0");
  arrayAdapter.add("Option 1");
  arrayAdapter.add("Option 2");

  builder.setTitle("Choose an option");

  builder.setAdapter(arrayAdapter,
  new DialogInterface.OnClickListener() {
    @Override
    public void onClick(DialogInterface dialogInterface, int i) {
      Toast.makeText(getActivity(),"Option choosen "+i, Toast.LENGTH_SHORT).show();
      dialogInterface.dismiss();
    }
  });

  builder.show();
}
```

这个对话框将显示一个指示点击选项的消息。我们使用了 `android.R.layout.select_dialog_singlechoice` 作为我们行的视图。

这些是我们应用程序内置列表布局的几个不同示例，具体取决于应用的主题。例如，在 4.4 KitKat 和 5.0 Lollipop 中，`android.R.layout.simple_list_item_1` 的对话框看起来是不同的，以下是它的样子：

![使用内置视图的 ListViews](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_02.jpg)

`android.R.layout.simple_list_item_2` 以下是带有两行的布局看起来类似的：

![使用内置视图的 ListViews](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_03.jpg)

这是一个 `android.R.layout.simpleListItemChecked` 的示例，我们可以将选择模式更改为多选或单选：

![使用内置视图的 ListViews](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_04.jpg)

这是 `android.R.layout.activityListItem`，我们有一个图标和文本：

![使用内置视图的 ListViews](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_05.jpg)

在创建布局时，我们可以访问这些内置的布局组件以进一步调整视图。这些组件被命名为`android.resource.id.Text1`，`android.resource.id.Text2`，`android.resource.id.Icon`等等。

现在，我们知道了如何创建带有功能和视图的列表。是时候创建我们自己的适配器并手动实现功能和视图了。

## 创建自定义适配器

当你寻找工作时，除了查看职位信息，你还会向不同的软件公司或 IT 招聘公司提交你的简历，这些公司会为你找到合适的公司。

在我们的联系人片段中，我们将创建一个按国家排序的列表，显示这些公司的联系人详细信息。将会有两种不同的行：一种用于国家头部，另一种用于公司详细信息。

我们可以在我们的 Parse 数据库中创建另一个表，名为`JobContact`，包含以下字段：

![创建自定义适配器](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_06.jpg)

我们将从服务器请求工作联系人并构建一个项目列表，该列表将发送到适配器以构建列表。在列表中，我们将发送两个不同的元素：公司和国家。我们可以生成一个项目列表并将它们作为对象添加。我们的两个类将类似于以下内容：

```java
@ParseClassName("JobContact")
public class JobContact extends ParseObject {

  public JobContact() {
    // A default constructor is required.
  }

  public String getName() {
    return getString("name");
  }

  public String getDescription() {
    return getString("description");
  }

  public String getCountry() {
    return getString("country");
  }

  public String getEmail() {
    return getString("email");
  }

}

public class Country {

  String countryCode;

  public Country(String countryCode) {
    this.countryCode = countryCode;
  }

}
```

一旦我们从[`www.parse.com`](http://www.parse.com)按国家排序下载了信息，我们就可以构建我们的项目列表，遍历解析列表，并在检测到不同国家时添加一个国家头部。执行以下代码：

```java
public void retrieveJobContacts(){
  ParseQuery<JobContact> query = ParseQuery.getQuery("JobContact");
  query.orderByAscending("country");
  query.findInBackground(new FindCallback<JobContact>() {
    @Override
    public void done(List<JobContact> jobContactsList, ParseException e) {
      mListItems = new ArrayList<Object>();
      String currentCountry = "";
      for (JobContact jobContact: jobContactsList) {
        if (!currentCountry.equals(jobContact.getCountry())){
          currentCountry = jobContact.getCountry();
          mListItems.add(new Country(currentCountry));
        }
        mListItems.add(jobContact);
      }
    }
  });
}
```

现在我们有了包含头部的列表，我们可以基于这个列表创建`Adapter`，它将在构造函数中作为参数发送。自定义`Adapter`的最佳方式是创建一个扩展`BaseAdapter`的子类。一旦我们这样做，我们将被要求实现以下方法：

```java
public class JobContactsAdapter extends BaseAdapter {
  @Override
  public int getCount() {
    return 0;
  }

  @Override
  public Object getItem(int i) {
    return null;
  }

  @Override
  public long getItemId(int i) {
    return 0;
  }

  @Override
  public View getView(int i, View view, ViewGroup viewGroup) {
    return null;
  }
}
```

这些方法必须根据我们想要显示的数据来实现；例如，`getCount()`必须返回列表的大小。我们需要实现一个接收两个参数的构造函数：列表和上下文。上下文在`getView()`方法中填充列表是必要的。下面是没有实现`getView()`的适配器样子：

```java
public class JobContactsAdapter extends BaseAdapter {

  private List<Object> mItemsList;
  private Context mContext;

  public JobContactsAdapter(List<Object> list, Context context){
    mItemsList = list;
    mContext = context;
  }

  @Override
  public int getCount() {
    return mItemsList.size();
  }

  @Override
  public Object getItem(int i) {
    return mItemsList.get(i);
  }

  @Override
  public long getItemId(int i) {
    //Not needed
    return 0;
  }

  @Override
  public View getView(int i, View view, ViewGroup viewGroup) {
    return null;
  }
}
```

在我们的案例中，我们可以创建两种不同的视图；因此，除了必须实现的方法外，我们还需要实现两个额外的方法：

```java
@Override
public int getItemViewType(int position) {
  return mItemsList.get(position) instanceof Country ? 0 : 1;
}

@Override
public int getViewTypeCount() {
  return 2;
}
```

`getItemViewType`方法会返回`0`如果元素是一个国家，或者`1`如果元素是一个公司。借助这个方法，我们可以实现`getView()`。如果是国家，我们填充`row_job_country.xml`布局，其中包含`ImageView`和`TextView`；如果是公司，我们填充`row_job_contact.xml`布局，其中包含三个文本视图：

```java
@Override
public View getView(int i, View view, ViewGroup viewGroup) {

  View rowView = null;
  switch (getItemViewType(i)){

    case (0) :
    rowView = View.inflate(mContext, R.layout.row_job_country,null);
    Country country = (Country) mItemsList.get(i);
    ((TextView) rowView.findViewById(R.id.rowJobCountryTitle)).setText(country.getName());
    ((ImageView) rowView.findViewById(R.id.rowJobCountryImage)).setImageResource(country.getImageRes(mContext));
    break;

    case (1) :
    rowView = View.inflate(mContext, R.layout.row_job_contact,null);
    JobContact company = (JobContact) mItemsList.get(i);
    ((TextView) rowView.findViewById(R.id.rowJobContactName)).setText(company.getName());
    ((TextView) rowView.findViewById(R.id.rowJobContactEmail)).setText(company.getEmail());
    ((TextView) rowView.findViewById(R.id.rowJobContactDesc)).setText(company.getDescription());
  }

  return rowView;
}
```

最后，我们可以在`contact_fragment.xml`中创建`ListView`，并将适配器设置到这个列表。但是，我们将采取捷径，使用`android.support.v4.ListFragment`；这是一个已经膨胀了包含`ListView`的视图并包含`setListAdapter()`方法的片段，该方法将适配器设置到内置的`ListView`。从该片段扩展，我们的`ContactFragment`类将类似于以下代码：

```java
public class ContactFragment extends android.support.v4.app.ListFragment {

  List<Object> mListItems;

  public ContactFragment() {
    // Required empty public constructor
  }

  @Override
  public void onViewCreated(View view, Bundle bundle) {
    super.onViewCreated(view,bundle);
    retrieveJobContacts();
  }

  public void retrieveJobContacts(){
    ParseQuery<JobContact> query = ParseQuery.getQuery("JobContact");
    query.orderByAscending("country");
    query.findInBackground(new FindCallback<JobContact>() {
      @Override
      public void done(List<JobContact> jobContactsList, ParseException e) {
        mListItems = new ArrayList<Object>();
        String currentCountry = "";
        for (JobContact jobContact: jobContactsList) {
          if (!currentCountry.equals(jobContact.getCountry())){
            currentCountry = jobContact.getCountry();
            mListItems.add(new Country(currentCountry));
          }
          mListItems.add(jobContact);
        }
        setListAdapter(new JobContactsAdapter(mListItems,getActivity()));
      }
    });
  }
}
```

在视图创建后调用`retrieveJobContacts()`方法，我们实现了以下结果：

![创建自定义适配器](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_07.jpg)

我们展示的旗帜是`drawable`文件夹中的图片，其名称与国家代码相匹配，*drawable/ "country_code" .png*。我们可以在`Country`类内部通过以下方法设置资源标识符到`ImageView`并获取它们来展示这些图片：

```java
public int getImageRes(Context ctx){
  return ctx.getResources().getIdentifier(countryCode, "drawable", ctx.getPackageName());
}
```

这是一个基础版本的`ListView`，包含两种不同类型的行。这个版本还远非完美，其性能存在不足。它没有回收视图，并且每次创建行时都会查找小部件的 ID。我们将在下一节中解释并解决这个问题。

## 回收视图

在使用`ListView`时，我们需要牢记行数是一个变量，即使我们尽可能快速地滚动，我们也希望列表流畅无阻。幸运的是，Android 在这方面为我们提供了很大帮助。

当我们滚动`ListView`时，屏幕一侧不再可见的视图会被复用并在另一侧重新显示。这样，Android 节省了视图的膨胀；当它膨胀时，视图必须遍历 xml 节点，实例化每个组件。这种额外的计算可能是流畅列表和卡顿列表之间的区别。

![回收视图](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_08.jpg)

`getView()`方法接收一个待回收的视图作为参数，如果没有视图待回收，则接收 null。

为了利用这种视图回收，我们需要停止每次都创建视图，而是复用作为参数传入的视图。我们仍然需要在回收的视图中更改文本视图和行内小部件的值，因为它具有与其先前位置的初始值相对应的值。在我们的示例中，我们有一个额外的复杂性；我们不能将国家视图回收用于公司视图，因此我们只能回收相同视图类型的视图。然而，再次强调，Android 通过内部使用我们实现的`getItemViewType`方法来为我们进行这个检查：

```java
@Override
public View getView(int i, View view, ViewGroup viewGroup) {

  switch (getItemViewType(i)){

    case (0) :
    if (view == null){
      view = View.inflate(mContext, R.layout.row_job_country,null);
    }
    Country country = (Country) mItemsList.get(i);
    ((TextView) view.findViewById(R.id.rowJobCountryTitle)).setText(country.getName());
    ((ImageView) view.findViewById(R.id.rowJobCountryImage)).setImageResource(country.getImageRes(mContext));
    break;

    case (1) :
    if (view == null){
      view = View.inflate(mContext, R.layout.row_job_contact,null);
    }
    JobContact company = (JobContact) mItemsList.get(i);
    ((TextView) view.findViewById(R.id.rowJobContactName)).setText(company.getName());
    ((TextView) view.findViewById(R.id.rowJobContactEmail)).setText(company.getEmail());
    ((TextView) view.findViewById(R.id.rowJobContactDesc)).setText(company.getDescription());
  }

  return view;
}
```

## 应用 ViewHolder 模式

请注意，在`getView()`中，每次我们想要为`TextView`设置文本时，都会使用`findViewById()`方法在行视图中搜索这个`TextView`；即使行被回收，我们仍然需要再次找到`TextView`来设置新值。

我们可以创建一个名为`ViewHolder`的类，它通过保存行内控件搜索的计算来引用控件。这个`ViewHolder`类将只包含对控件的引用，我们可以通过`setTag()`方法在行和其`ViewHolder`类之间保持引用。`View`对象允许我们设置一个对象作为标签，并在之后检索它；我们可以通过指定一个键来添加任意数量的标签：`setTag(key)`或`getTag(key)`。如果没有指定键，我们可以保存和检索默认标签。

按照这种模式，在我们第一次创建视图时，我们将创建`ViewHolder`类并将其设置为视图的标签。如果视图已经创建并且我们正在回收它，我们只需简单地检索持有者。执行以下代码：

```java
@Override
public View getView(int i, View view, ViewGroup viewGroup) {

  switch (getItemViewType(i)){

    case (0) :
    CountryViewHolder holderC;
    if (view == null){
      view = View.inflate(mContext, R.layout.row_job_country,null);
      holderC = new CountryViewHolder();
      holderC.name = (TextView) view.findViewById(R.id.rowJobCountryTitle);
      holderC.flag = (ImageView) view.findViewById(R.id.rowJobCountryImage);
      view.setTag(view);
    } else {
      holderC = (CountryViewHolder) view.getTag();
    }
    Country country = (Country) mItemsList.get(i);
    holderC.name.setText(country.getName());
    holderC.flag.setImageResource(country.getImageRes(mContext));
    break;
    case (1) :
    CompanyViewHolder holder;
    if (view == null){
      view = View.inflate(mContext, R.layout.row_job_contact,null);
      holder = new CompanyViewHolder();
      holder.name = (TextView) view.findViewById(R.id.rowJobContactName);
      holder.email = (TextView) view.findViewById(R.id.rowJobContactEmail);
      holder.desc = (TextView) view.findViewById(R.id.rowJobOfferDesc);
      view.setTag(holder);
    } else {
      holder = (CompanyViewHolder) view.getTag();
    }
    JobContact company = (JobContact) mItemsList.get(i);
    holder.name.setText(company.getName());
    holder.email.setText(company.getEmail());
    holder.desc.setText(company.getDescription());
  }

  return view;
}

private class CountryViewHolder{

  public TextView name;
  public ImageView flag;

}

private class CompanyViewHolder{

  public TextView name;
  public TextView email;
  public TextView desc;

}
```

为了简化这段代码，我们可以在每个持有者内部创建一个名为`bindView()`的方法；它将获取一个国家或公司对象并填充控件：

```java
CountryViewHolder holderC;
if (view == null){
  view = View.inflate(mContext, R.layout.row_job_country,null);
  holderC = new CountryViewHolder(view);
  view.setTag(view);
} else {
  holderC = (CountryViewHolder) view.getTag();
}
holderC.bindView((Country)mItemsList.get(i));
break;

private class CountryViewHolder{

  public TextView name;
  public ImageView flag;

  public CountryViewHolder(View view) {
    this.name = (TextView) view.findViewById(R.id.rowJobCountryTitle);
    this.flag = (ImageView) view.findViewById(R.id.rowJobCountryImage);
  }

  public void bindView(Country country){
    this.name.setText(country.getName());
    this.flag.setImageResource(country.getImageRes(mContext));
  }

}
```

现在我们来完成`ListView`性能改进列表。如果需要加载图像或执行长时间的操作，我们需要在`getView()`中创建`AsyncTask`方法，以避免在滚动时进行繁重操作。例如，如果我们想在每一行显示从互联网下载的图像，我们会有一个`LoadImageAsyncTask`方法，我们将使用持有者和要下载图像的 URL 来执行它。当`Asynctask`方法完成时，它将有一个对持有者的引用，因此能够显示图像：

```java
public View getView(int position, View convertView,
ViewGroup parent) {

  ...

  new LoadImageAsyncTask(list.get(position).getImageUrl, holder)
  .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, null);

  return convertView;
}
```

现在我们知道了所有改进`ListView`性能的不同技术，我们准备引入`RecyclerView`。通过在实现中应用这些技术的大部分，我们将能够轻松识别它。

# 引入 RecyclerView

`RecyclerView`在 Android 5.0 Lollipop 中引入，并被谷歌定义为比`ListView`更灵活和先进的版本。它基于一个类似于`ListView`的`Adapter`类，但强制使用`ViewHolder`类以提高性能和模块化，正如我们在前一部分所看到的。当我们把条目表示与组件分离，允许动画、条目装饰和布局管理器来处理工作时，灵活性便体现出来了。

`RecyclerView`通过使用`RecyclerView.ItemAnimator`处理添加和移除动画，我们可以通过继承它来自定义动画。如果你从数据源显示数据，或者数据发生变化，例如添加或移除条目，可以调用`notifyItemInserted()`或`notifyItemRemoved()`来触发动画。

要添加分隔符、分组条目或突出显示一个条目，我们可以使用`RecyclerView.ItemDecoration`。

使用`ListView`的主要区别之一是使用布局管理器来定位项目。在`ListView`中，我们知道项目将始终垂直显示，如果我们想要网格，可以使用`GridView`。布局管理器使我们的列表更加灵活，因为我们可以按需显示元素，甚至可以创建自己的布局管理器。

## 使用列表、网格或堆叠布局

默认情况下，我们有三个内置的布局管理器：`LinearLayoutManager`、`GridLayoutManager`和`StaggeredLayoutManager`。

`LinearLayoutManager`以列表形式对齐显示项目，我们可以指定方向——垂直或水平。

![使用列表、网格或堆叠](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_09.jpg)

`GridLayoutManager`以矩阵形式显示项目，我们可以指定列和行：

![使用列表、网格或堆叠](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_10.jpg)

`StaggereGriddLayoutManager`以交错的方式显示项目；这些项目可以有不同的宽度和高度，我们可以使用`setGapStrategy()`控制它们的显示方式。

![使用列表、网格或堆叠](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_11.jpg)

## 实现`RecyclerView`

继续使用`MasteringAndroidApp`，我们将再次实现职位列表，移除`ParseQueryAdapter`并用`RecyclerView`替代。我们仍然会从 Parse 查询数据，但这次，我们将做的是将项目列表保存在一个变量中，并使用它来构建`RecyclerView.Adapter`，供`RecyclerView`使用。

`RecyclerView`包含在 v7 支持库中；将之包含在项目中的最佳方式是打开项目结构，点击依赖项标签，并搜索`RecyclerView`。将展示如下截图所示的结果列表：

![实现 RecyclerView](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_12.jpg)

这相当于在`build.gradle`的依赖项中添加以下这行代码：

```java
dependencies {
  compile fileTree(dir: 'libs', include: ['*.jar'])
  compile 'com.android.support:appcompat-v7:21.0.3'
  compile 'com.parse.bolts:bolts-android:1.+'
  compile fileTree(dir: 'libs', include: 'Parse-*.jar')
  compile 'com.mcxiaoke.volley:library-aar:1.0.1'
  compile 'com.android.support:recyclerview-v7:21.0.3'
}
```

添加完这行代码后，我们将点击**同步 Gradle 与项目文件**来更新依赖项，并准备在 XML 中使用`RecyclerView`。

打开`fragment_list.xml`，将现有的`ListView`替换为`RecyclerView`，如下所示：

```java
<android.support.v7.widget.RecyclerView
  android:id="@+id/my_recycler_view"
  android:scrollbars="vertical"
  android:layout_width="match_parent"
  android:layout_height="match_parent"/>
```

添加后如果没有出现错误，说明依赖项已经正确添加。

下一步是创建适配器。这个适配器与我们为工作联系人创建的适配器略有不同；我们不再继承`BaseAdapter`，而是继承`RecyclerView.Adapter <RecyclerView.MyViewHolder>`，这是一个在创建`JobOfferAdapter`适配器类后实现`ViewHolder`模式的适配器。但在继承之前，我们必须创建一个内部的`MyViewHolder`类，继承`RecylcerView.ViewHolder`。至此，我们有以下代码：

```java
public class JobOffersAdapter  {

  public class MyViewHolder extends RecyclerView.ViewHolder{

    public TextView textViewName;
    public TextView textViewDescription;

    public  MyViewHolder(View v){
      super(v);
      textViewName = (TextView)v.findViewById(R.id.rowJobOfferTitle);
      textViewDescription = (TextView)v.findViewById(R.id.rowJobOfferDesc);
    }
  }
}
```

现在是从`RecyclerView.Adapter<JobsOfferAdapter.MyViewHolder>`扩展`JobOffersAdapter`类。我们将被要求实现以下方法：

```java
@Override
public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
  return null;
}

@Override
public void onBindViewHolder(MyViewHolder holder, int position) {

}

@Override
public int getItemCount() {
  return 0;
}
```

与`JobsContactsAdapter`中的方法相同，我们通过接收工作机会列表创建构造函数，并根据该列表实现适配器方法。

`OnBindViewHolder`方法会接收到带有位置的 holder；我们需要做的就是从列表中获取该位置的工作机会，并用这些值更新 holder 中的文本视图。`OnCreateViewHolder`方法将填充视图；在这种情况下，我们只有一个类型，因此我们忽略`ViewType`参数。下面我们将展示一种使用父级上下文来填充视图的方法，它会作为参数传入。

最后，`getItemCount`将返回工作机会的数量。完成上述所有任务后，我们新的适配器将使用以下代码创建：

```java
public class JobOffersAdapter extends RecyclerView.Adapter<JobOffersAdapter.MyViewHolder>  {

  private  List<JobOffer> mOfferList;

  public JobOffersAdapter(List<JobOffer> offersList) {
    this.mOfferList = offersList;
  }

  @Override
  public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
    View v = LayoutInflater.from(parent.getContext()).inflate(R.layout.row_job_offer, parent, false);
    return new MyViewHolder(v);
  }

  @Override
  public void onBindViewHolder(MyViewHolder holder, int position) {
    holder.textViewName.setText(mOfferList.get(position).getTitle());
    holder.textViewDescription.setText(mOfferList.get(position).getDescription());
  }

  @Override
  public int getItemCount() {
    return mOfferList.size();
  }

  public class MyViewHolder extends RecyclerView.ViewHolder{

    public TextView textViewName;
    public TextView textViewDescription;

    public  MyViewHolder(View v){
      super(v);
      textViewName = (TextView)v.findViewById(R.id.rowJobOfferTitle);
      textViewDescription = (TextView)v.findViewById(R.id.rowJobOfferDesc);
    }
  }
}
```

这就是我们需要适配器完成的所有工作；现在，我们需要初始化`RecyclerView`并设置布局管理器以及适配器。适配器必须使用从 Parse 获取的对象列表实例化，就像我们在上一个适配器中获取工作联系人一样。首先，在`OnCreateView`中，我们将初始化`RecyclerView`：

```java
public class ListFragment extends android.support.v4.app.Fragment {

  public List<JobOffer> mListItems;
  public RecyclerView mRecyclerView;

  public ListFragment() {
    // Required empty public constructor
  }

  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container,
  Bundle savedInstanceState) {
    // Inflate the layout for this fragment
    View view = inflater.inflate(R.layout.fragment_list, container, false);

    mRecyclerView = (RecyclerView) view.findViewById(R.id.my_recycler_view);

    // use this setting to improve performance if you know that changes
    // in content do not change the layout size of the RecyclerView
    mRecyclerView.setHasFixedSize(true);

    // use a linear layout manager
    mRecyclerView.setLayoutManager(new LinearLayoutManager(getActivity()));

    //Retrieve the list of offers
    retrieveJobOffers();

    return view;
  }
```

最后，我们将调用`retrieveOffers()`方法，这是一个`async`操作。只有当从 Parse 获取结果后，我们才能创建适配器并将其设置到列表中：

```java
public void retrieveJobOffers(){

  ParseQuery<JobOffer> query = ParseQuery.getQuery("JobOffer");
  query.findInBackground(new FindCallback<JobOffer>() {

    @Override
    public void done(List<JobOffer> jobOffersList, ParseException e) {
      mListItems = jobOffersList;
      JobOffersAdapter adapter = new JobOffersAdapter(mListItems);
      mRecyclerView.setAdapter(adapter);
    }

  });
}
```

检验我们所做工作是否有效的最佳方式是查看控制台是否有错误。如果一切运行正常，你应该能够看到工作机会的列表，如下面的截图所示：

![实现 RecyclerView](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_05_13.jpg)

我们有意添加了一个重复的工作机会，以便删除它，以便看到`RecyclerView`默认包含的删除动画。我们将在**长按监听器**中实现这个功能。点击监听器仅用于在详情视图中打开工作机会。我们将在下一节中看到如何实现这一点。

## 点击`RecyclerView`的条目

在`ListView`中，检测项目点击相当简单；我们可以简单地执行`ListView.setOnItemClickLister`和`setOnItemLongClickListener`用于长按。然而，在`RecyclerView`中这种实现并不是那么快，灵活性的代价是存在的。

这里有两种实现项目点击的方法：一种是通过创建一个实现`RecyclerView.OnItemTouchListener`的类，并调用`RecyclerView`的方法`addOnItemTouchListener`，如下所示：

```java
mrecyclerView.addOnItemTouchListener(new MyRecyclerItemClickListener(getActivity(), recyclerView, new MyRecyclerItemClickListener.OnItemClickListener() {

  @Override
  public void onItemClick(View view, int position){
    // ...
  }

  @Override
  public void onItemLongClick(View view, int position){
    // ...
  }
}));

public class MyRecyclerItemClickListener implements RecyclerView.OnItemTouchListener
{
  public static interface OnItemClickListener
  {
    public void onItemClick(View view, int position);
    public void onItemLongClick(View view, int position);
  }

  private OnItemClickListener mListener;
  private GestureDetector mGestureDetector;

  public MyRecyclerItemClickListener(Context context, final RecyclerView recyclerView, OnItemClickListener listener)
  {
    mListener = listener;

    mGestureDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener()
    {
      @Override
      public boolean onSingleTapUp(MotionEvent e)
      {
        return true;
      }

      @Override
      public void onLongPress(MotionEvent e)
      {
        View child = recyclerView.findChildViewUnder(e.getX(), e.getY());

        if(child != null && mListener != null)
        {
          mListener.onItemLongClick(child, recyclerView.getChildPosition(child));
        }
      }
    });
  }

  @Override
  public boolean onInterceptTouchEvent(RecyclerView view, MotionEvent e)
  {
    View child = view.findChildViewUnder(e.getX(), e.getY());

    if(child != null && mListener != null && mGestureDetector.onTouchEvent(e))
    {
      mListener.onItemClick(child, view.getChildPosition(child));
    }

    return false;
  }

  @Override
  public void onTouchEvent(RecyclerView view, MotionEvent motionEvent){
    //Empty
  }
}
@Override
public void onRequestDisallowInterceptTouchEvent(RecyclerView view){
  //Empty
}
```

这种方法的好处在于，我们可以在每个活动或片段中定义`onClick`内部的操作。点击逻辑不在视图上，一旦我们构建了这个组件，我们就可以在不同的应用程序中重复使用它。

第二种方法是在`ViewHolder`内部设置和管理点击事件。如果我们想在应用程序的另一部分或在另一个应用程序中重用这个`ViewHolder`，这里将会有一个问题，因为点击的逻辑在视图内部，而我们在不同的片段或活动中可能需要有不同的逻辑。然而，这种方法可以更容易地检测同一行内不同组件的点击。例如，如果我们在一行内有一个小图标用于删除，另一个用于分享优惠，这种方法更有意义。这样，我们可以在每一行的职位名称上设置点击事件，并在整行上设置长按监听器：

```java
public class MyViewHolder extends RecyclerView.ViewHolder implements View.OnClickListener, View.OnLongClickListener{

  public TextView textViewName;
  public TextView textViewDescription;

  public  MyViewHolder(View v){
    super(v);
    textViewName = (TextView)v.findViewById(R.id.rowJobOfferTitle);
    textViewDescription = (TextView)v.findViewById(R.id.rowJobOfferDesc);
    textViewName.setOnClickListener(this);
    v.setOnLongClickListener(this);
  }

  @Override
  public void onClick(View view) {
    switch (view.getId()){
      case R.id.rowJobOfferTitle :
      //Click
      break;
    }
  }

  @Override
  public boolean onLongClick(View view) {
    //Delete the element here
    return false;
  }
}
```

你应该能够判断在每种情况下应该使用哪种实现，并为其辩护。为了能够测试这一点，我们将在长按后删除一个元素（这里应该有一个确认对话框以避免误删元素，但我们将省略这部分）。元素将在本地被删除以显示移除动画。注意，我们并没有从 Parse 中的源数据中删除这个元素；我们需要做的是从列表中删除元素并调用`notifyItemRemoved`来触发通知。我们将使用`getPosition()`方法来知道哪个条目被点击了。

```java
@Override
public boolean onLongClick(View view) {
  mOfferList.remove(getPosition());
  notifyItemRemoved(getPosition());
  return true;
}
```

# 总结

在本章的最后，你将了解到如何实现一个适配器，如何在列表中处理不同类型的条目，以及我们如何以及为什么应用`ViewHolder`模式。你最早是在学习`ListView`类时了解到这些，并手动实现了视图回收技术。因此，你将能够完全理解`RecyclerView`的功能以及它是如何工作的，以及展示不同条目显示方式和实现条目点击监听器的方法。

在下一章，我们将探索在 Android 5.0 中与`RecyclerView`一起引入的一个新组件—`CardView`。我们将将其与`RecyclerView`结合使用，以获得灵活且专业外观的卡片列表。
