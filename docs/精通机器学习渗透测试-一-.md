# 精通机器学习渗透测试（一）

> 原文：[`annas-archive.org/md5/74E92091FA78BD2C9635BCA05C8FE700`](https://annas-archive.org/md5/74E92091FA78BD2C9635BCA05C8FE700)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 前言

目前，机器学习技术是信息技术中最热门的趋势之一。它们影响着我们生活的方方面面，影响着每个行业和领域。机器学习是信息安全专业人员的网络武器。在本书中，你不仅将探索机器学习技术的基础知识，还将学习构建一个完全功能的机器学习安全系统的秘诀；我们不仅仅停留在构建防御层面。我们还将探讨如何使用对抗学习攻击机器学习模型。《精通机器学习渗透测试》将提供教育和实践价值。

# 本书适合谁

《精通机器学习渗透测试》适用于对打破智能安全系统技术感兴趣的渗透测试人员和安全专业人员。需要有 Python 的基础知识，但不需要有机器学习的先验知识。

# 本书涵盖的内容

第一章《渗透测试中的机器学习简介》向读者介绍了不同机器学习模型和算法的基本概念，以及如何评估它们。然后，它向我们展示了如何使用许多数据科学 Python 库准备机器学习开发环境。

第二章《钓鱼域名检测》指导我们如何使用不同的算法和自然语言处理（NLP）构建机器学习模型来检测钓鱼邮件和垃圾邮件。

第三章《使用 API 调用和 PE 头部检测恶意软件》解释了分析恶意软件和恶意软件的不同方法，并介绍了一些构建基于机器学习的恶意软件检测器的不同技术。

第四章《使用深度学习进行恶意软件检测》扩展了前一章的内容，探讨了如何构建人工神经网络和深度学习来检测恶意软件。

第五章《使用机器学习检测僵尸网络》演示了如何使用先前讨论的技术和公开可用的僵尸网络流量数据集构建僵尸网络检测器。

第六章《异常检测系统中的机器学习》向我们介绍了异常检测中最重要的术语，并指导我们构建机器学习异常检测系统。

第七章《检测高级持续威胁》向我们展示了如何使用已经加载了机器学习功能的 ELK 堆栈构建一个完全工作的真实威胁追踪平台。

第八章《使用对抗机器学习规避入侵检测系统》演示了如何使用对抗学习规避机器学习系统，并研究了一些真实案例，包括规避下一代入侵检测系统。

第九章《绕过机器学习恶意软件检测器》教会我们如何使用对抗学习和生成对抗网络绕过基于机器学习的恶意软件检测器。

第十章《机器学习和特征工程的最佳实践》探讨了不同的特征工程技术，同时向读者介绍了构建可靠系统的机器学习最佳实践。

# 如何充分利用本书

我们假设本书的读者熟悉基本的信息安全概念和 Python 编程。本书中的一些演示需要更多的练习和在线研究来深入讨论的概念。

如果您遇到任何错误、错别字或错误，请始终检查本书的 GitHub 存储库以查找更新的代码。

# 下载示例代码文件

您可以从[www.packtpub.com](http://www.packtpub.com)的帐户中下载本书的示例代码文件。如果您在其他地方购买了本书，您可以访问[www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便文件直接发送到您的邮箱。

您可以按照以下步骤下载代码文件：

1.  在[www.packtpub.com](http://www.packtpub.com/support)登录或注册。

1.  选择“支持”选项卡。

1.  单击“代码下载和勘误”。

1.  在搜索框中输入书名，然后按照屏幕上的说明操作。

下载文件后，请确保使用以下最新版本解压或提取文件夹：

+   WinRAR/7-Zip for Windows

+   Zipeg/iZip/UnRarX for Mac

+   7-Zip/PeaZip for Linux

本书的代码捆绑包也托管在 GitHub 上，网址为[`github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing`](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing)。如果代码有更新，将在现有的 GitHub 存储库上进行更新。

我们还有来自我们丰富书籍和视频目录的其他代码捆绑包，可在**[`github.com/PacktPublishing/`](https://github.com/PacktPublishing/)**上找到。去看看吧！

# 下载彩色图片

我们还提供了一个 PDF 文件，其中包含本书中使用的屏幕截图/图表的彩色图片。您可以从[`www.packtpub.com/sites/default/files/downloads/MasteringMachineLearningforPenetrationTesting_ColorImages.pdf`](https://www.packtpub.com/sites/default/files/downloads/MasteringMachineLearningforPenetrationTesting_ColorImages.pdf)下载。

# 使用的约定

本书中使用了许多文本约定。

`CodeInText`：指示文本中的代码字词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 句柄。这是一个例子：“首先，使用`python --version`命令检查您的 Python 版本。”

代码块设置如下：

```py
from keras import [what_to_use]
from keras.models import Sequential
from keras.layers import Dense
```

当我们希望引起您对代码块的特定部分的注意时，相关行或项目将以粗体显示：

```py
model = Sequential()
# N = number of neurons
# V = number of variable
model.add(Dense(N, input_dim=V, activation='relu'))
# S = number of neurons in the 2nd layer
model.add(Dense(S, activation='relu'))
model.add(Dense(1, activation='sigmoid')) # 1 output
```

任何命令行输入或输出都以以下方式编写：

```py
>>> import tensorflow as tf
>>> Message = tf.constant("Hello, world!")
>>> sess = tf.Session()
>>> print(sess.run(Message))
```

**粗体**：表示新术语、重要单词或屏幕上看到的单词。

警告或重要说明会显示为这样。

提示和技巧会显示为这样。


# 第一章：渗透测试中的机器学习简介

目前，机器学习技术是信息技术中最热门的趋势之一。它们影响着我们生活的方方面面，影响着每个行业和领域。机器学习是信息安全专业人员的网络武器。在本书中，读者不仅将探索机器学习技术背后的基本原理，还将学习构建完全功能的机器学习安全系统的秘诀。我们不仅会停留在构建防御层，还将说明如何构建攻击和绕过安全防御的攻击工具。通过本书，您将能够绕过机器学习安全系统，并在渗透测试任务中使用构建的模型。

在本章中，我们将涵盖：

+   机器学习模型和算法

+   性能评估指标

+   降维

+   集成学习

+   机器学习开发环境和 Python 库

+   渗透测试中的机器学习-承诺和挑战

# 技术要求

在这一章中，我们将建立一个开发环境。因此，我们将安装以下 Python 机器学习库：

+   NumPy

+   SciPy

+   TensorFlow

+   Keras

+   pandas

+   MatplotLib

+   scikit-learn

+   NLTK

+   Theano

您还可以在此 GitHub 存储库中找到本书中使用的所有脚本和安装指南：[`github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter01`](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter01)。

# 人工智能和机器学习

让机器像人一样思考是最古老的梦想之一。机器学习技术用于基于经验和数据进行预测。

# 机器学习模型和算法

为了教会机器如何自己解决大量问题，我们需要考虑不同的机器学习模型。正如您所知，我们需要向模型提供数据；这就是为什么机器学习模型根据输入的数据集被分为四个主要类别：监督学习、半监督学习、无监督学习和强化学习。在本节中，我们将详细描述每个模型，以及探索每个机器学习模型中使用的最知名的算法。在构建机器学习系统之前，我们需要了解表面下的工作原理。

# 监督

当我们既有输入变量又有输出变量时，我们谈论监督机器学习。在这种情况下，我们需要映射两方之间的函数（或模式）。以下是一些最常用的监督机器学习算法。

# 贝叶斯分类器

根据*剑桥英语词典*的定义，偏见是以不公平的方式支持或反对特定的人或事物，允许个人意见影响您的判断。贝叶斯机器学习是指先前的信念，并通过使用数据进行更新。在数学上，它基于贝叶斯公式：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00005.jpeg)

最简单的贝叶斯问题之一是随机抛硬币并尝试预测输出是正面还是反面。这就是为什么我们可以将贝叶斯方法论识别为概率的原因。当您使用少量数据时，朴素贝叶斯非常有用。

# 支持向量机

**支持向量机**（**SVM**）是一种监督机器学习模型，通过在表示的数据之间识别一个超平面来工作。数据可以在多维空间中表示。因此，SVM 广泛用于分类模型。在 SVM 中，将使用最佳分离不同类别的超平面。在某些情况下，当我们有不同的超平面分离不同的类别时，将通过称为**间隔**或**间隙**的东西执行正确的超平面的识别。间隔是超平面和数据位置之间的最近距离。您可以查看以下表示以检查间隔：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00006.jpeg)

将选择具有最大间隙的超平面。如果选择具有最短间隔的超平面，我们可能会在以后面临错误分类问题。不要被前面的图形分散注意力；超平面并不总是线性的。考虑以下情况：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00007.gif)

在前面的情况下，我们可以添加一个新的轴，称为*z*轴，并使用一个称为核函数的核技巧应用变换，其中`z=x²+y²`。如果应用变换，新图将如下所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00008.gif)

现在，我们可以确定正确的超平面。这个转换被称为**核**。在现实世界中，找到一个超平面是非常困难的。因此，称为正则化和伽玛的两个重要参数在确定正确的超平面以及在每个 SVM 分类器中获得非线性超平面情况下的更好准确性方面起着巨大作用。

# 决策树

决策树是监督学习算法，通过将数据表示为树，根在顶部，用于决策制定。以下是决策树的图形表示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00009.jpeg)

数据是通过迭代二分 3 算法表示的。用于分类和回归问题的决策树称为 CARTs。它们由 Leo Breiman 引入。

# 半监督

半监督学习是在前面讨论的两个模型之间的一个领域。换句话说，如果您使用少量标记数据以及未标记数据的情况，那么您正在执行半监督学习。半监督学习广泛应用于现实世界的应用，如语音分析，蛋白质序列分类和网页内容分类。有许多半监督方法，包括生成模型，低密度分离和基于图的方法（离散马尔可夫随机场，流形正则化和最小割）。

# 无监督

在无监督学习中，我们对模型的输出没有明确的信息。以下是一些众所周知的无监督机器学习算法。

# 人工神经网络

人工网络是人工智能中一些最热门的应用，特别是机器学习。人工神经网络的主要目标是构建可以像人类大脑一样学习的模型；换句话说，我们试图模仿人类大脑。这就是为什么为了学习如何构建神经网络系统，我们需要清楚地了解人类大脑实际上是如何工作的。人类大脑是一个令人惊奇的实体。大脑由神经元组成和连接。神经元负责传输和处理信息。

我们都知道人类大脑可以执行很多任务，如听觉、视觉、味觉和许多其他复杂的任务。因此，从逻辑上讲，人们可能会认为大脑由许多不同的区域组成，每个区域负责特定的任务，都归功于特定的算法。但这是完全错误的。根据研究，人类大脑的所有不同部分都是由一个算法而不是不同的算法来实现功能的。这个假设被称为**一个算法假设**。

现在我们知道大脑是通过使用一个算法工作的。但是这个算法是什么？它是如何使用的？信息是如何用它处理的？

为了回答前面的问题，我们需要看一下神经元的逻辑表示。人工神经元的人工表示称为**感知器**。感知器由以下图表示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00010.jpeg)

有许多使用的**激活函数**。你可以把它们看作是逻辑门：

+   **阶跃函数**：预定义的阈值。

+   **Sigmoid 函数**：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00011.gif)

+   **Tanh 函数**：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00012.gif)

+   **ReLu 函数**：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00013.jpeg)

许多全连接的感知器组成了我们所谓的**多层感知器**（**MLP**）网络。典型的神经网络包括以下内容：

+   一个输入层

+   隐藏层

+   输出层

一旦我们有了三个以上的隐藏层，我们将讨论术语**深度学习**。世界上使用许多类型的深度学习网络：

+   **卷积神经网络**（**CNNs**）

+   **递归神经网络**（**RNNs**）

+   **长短期记忆**（**LSTM**）

+   浅层神经网络

+   **自动编码器**（**AEs**）

+   受限玻尔兹曼机

不要担心；我们将在未来的章节中详细讨论前述算法。

为了构建深度学习模型，我们遵循由 Dr. Jason Brownlee 建议的五个步骤。这五个步骤如下：

1.  网络定义

1.  网络编译

1.  网络拟合

1.  网络评估

1.  预测

# 线性回归

线性回归是一种统计和机器学习技术。它被广泛用于理解输入和输出之间的关系。当我们有数值数值时，我们使用线性回归。

# 逻辑回归

逻辑回归也是一种统计和机器学习技术，用作二元分类器 - 换句话说，当输出是类别（是/否，真/假，0/1 等）时。

# 使用 k 均值进行聚类

**k-最近邻**（**kNN**）是一种著名的聚类方法。它基于在数据点中找到相似性，或者我们称之为特征相似性。因此，这个算法很简单，并且被广泛用于解决许多分类问题，比如推荐系统、异常检测、信用评级等。然而，它需要大量的内存。虽然它是一个监督学习模型，但它应该由标记数据提供，并且输出是已知的。我们只需要映射关联两方的函数。kNN 算法是非参数的。数据被表示为特征向量。你可以把它看作是一个数学表示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00014.jpeg)

分类就像投票一样；要知道所选数据的类别，必须首先计算所选项与其他训练项之间的距离。但是我们如何计算这些距离呢？

通常，我们有两种主要的计算方法。我们可以使用欧几里得距离：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00015.gif)

或者，我们可以使用余弦相似度：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00016.gif)

第二步是选择*k*个最近的距离（*k*可以任意选择）。最后，我们根据置信水平进行投票。换句话说，数据将被分配给具有最大概率的类别。

# 强化

在强化机器学习模型中，代理与其环境互动，因此它通过在过程中收集数据来从经验中学习；目标是优化我们所谓的长期**奖励**。你可以把它看作是一个带有评分系统的游戏。以下图表说明了一个强化模型：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00017.jpeg)

# 性能评估

评估是每个方法操作中的关键步骤。在构建产品或系统，尤其是机器学习模型之后，我们需要清晰地了解其性能，以确保它将来能够按预期运行。为了评估机器学习的性能，我们需要使用明确定义的参数和见解。为了计算不同的评估指标，我们需要使用四个重要的参数：

+   真阳性

+   假阳性

+   真阴性

+   假阴性

前述参数的符号如下：

+   *tp*：真阳性

+   *fp*：假阳性

+   *tn*：真阴性

+   *fn*：假阴性

有许多机器学习评估指标，例如以下内容：

+   **精度**：精度，或者叫做阳性预测值，是指被正确分类的阳性样本数量与总体被分类为阳性的样本数量的比值：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00018.gif)

+   **召回率**：召回率，或者真阳性率，是指真阳性分类的比率除以数据集中的阳性样本总数：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00019.gif)

+   **F-分数**：F-分数，或者 F-度量，是将精度和召回率结合在一个谐波公式中的度量。

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00020.gif)

+   **准确度**：准确度是指总体被正确分类的样本数量与总体样本数量的比值。这个度量本身是不够的，因为它在我们有相等数量的类时使用。

+   **混淆矩阵**：混淆矩阵是对给定机器学习模型性能的图形化表示。它总结了分类问题中每个类的性能。

# 降维

降维用于减少数据集的维度。在变量数量增加时，这对于处理问题变得困难时非常有帮助。通过使用“维度”，我们指的是特征。基本的降维技术之一是特征工程。

通常，我们有许多降维算法：

+   **低方差过滤器**：删除与其他变量相比方差较低的变量。

+   **高相关性过滤器**：通过使用 Pearson 或 Polychoric 识别具有高相关性的变量，并使用**方差膨胀因子**（**VIF**）选择其中之一。

+   **向后特征消除**：通过在消除每个变量*n*次后计算**平方误差和**（**SSE**）来实现。

+   **线性判别分析**（**LDA**）：这将维度的数量*n*从原始数量减少到类别数量-1 的特征数量。

+   **主成分分析**（**PCA**）：这是一种将变量转换为新变量（主成分）的统计过程。

# 通过集成学习改善分类

在许多情况下，当构建机器学习模型时，我们会得到低准确度和低结果。为了获得良好的结果，我们可以使用集成学习技术。这可以通过将许多机器学习技术组合成一个预测模型来实现。

我们可以将集成学习技术分为两类：

+   **并行集成方法**—以下图表说明了并行集成学习的工作原理：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00021.jpeg)

+   **顺序集成方法**—以下图表说明了顺序集成学习的工作原理：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00022.jpeg)

以下是三种最常用的集成学习技术：

+   **自助聚合**（**bagging**）：这涉及构建单独的模型，并通过使用模型平均技术（如加权平均和多数投票）将它们组合起来。

+   **提升**：这是一种顺序集成学习技术。梯度提升是最常用的提升技术之一。

+   **堆叠**：这类似于提升，但它使用新模型来组合子模型。

# 机器学习开发环境和 Python 库

到目前为止，我们已经了解了最常用的机器学习算法背后的基本知识。从这一部分开始，我们将更深入地学习，通过实践构建基于机器学习的安全项目。我们不会止步于此；在接下来的章节中，我们将学习恶意攻击者如何绕过智能安全系统。现在，让我们把到目前为止学到的东西付诸实践。如果您正在阅读本书，您可能对 Python 有一些经验。这对您很有好处，因为您有一个学习如何构建机器学习安全系统的基础。

我敢打赌您正在想，为什么选择 Python？这是一个很好的问题。根据最新研究，Python 是数据科学中最常用的编程语言之一，尤其是机器学习。最知名的机器学习库是为 Python 编写的。让我们发现构建机器学习模型所需的 Python 库和实用程序。

# NumPy

数值 Python 库是数学和数组逻辑操作中最常用的库之一。它加载了许多线性代数功能，在机器学习中非常有用。当然，它是开源的，并受到许多操作系统的支持。

要安装 NumPy，请使用`pip`实用程序，输入以下命令：

```py
#pip install numpy
```

现在，您可以通过导入它来开始使用它。以下脚本是一个简单的数组打印示例：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00023.jpeg)

此外，您可以使用许多数学函数，如`cosine`，`sine`等。

# SciPy

科学 Python（SciPy）就像 NumPy 一样，是一个令人惊叹的 Python 包，加载了大量科学函数和实用程序。有关更多详细信息，您可以访问[`www.scipy.org/getting-started.html`](https://www.scipy.org/getting-started.html)：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00024.jpeg)

# TensorFlow

如果您已经从事机器学习一段时间，您将听说过 TensorFlow，甚至使用它构建了机器学习模型或为人工神经网络提供数据。这是一个令人惊叹的开源项目，基本上由 Google 开发和支持：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00025.jpeg)

以下是 TensorFlow 的主要架构，根据官方网站：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00026.jpeg)

如果这是您第一次使用 TensorFlow，强烈建议访问项目的官方网站[`www.tensorflow.org/get_started/`](https://www.tensorflow.org/get_started/)。让我们在我们的机器上安装它，并发现一些其功能。有许多安装它的可能性；您可以使用本机 PIP、Docker、Anaconda 或 Virtualenv。

假设我们要在 Ubuntu 机器上安装它（它也支持其他操作系统）。首先，使用`python --version`命令检查您的 Python 版本：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00027.jpeg)

使用以下命令安装 PIP 和 Virtualenv：

```py
sudo apt-get install python-pip python-dev python-virtualenv
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00028.gif)

现在，包已安装：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00029.gif)

使用`mkdir`命令创建一个新的存储库：

```py
#mkdir TF-project
```

通过输入以下命令创建一个新的 Virtualenv：

```py
 virtualenv --system-site-packages TF-project
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00030.gif)

然后，键入以下命令：

```py
source  <Directory_Here>/bin/activate
```

通过使用`pip install -upgrade tensorflow`命令升级 TensorFlow：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00031.gif)

```py
>>> import tensorflow as tf
>>> Message = tf.constant("Hello, world!")
>>> sess = tf.Session()
>>> print(sess.run(Message))
```

以下是显示`Hello World!`消息的完整步骤：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00032.gif)

# Keras

Keras 是一个广泛使用的 Python 库，用于构建深度学习模型。这很容易，因为它是建立在 TensorFlow 之上的。构建深度学习模型的最佳方法是遵循先前讨论的步骤：

1.  加载数据

1.  定义模型

1.  编译模型

1.  拟合

1.  评估

1.  预测

在构建模型之前，请确保已预配置 SciPy 和 NumPy。要检查，请打开 Python 命令行界面并键入，例如，以下命令以检查 NumPy 版本：

```py
 >>>print numpy.__version__
```

要安装 Keras，只需使用 PIP 实用程序：

```py
$ pip install keras
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00033.gif)

当然，要检查版本，请键入以下命令：

```py
>>> print keras.__version__
```

要从 Keras 导入，请使用以下命令：

```py
from keras import [what_to_use]
from keras.models import Sequential
from keras.layers import Dense
```

现在，我们需要加载数据：

```py
dataset = numpy.loadtxt("DATASET_HERE", delimiter=",")
I = dataset[:,0:8]
O = dataset[:,8]  
#the data is splitted into Inputs (I) and Outputs (O)
```

您可以使用任何公开可用的数据集。接下来，我们需要创建模型：

```py
model = Sequential()
# N = number of neurons
# V = number of variable
model.add(Dense(N, input_dim=V, activation='relu'))
# S = number of neurons in the 2nd layer
model.add(Dense(S, activation='relu'))
model.add(Dense(1, activation='sigmoid')) # 1 output
```

现在，我们需要编译模型：

```py
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])
```

我们需要拟合模型：

```py
model.fit(I, O, epochs=E, batch_size=B)
```

如前所述，评估是机器学习中的关键步骤；因此，为了评估我们的模型，我们使用：

```py
scores = model.evaluate(I, O)
print("\n%s: %.2f%%" % (model.metrics_names[1], scores[1]*100))
```

要进行预测，请添加以下一行：

```py
predictions = model.predict(Some_Input_Here)
```

# pandas

pandas 是一个开源的 Python 库，以其高性能而闻名；它是由 Wes McKinney 开发的。它可以快速操作数据。这就是为什么它在学术界和商业活动的许多领域被广泛使用。与之前的包一样，它受到许多操作系统的支持。

要在 Ubuntu 机器上安装它，请输入以下命令：

```py
sudo apt-get install python-pandas
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00034.gif)

基本上，它操作三种主要数据结构-数据框、系列和面板：

```py
>> import pandas as pd
>>>import numpy as np
 data = np.array(['p','a','c','k',’t’])
 SR = pd.Series(data)
 print SR
```

我在这个截图中总结了所有之前的行：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00035.gif)

# Matplotlib

如您所知，可视化在从数据中获得洞察力方面起着重要作用，也在机器学习中非常重要。Matplotlib 是数据科学家用于绘图的可视化库。您可以通过访问其官方网站[`matplotlib.org`](https://matplotlib.org)来更清楚地了解：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00036.jpeg)

要在 Ubuntu 机器上安装它，请使用以下命令：

```py
sudo apt-get install python3-matplotlib
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00037.gif)

要导入所需的包，请使用`import`：

```py
import matplotlib.pyplot as plt
import numpy as np
```

使用此示例准备数据：

```py
x = np.linspace(0, 20, 50)
```

要绘制它，请添加这一行：

```py
plt.plot(x, x, label='linear')
```

要添加图例，请使用以下命令：

```py
plt.legend()
```

现在，让我们显示图表：

```py
plt.show()
```

看吧！这是我们的图表：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00038.jpeg)

# scikit-learn

我强烈推荐这个令人惊叹的 Python 库。scikit-learn 功能齐全，具有各种功能，包括机器学习功能。scikit-learn 的官方网站是[`scikit-learn.org/`](http://scikit-learn.org/)。要下载它，请使用之前讨论过的 PIP：

```py
pip install -U scikit-learn 
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00039.gif)

# NLTK

自然语言处理是机器学习项目中最常用的应用之一。NLTK 是一个 Python 包，可以帮助开发人员和数据科学家管理和操作大量文本。可以使用以下命令安装 NLTK：

```py
pip install -U nltk
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00040.gif)

现在，导入`nltk`：

```py
>>> import nltk
```

使用以下命令安装`nltk`包：

```py
> nltk.download()
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00041.jpeg)

您可以安装所有的包：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00042.jpeg)

如果您正在使用命令行环境，您只需要按照以下步骤进行：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00043.gif)

如果您键入`all`，您将下载所有的包：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00044.gif)

# Theano

优化和速度是构建机器学习模型的两个关键因素。Theano 是一个 Python 包，优化实现并使您能够利用 GPU。要安装它，请使用以下命令：

```py
 pip install theano
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00045.gif)

要导入所有 Theano 模块，请键入：

```py
>>> from theano import *
```

在这里，我们导入了一个名为`tensor`的子包：

```py
>>> import theano.tensor as T
```

假设我们想要添加两个数字：

```py
>>> from theano import function
>>> a = T.dscalar('a')
>>> b = T.dscalar('b')
>>> c = a + b
>>> f = function([a, b], c)
```

以下是完整的步骤：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00046.gif)

到目前为止，我们已经掌握了安装和使用机器学习项目中最常用的 Python 库的基本技能。我假设您已经在您的机器上安装了所有之前的包。在接下来的章节中，我们将使用这些包中的大部分来构建完全可用的信息安全机器学习项目。

# 渗透测试中的机器学习-承诺和挑战

机器学习现在是每个现代项目中必不可少的一个方面。结合数学和尖端优化技术和工具可以提供惊人的结果。将机器学习和分析应用于信息安全是在防御先进的现实世界攻击和威胁方面迈出的一步。

黑客总是试图使用新的复杂技术来攻击现代组织。因此，作为安全专业人员，我们需要保持更新并部署所需的防护措施来保护资产。许多研究人员已经提出了成千上万的建立基于机器学习技术的防御系统的建议。例如，以下是一些信息安全模型：

+   **监督学习**：

+   网络流量分析

+   垃圾邮件过滤

+   恶意软件检测

+   **半监督学习**：

+   网络异常检测

+   C2 检测

+   **无监督学习**：

+   用户行为分析

+   内部威胁检测

+   恶意软件家族识别

正如你所看到的，有很多应用程序可以帮助保护现代组织的宝贵资产。但一般来说，黑帽骇客不再使用传统技术。如今，机器学习技术的使用正在从防御性技术转向进攻性系统。我们正在从防御性转向进攻性。事实上，仅仅使用人工智能和机器学习构建防御层是不够的；需要了解如何利用这些技术进行凶猛的攻击，并在进行渗透测试任务时将其添加到您的技术技能中。在模拟尖端攻击时，将进攻性机器学习工具添加到您的渗透测试工具库中非常有用。虽然很多这些进攻性应用程序仍然是为研究目的而存在，但我们将尝试构建我们自己的项目，以了解攻击者是如何构建进攻性工具和网络武器来攻击现代公司的。也许您以后可以在渗透测试操作中使用它们。

# 深度利用

最近出现了许多出色的公开可用工具，利用机器学习能力将渗透测试提升到另一个水平。其中一个工具就是 Deep Exploit。它在 2018 年黑帽大会上展示。它是一个与 metasploit 相关联的全自动渗透测试工具。这个出色的工具使用了强化学习（自学习）。

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00047.jpeg)

它能够执行以下任务：

+   情报收集

+   威胁建模

+   漏洞分析

+   利用

+   后利用

+   报告

要下载 Deep Exploit，请访问其官方 GitHub 存储库：[`github.com/13o-bbr-bbq/machine_learning_security/tree/master/DeepExploit`](https://github.com/13o-bbr-bbq/machine_learning_security/tree/master/DeepExploit)。

它由一个机器学习模型（A3C）和 metasploit 组成。这是 Deep Exploit 架构的高级概述：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00048.jpeg)

使 Deep Exploit 正常工作所需的环境如下：

+   Kali Linux 2017.3（VMWare 上的客户操作系统）

+   内存：8.0GB

+   Metasploit 框架 4.16.15-dev

+   Windows 10 Home 64 位（主机操作系统）

+   CPU：Intel(R) Core(TM) i7-6500U 2.50GHz

+   内存：16.0GB

+   Python 3.6.1（Anaconda3）

+   TensorFlow 1.4.0

+   Keras 2.1.2

# 总结

现在我们已经学习了最常用的机器学习技术；在深入实验室之前，我们需要对这些模型的实际工作原理有一个公平的理解。我们的实际经验将从下一章开始。

阅读完本章后，我认为我们可以构建我们自己的开发环境。第二章将向我们展示如何抵御先进的基于计算机的社会工程攻击，我们将学习如何构建一个智能的钓鱼检测器。就像每一章一样，我们将从攻击背后的技术开始学习，并逐步学习构建一个钓鱼检测系统的实际步骤。

# 问题

1.  尽管机器学习是一个有趣的概念，但在有用的有限商业应用中使用它。 （是 | 否）

1.  机器学习应用程序太复杂，无法在云中运行。（是 | 否）

1.  对于两次 k 均值聚类运行，预期会得到相同的聚类结果吗？（是 | 否）

1.  具有离散值目标属性的预测模型可以称为：

(a) 回归模型

(b) 分类模型

1.  以下哪些技术执行类似于神经网络中的辍学操作？

(a) 堆叠

(b) 裹袋

(c) 提升

1.  哪种神经网络架构最适合解决图像识别问题？

(a) 卷积神经网络

(b) 循环神经网络

(c) 多层感知器

(d) 感知器

1.  深度学习与传统机器学习有何不同？

(a) 深度学习算法可以处理更多数据，并且需要更少的数据科学家监督。

(b) 机器学习更简单，需要更少的数据分析师监督，而深度学习则不然。

(c) 两者之间没有真正的区别；它们是相同的工具，只是名称不同。

1.  以下哪项是机器学习项目中经常使用的技术？

(a) 将数据分类。

(b) 将相似的对象分组成簇。

(c) 识别事件之间的关系，以预测一个事件将在另一个事件之后发生。

(d) 以上全部。

# 进一步阅读

为了节省您的一些努力，我已经准备了一份有用的资源列表，以帮助您更深入地探索我们讨论过的技术。

推荐书籍：

+   *Python 机器学习-第二版* by Sebastian Raschka and Vahid Mirjalili：[`www.packtpub.com/big-data-and-business-intelligence/python-machine-learning-second-edition`](https://www.packtpub.com/big-data-and-business-intelligence/python-machine-learning-second-edition)

+   *使用 Python 构建机器学习系统* by Luis Pedro Coelho and Willi Richert：[`www.amazon.com/Building-Machine-Learning-Systems-Python/dp/1782161406`](https://www.amazon.com/Building-Machine-Learning-Systems-Python/dp/1782161406)

+   *从头开始的数据科学：Python 基本原理* by Joel Grus：[`www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X/ref=pd_sim_14_4?_encoding=UTF8&pd_rd_i=149190142X&pd_rd_r=506TTMZ93CK4Q4KZWDRM&pd_rd_w=5Eqf8&pd_rd_wg=1HMzv&psc=1&refRID=506TTMZ93CK4Q4KZWDRM`](https://www.amazon.com/Data-Science-Scratch-Principles-Python/dp/149190142X/ref=pd_sim_14_4?_encoding=UTF8&pd_rd_i=149190142X&pd_rd_r=506TTMZ93CK4Q4KZWDRM&pd_rd_w=5Eqf8&pd_rd_wg=1HMzv&psc=1&refRID=506TTMZ93CK4Q4KZWDRM)

推荐网站和在线课程：

+   机器学习掌握：[`machinelearningmastery.com`](https://machinelearningmastery.com)

+   Coursera - 机器学习（Andrew Ng）：[`www.coursera.org/learn/machine-learning#syllabus`](https://www.coursera.org/learn/machine-learning#syllabus)

+   **神经网络用于机器学习**：[`www.coursera.org/learn/neural-networks`](https://www.coursera.org/learn/neural-networks)


# 第二章：钓鱼域名检测

社会工程是每个个人和现代组织面临的最危险的威胁之一。钓鱼是一种众所周知的基于计算机的社会工程技术。攻击者使用伪装的电子邮件地址作为武器来瞄准大公司。由于每天收到大量的钓鱼邮件，公司无法检测到所有这些邮件。这就是为什么需要新的技术和防护措施来防御钓鱼。本章将介绍构建三个不同基于机器学习的项目以检测钓鱼尝试所需的步骤，使用尖端的 Python 机器学习库。

在本章中，我们将涵盖：

+   社会工程概述

+   社会工程渗透测试的步骤

+   使用不同的机器学习模型构建实时钓鱼攻击检测器：

+   使用逻辑回归进行钓鱼检测

+   使用决策树进行钓鱼检测

+   使用**自然语言处理**（**NLP**）进行垃圾邮件检测。

# 技术要求

在本章中，我们将使用以下 Python 库：

+   scikit-learn Python（≥2.7 或≥3.3）

+   NumPy（≥1.8.2）

+   NLTK

如果您尚未安装它们，请确保在继续本章之前安装它们。您可以在[`github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter02`](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter02)找到代码文件。

# 社会工程概述

社会工程，根据定义，是对一个人的心理操纵，以从他们那里获取有用和敏感的信息，这些信息以后可以用来破坏系统。换句话说，罪犯利用社会工程从人们那里获取机密信息，利用人类行为。

# 社会工程参与框架

**社会工程参与框架**（**SEEF**）是由 Dominique C. Brack 和 Alexander Bahmram 开发的框架。它总结了信息安全和防御社会工程多年的经验。该框架的利益相关者是组织、政府和个人（个人）。社会工程参与管理经历三个步骤：

1.  预先参与过程：准备社会工程操作

1.  **在参与过程中**：参与发生

1.  **在参与过程后**：提交报告

罪犯使用许多社会工程技术：

+   **诱饵**：说服受害者透露信息，承诺给他奖励或礼物。

+   冒充：假装成别人。

+   垃圾箱潜水：从垃圾箱中收集有价值的信息（包括地址、电子邮件等）。

+   窥视：在别人背后窥视他们的机器，当他们在打字时。

+   钓鱼：这是最常用的技术；当攻击者假扮成受信任的实体，欺骗受害者打开电子邮件、即时消息或短信时，就会发生这种情况。

# 社会工程渗透测试步骤

渗透测试模拟黑客的攻击，以评估公司的安全姿态，以部署所需的防护措施。渗透测试是一个有方法的过程，它经过明确定义的步骤。有许多类型的渗透测试：

+   白盒渗透测试

+   黑盒渗透测试

+   灰盒渗透测试

要执行社会工程渗透测试，您需要按照以下步骤进行：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00049.jpeg)

# 使用不同的机器学习模型构建实时钓鱼攻击检测器

在接下来的章节中，我们将学习如何构建机器学习钓鱼检测器。我们将涵盖以下两种方法：

+   使用逻辑回归进行钓鱼检测

+   使用决策树进行钓鱼检测

# 使用逻辑回归进行钓鱼检测

在本节中，我们将使用逻辑回归算法从头开始构建一个钓鱼网站检测器。逻辑回归是一种用于进行二项预测（两类）的众所周知的统计技术。

就像在每个机器学习项目中一样，我们需要数据来供给我们的机器学习模型。对于我们的模型，我们将使用 UCI 机器学习库（钓鱼网站数据集）。您可以在[`archive.ics.uci.edu/ml/datasets/Phishing+Websites`](https://archive.ics.uci.edu/ml/datasets/Phishing+Websites)上查看它：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00050.jpeg)

数据集以`arff`文件的形式提供：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00051.jpeg)

以下是数据集的快照：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00052.gif)

为了更好地操作，我们已经将数据集组织成了`csv`文件：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00053.jpeg)

您可能已经注意到，从属性中，数据集的每一行都以以下格式表示 - *{30 个属性（具有 IP 地址 URL 长度，异常 URL 等）} + {1 个属性（结果）}*：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00054.jpeg)

对于我们的模型，我们将导入两个机器学习库，NumPy 和 scikit-learn，这两个库我们已经在第一章中安装了，*渗透测试中的机器学习简介*。

让我们打开 Python 环境并加载所需的库：

```py
>>> import numpy as np
>>> from sklearn import *
>>> from sklearn.linear_model import LogisticRegression
>>> from sklearn.metrics import accuracy_score
```

接下来，加载数据：

```py
training_data = np.genfromtxt('dataset.csv', delimiter=',', dtype=np.int32)
```

确定`inputs`（除最后一个属性外的所有属性）和`outputs`（最后一个属性）：

```py
>>> inputs = training_data[:,:-1]
>>> outputs = training_data[:, -1]
```

在上一章中，我们讨论了如何将数据集分成训练数据和测试数据：

```py
training_inputs = inputs[:2000]
training_outputs = outputs[:2000] 
testing_inputs = inputs[2000:]
testing_outputs = outputs[2000:]
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00055.gif)

创建 scikit-learn 逻辑回归分类器：

```py
classifier = LogisticRegression()
```

训练分类器：

```py
classifier.fit(training_inputs, training_outputs)
```

进行预测：

```py
predictions = classifier.predict(testing_inputs)
```

让我们打印出我们的钓鱼网站检测器模型的准确率：

```py
accuracy = 100.0 * accuracy_score(testing_outputs, predictions) 
print ("The accuracy of your Logistic Regression on testing data is: " + str(accuracy))
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00056.gif)

我们的模型准确率约为 85%。这是一个很好的准确率，因为我们的模型在 100 个中检测出了 85 个钓鱼网址。但让我们尝试使用相同的数据，用决策树来构建一个更好的模型。

# 使用决策树进行钓鱼检测

为了构建第二个模型，我们将使用相同的机器学习库，因此无需再次导入它们。但是，我们将从`sklearn`导入决策树分类器：

```py
>>> from sklearn import tree
```

创建`tree.DecisionTreeClassifier()` scikit-learn 分类器：

```py
classifier = tree.DecisionTreeClassifier()
```

训练模型：

```py
classifier.fit(training_inputs, training_outputs)
```

计算预测：

```py
predictions = classifier.predict(testing_inputs)
```

计算准确率：

```py
accuracy = 100.0 * accuracy_score(testing_outputs, predictions)
```

然后，打印出结果：

```py
print ("The accuracy of your decision tree on testing data is: " + str(accuracy))
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00057.gif)

第二个模型的准确率约为 90.4%，与第一个模型相比，这是一个很好的结果。我们现在已经学会了如何使用两种机器学习技术构建两个钓鱼网站检测器。

# NLP 深入概述

NLP 是机器分析和理解人类语言的艺术。根据许多研究，超过 75%的使用数据是非结构化的。非结构化数据没有预定义的数据模型，也没有按预定义的方式组织。电子邮件、推文、日常消息甚至我们记录的演讲都是非结构化数据的形式。NLP 是机器分析、理解和从自然语言中获取含义的一种方式。NLP 广泛应用于许多领域和应用程序，例如：

+   实时翻译

+   自动摘要

+   情感分析

+   语音识别

+   构建聊天机器人

通常，NLP 有两个不同的组成部分：

+   **自然语言理解（NLU）**：这指的是将输入映射为有用的表示。

+   **自然语言生成（NLG）**：这指的是将内部表示转换为有用的表示。换句话说，它是将数据转换为书面或口头叙述。商业智能仪表板的书面分析是 NLG 应用之一。

每个 NLP 项目都经历五个步骤。构建 NLP 项目的第一步是识别和分析单词的结构。这一步涉及将数据分成段落、句子和单词。然后我们分析句子中的单词以及它们之间的关系。第三步涉及检查文本的意义。然后，分析连续句子的含义。最后，我们通过实用分析完成项目。

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00058.jpeg)

# 开源 NLP 库

有许多开源的 Python 库提供了构建实际 NLP 应用所需的结构，例如：

+   Apache OpenNLP

+   GATE NLP 库

+   Stanford NLP

+   当然，**自然语言工具包**（**NLTK**）

在上一章中，我们学习了如何安装许多开源的机器学习 Python 库，包括 NLTK。让我们启动我们的 Linux 机器并尝试一些实际技术。

打开 Python 终端并导入`nltk`：

```py
>>> import nltk
```

下载书籍类型，如下所示：

```py
>>> nltk.download()
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00059.jpeg)

如果要列出我们在上一章中已经下载的可用资源，请输入`l`：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00060.gif)

您也可以输入：

```py
>> from nltk.book import *
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00061.gif)

要从链接中获取文本，建议使用`urllib`模块来爬取网站：

```py
>>> from urllib import urlopen
>>> url = "http://www.URL_HERE/file.txt"
```

作为演示，我们将加载一个名为`Security.in.Wireless.Ad.Hoc.and.Sensor.Networks`的文本：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00062.jpeg)

我们爬取了文本文件，并使用`len`检查其长度和`raw[:50]`显示一些内容。从屏幕截图中可以看到，文本包含许多对我们的项目无用的符号。为了只获取我们需要的内容，我们使用**标记化**：

```py
>>> tokens = nltk.word_tokenize(raw)
>>> len(tokens)
> tokens[:10]
```

总结一下我们在上一节学到的内容，我们看到了如何下载网页，对文本进行标记化，并对单词进行规范化。

# 使用 NLTK 进行垃圾邮件检测

现在是时候使用 NLTK 构建我们的垃圾邮件检测器了。这种分类器的原理很简单；我们需要检测垃圾邮件发送者使用的单词。我们将使用 Python 和`nltk`库构建一个垃圾邮件/非垃圾邮件二元分类器，以检测电子邮件是否为垃圾邮件。首先，我们需要像往常一样导入该库：

```py
>>> import nltk
```

我们需要加载数据并用电子邮件数据集来训练我们的模型。为了实现这一点，我们可以使用**Internet CONtent FIltering Group**提供的数据集。您可以访问该网站[`labs-repos.iit.demokritos.gr/skel/i-config/`](https://labs-repos.iit.demokritos.gr/skel/i-config/)：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00063.jpeg)

基本上，该网站提供了四个数据集：

+   Ling-spam

+   PU1

+   PU123A

+   Enron-spam

对于我们的项目，我们将使用 Enron-spam 数据集：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00064.jpeg)

让我们使用`wget`命令下载数据集：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00065.jpeg)

使用`tar -xzf enron1.tar.gz`命令提取`tar.gz`文件：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00066.jpeg)

洗牌`cp spam/* emails && cp ham/* emails`对象：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00067.jpeg)

要洗牌电子邮件，让我们编写一个小的 Python 脚本`Shuffle.py`来完成这项工作：

```py
import os
import random
#initiate a list called emails_list
emails_list = []
Directory = '/home/azureuser/spam_filter/enron1/emails/'
Dir_list  = os.listdir(Directory)
for file in Dir_list:
    f = open(Directory + file, 'r')
    emails_list.append(f.read())
f.close()
```

只需更改目录变量，它将对文件进行洗牌：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00068.jpeg)

准备数据集后，您应该知道，正如我们之前学到的那样，我们需要对电子邮件进行`标记化`：

```py
>> from nltk import word_tokenize
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00069.jpeg)

此外，我们还需要执行另一个步骤，称为词形还原。词形还原将连接具有不同形式的单词，如 hacker/hackers 和 is/are。我们需要导入`WordNetLemmatizer`：

```py
>>> from nltk import WordNetLemmatizer
```

创建一个用于演示的句子，并打印出词形还原器的结果：

```py
>>> [lemmatizer.lemmatize(word.lower()) for word in word_tokenize(unicode(sentence, errors='ignore'))]
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00070.gif)

然后，我们需要去除`停用词`，如`of`，`is`，`the`等：

```py
from nltk.corpus import stopwords
stop = stopwords.words('english')
```

为了处理电子邮件，必须创建一个名为`Process`的函数，以对我们的数据集进行`词形还原`和`标记化`：

```py
def Process(data):
 lemmatizer = WordNetLemmatizer()
 return [lemmatizer.lemmatize(word.lower()) for word in word_tokenize(unicode(sentence,   errors='ignore'))]
```

第二步是通过阅读电子邮件的单词进行特征提取：

```py
from collections import Counter
def Features_Extraction(text, setting):
 if setting=='bow':
# Bow means  bag-of-words
 return {word: count for word, count in Counter(Process(text)).items() if not word in stop}
 else:
 return {word: True for word in Process(text) if not word in stop}
```

提取特征：

```py
features = [(Features_Extraction(email, 'bow'), label) for (email, label) in emails]
```

现在，让我们定义训练模型的 Python 函数：

```py
def training_Model (Features, samples):
 Size = int(len(Features) * samples)
 training , testing = Features[:Size], Features[Size:]
 print ('Training = ' + str(len(training)) + ' emails')
 print ('Testing = ' + str(len(testing)) + ' emails')
```

作为分类算法，我们将使用`NaiveBayesClassifier`：

```py
from nltk import NaiveBayesClassifier, classify
classifier = NaiveBayesClassifier.train(training)
```

最后，我们定义评估 Python 函数：

```py
def evaluate(training, tesing, classifier):
 print ('Training Accuracy is ' + str(classify.accuracy(classifier, train_set)))
 print ('Testing Accuracy i ' + str(classify.accuracy(classifier, test_set)))
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00071.gif)

# 总结

在本章中，我们学习了如何通过从头开始构建三个不同的项目来检测网络钓鱼尝试。首先，我们发现如何利用两种不同的机器学习技术开发网络钓鱼检测器，这要归功于尖端的 Python 机器学习库。第三个项目是一个基于 NLP 和朴素贝叶斯分类的垃圾邮件过滤器。在下一章中，我们将使用不同的技术和 Python 机器学习库构建各种项目来检测恶意软件。

# 问题

希望您能轻松地阅读完本章。现在，像往常一样，是练习时间了。您的任务是尝试构建自己的垃圾邮件检测系统。我们将通过问题来指导您。

在本章的 GitHub 存储库中，您将找到由 Androutsopoulos、J. Koutsias、K.V. Chandrinos、George Paliouras 和 C.D. Spyropoulos 进行的研究收集的数据集：*朴素贝叶斯反垃圾邮件过滤的评估*。*机器学习在新信息时代的研讨会论文集，G. Potamias，V. Moustakis 和 M. van Someren（编辑），第 11 届欧洲机器学习大会，西班牙巴塞罗那，第 9-17 页，2000 年*。

现在可以准备数据了：

1.  以下是一些要执行的文本清理任务：

+   清理文本中的停用词、数字和标点符号。

+   执行词形还原。

1.  创建一个单词字典，包括它们的频率。

在电子邮件文本中，您会注意到第一行是电子邮件的主题，第三行是电子邮件的正文（我们只需要电子邮件正文）。

1.  从字典中删除非单词。

1.  从数据中提取特征。

1.  准备特征向量及其标签。

1.  使用线性支持向量机分类器对模型进行训练。

1.  打印出模型的混淆矩阵。


# 第三章：使用 API 调用和 PE 头部进行恶意软件检测

信息安全中最烦人的威胁之一是恶意程序。每天，我们都会听到关于数据泄露和恶意软件的网络攻击的新闻。攻击者正在提高他们的开发技能，并构建新的恶意软件，能够绕过公司的安全防护和杀毒产品。本章将介绍一些新的技术和解决方案，使用尖端的数据科学、Python 库和机器学习算法来打败恶意软件。

在本章中，我们将涵盖：

+   恶意软件分析方法

+   机器学习辅助的恶意软件分析技术，带有实际的、真实世界的 Python 项目

# 技术要求

在本章中，我们将使用已经安装的相同 Python 库。我们将在本书的大部分章节中使用这些库。这就是为什么我们在第一章中教你如何安装所有所需的库。

你会发现所有讨论过的代码，以及一些其他有用的脚本，都在存储库中[`github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter03`](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter03)。

# 恶意软件概述

恶意软件是设计用来在用户不知情的情况下渗透和破坏信息系统的恶意软件。术语*恶意软件*涵盖了许多类别。有许多不同类型的恶意软件：

+   病毒

+   勒索软件

+   蠕虫

+   特洛伊木马

+   后门

+   间谍软件

+   键盘记录器

+   广告软件、机器人和 rootkits

# 恶意软件分析

作为恶意软件分析员，你的工作是发现系统发生了什么，并确保受恶意软件损害的机器与组织的网络隔离。为了进行恶意软件分析，我们需要遵循特定的操作和方法。在进行恶意软件分析时，我们必须执行三种技术：静态恶意软件分析、动态恶意软件分析和内存恶意软件分析。我们将逐一看看它们。

# 静态恶意软件分析

恶意软件分析的第一步是收集有关恶意软件的所有信息。静态分析是使用不同的技术和实用程序收集有关恶意二进制文件的所有可用信息的艺术。在这个阶段，分析人员在不真正执行它的情况下检查恶意软件。一些常见的静态恶意软件分析方法如下：

+   **在线杀毒扫描**：使用在线扫描器扫描可疑文件是检查文件的好方法，这要归功于在线环境，让你能够使用许多杀毒产品扫描文件。最著名的在线扫描器是 VirusTotal。如果你想扫描一个文件，只需访问[`www.virustotal.com/#/home/upload`](https://www.virustotal.com/#/home/upload)并上传文件：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00072.jpeg)

为了自动化任务，VirusTotal 提供了一些有用的 API。因此，你可以用几行代码构建自己的 Python 脚本：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00073.jpeg)

要扫描`file.exe`，你可以使用来自 VirusTotal 的以下代码片段：

```py
import requests
 url = 'https://www.virustotal.com/vtapi/v2/file/scan'
 params = {'apikey': '<apikey>'}
 files = {'file': ('myfile.exe', open('myfile.exe', 'rb'))}
 response = requests.post(url, files=files, params=params)
 print(response.json())
```

要获取密钥，只需创建一个 VirusTotal 社区帐户。

+   **哈希**：这是一种识别文件的技术。每个哈希文件都有一个唯一的哈希。最常用的哈希函数是 MD5 和 SHA256。

+   **字符串**：这些也是信息的重要来源。从恶意程序中提取字符串将为我们提供有关恶意软件的重要信息。一些字符串包括 URI、URL、错误消息和注释。

# 动态恶意软件分析

收集有关恶意软件的信息后，你应该在一个隔离和安全的环境中运行它。一般来说，这些环境被称为**恶意软件分析沙盒**。沙盒加载了分析和监控工具，以在恶意软件运行时收集有关恶意软件的信息。恶意软件分析人员可以收集以下信息，以及更多：

+   TCP 连接

+   DNS 摘要

+   恶意软件行为

+   系统调用

# 内存恶意软件分析

多年前，使用前两种技术就足以分析恶意软件，但攻击者现在正在使用新的、更复杂的技术来避免检测。我敢打赌你已经听说过无文件恶意软件。需要内存恶意软件分析来检测新一波的恶意软件。内存恶意软件分析是通过分析从感染的机器收集的内存转储来进行的。为了进行内存分析，分析师首先需要获取内存（转储内存），然后可以使用许多实用程序和技术来进行后续分析。

最常用的框架之一是 volatility 框架。如果你安装了 Kali Linux 发行版，你可以在机器上直接使用 volatility 而不需要安装它。以下截图是从 Kali Linux 内置的 volatility 框架中获取的：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00074.jpeg)

Volatility 帮助分析师从内存转储中收集信息，包括以下内容等等：

+   Bash 历史

+   API 钩子

+   网络信息

+   内核加载模块

# 规避技术

攻击者和恶意软件开发者不断想出新的技术和方法来避免检测。一些最常见的技术包括：

+   **混淆**：这是使恶意软件更难以检测或分析的做法。死代码插入、寄存器重新分配和加密是三种混淆技术。

+   **绑定**：这是将恶意软件与合法文件绑定在一起的做法，导致形成一个可执行文件。

+   打包：打包器，有时被称为**自解压缩存档**，是一种软件，当执行*打包文件*时，在内存中解压缩自身。

# 可移植可执行文件格式文件

**可移植可执行文件**（**PE**）文件是用于 32 位和 64 位 Windows 版本的可执行文件、DDL 和目标代码的文件格式。它们包含了许多对恶意软件分析师有用的信息，包括导入、导出、时间戳、子系统、部分和资源。以下是 PE 文件的基本结构：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00075.jpeg)

PE 文件的一些组件如下：

+   DOS 头部：这从每个 PE 文件的前 64 个字节开始，因此 DOS 可以验证可执行文件，并在 DOS stub 模式下运行它。

+   PE 头部：这包含了信息，包括代码的位置和大小。

+   **PE 部分**：它们包含文件的主要内容。

要探索 PE 头部的信息，可以使用许多工具，如 PE EXPLORER、PEview 和 PEstudio。

# 使用 PE 头部进行机器学习恶意软件检测

为了训练我们的机器学习模型来查找恶意软件数据集，有许多公开可用的数据源供数据科学家和恶意软件分析师使用。例如，以下网站为安全研究人员和机器学习爱好者提供了下载许多不同恶意软件样本的能力：

+   **恶意软件流量分析**：[`www.malware-traffic-analysis.net/`](https://www.malware-traffic-analysis.net/)

+   Kaggle 恶意软件家族：[`www.kaggle.com/c/malware-classification`](https://www.kaggle.com/c/malware-classification)

+   **VX 天堂**：[`83.133.184.251/virensimulation.org/index.html`](http://83.133.184.251/virensimulation.org/index.html)

+   **VirusTotal**：[`www.virustotal.com`](https://www.virustotal.com)

+   **VirusShare**：[`virusshare.com`](https://virusshare.com)

要处理 PE 文件，我强烈推荐使用一个名为`pefile`的惊人 Python 库。`pefile`让你能够检查头部、分析部分、检索数据，以及其他功能，如打包器检测和 PEiD 签名生成。你可以在 GitHub 项目中查看[`github.com/erocarrera/pefile`](https://github.com/erocarrera/pefile)。

你也可以像我们使用其他机器学习库一样使用 PIP 安装它：

```py
# pip install pefile
```

现在我们成功安装了`pefile`：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00076.jpeg)

让我们开始构建我们的第一个恶意软件分类器。对于这个模型，我们将使用三种不同的技术：

+   随机森林

+   梯度提升分类

+   AdaBoost 分类

正如你可能从本书中的分类算法中注意到的那样，我们正在尝试使用许多不同的技术。在某些情况下，您可以使用先前讨论过的算法之一，但我正在尝试在每一章中使用不同的技术，以便您可以清楚地了解如何使用每种机器学习技术。

到目前为止，您已经意识到构建机器学习模型的第一步（在研究项目需求和要求之后，当然）是下载数据集。在本节中，我们将下载由安全博主 Prateek Lalwani 提供的恶意软件数据集。恶意软件数据集包含从以下提取的特征：

+   41,323 个 Windows 二进制文件（可执行文件`.exe`和`.dlls`），作为合法文件。

+   从 VirusShare 网站下载的 96,724 个恶意软件文件。因此，数据集总共包含 138,048 行。

数据集分为如下：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00077.jpeg)

让我们从`pandas` Python 库中加载恶意软件数据集开始：

```py
import pandas as pd
MalwareDataset = pd.read_csv('MalwareData.csv', sep='|')
Legit = MalwareDataset[0:41323].drop(['legitimate'], axis=1)
Malware = MalwareDataset[41323::].drop(['legitimate'], axis=1)
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00078.jpeg)

为了确保数据集已正确加载，请打印重要特征的数量：

```py
print('The Number of important features is  %i \n' % Legit.shape[1])
```

`重要特征的数量为 56`将是结果行：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00079.gif)

为了提高估计器的准确度分数，我们将使用`sklearn.feature_selection`模块。该模块用于特征选择或数据集的降维。

要计算特征的重要性，在我们的情况下，我们将使用基于树的特征选择。加载`sklearn.feature_selection`模块：

```py
import sklearn
from sklearn.feature_selection import SelectFromModel
from sklearn.ensemble import ExtraTreesClassifier
from sklearn.model_selection import train_test_split
from sklearn import cross_validation 
Data = MalwareDataset.drop(['Name', 'md5', 'legitimate'], axis=1).values
Target = MalwareDataset['legitimate'].values
FeatSelect =  sklearn.ensemble.ExtraTreesClassifier().fit(Data, Target)
Model = SelectFromModel(FeatSelect, prefit=True)
Data_new = Model.transform(Data)
print (Data.shape)
print (Data_new.shape)
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00080.gif)

因此，算法已为我们选择了九个重要特征。要打印它们，请使用以下命令：

```py
Features = Data_new.shape[1]
Index = np.argsort(ske.ExtraTreesClassifier().fit(Data,Target).feature_importances_)[::-1][:Features]
for feat  in range(Features):
print(MalwareDataset.columns[2+index[feat]])
```

最重要的特征如下：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00081.jpeg)

现在，是时候用随机森林分类器训练我们的模型了。不要忘记像我们之前学到的那样分割数据集：

```py
Legit_Train, Legit_Test, Malware_Train, Malware_Test = cross_validation.train_test_split(Data_new, Target ,test_size=0.2) 
clf =  sklearn.ensemble.RandomForestClassifier(n_estimators=50)
clf.fit(Legit_Train, Malware_Train)
score = clf.score(Legit_Test, Malware_Test)
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00082.gif)

让我们看看最终结果：

```py
print("The score of Random Forest Algorithm is," score*100))
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00083.gif)

得分看起来非常有希望。该模型以 99%的成功率检测到了恶意软件，这是一个很好的结果。要获取有关我们的恶意软件分类器的`假阳性`和`假阴性`率的更多信息，请导入 scikit-learn`confusion_matrix`模块：

```py
from sklearn.metrics import confusion_matrix
```

添加以下行：

```py
Result = clf.predict(Legit_Test)
CM = confusion_matrix(Malware_Test, Result)
print("False positive rate : %f %%" % ((CM[0][1] / float(sum(CM[0])))*100)) print('False negative rate : %f %%' % ( (CM[1][0] / float(sum(CM[1]))*100)))
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00084.gif)

`假阳性率`为 0.6%，`假阴性率`为 1.4%。

要使用另一个分类器训练模型，请重复上述步骤，但是选择随机森林分类器的代替，选择一种机器学习算法。例如，我将选择梯度提升：

```py
Clf = sklearn.ensemble.GradientBoostingClassifier(n_estimators=50)
Clf.fit(Legit_Train, Malware_Train)
Score = Clf.score(Legit_Test, Malware_Test)
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00085.gif)

让我们检查第二个分数：

```py
print ("The Model score using Gradient Boosting is", Score * 100)
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00086.gif)

这有 98.8%的检测率。使用 AdaBoost 分类器的得分如下：

```py
Classifiers =
{ "RandomForest": ske.RandomForestClassifier(n_estimators=50), "GradientBoosting": ske.GradientBoostingClassifier(n_estimators=50), "AdaBoost": ske.AdaBoostClassifier(n_estimators=100),}

for Classif in Classifiers:
clf = Classifiers[Classif]
clf.fit(Legit_Train,Malware_Train)
score = clf.score(Legit_test, Malware_test)
print("%s : %f %%" % (Classif, score*100))
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00087.gif)

# 使用 API 调用的机器学习恶意软件检测

使用 API 调用分析恶意软件在恶意软件分析中起着重要作用。因此，API 可以让恶意软件分析人员了解恶意软件行为，特别是在基本的静态分析由于混淆技术（如打包程序、加密程序和保护程序）而失败时。通过研究 API 调用，恶意软件分析人员可以了解恶意文件的工作原理。有许多在线工具可以让您在安全环境中分析恶意软件。这些实用程序和环境被称为沙箱。检测到的恶意软件由哈希函数（MD5 或 SHA256）标识。恶意软件分析人员使用哈希对文件进行签名。例如，以下 API 是从[`www.hybrid-analysis.com`](https://www.hybrid-analysis.com)的在线恶意软件扫描报告中获取的。

这是关于恶意软件“PE32 可执行文件（GUI）Intel 80386，用于 MS Windows”的一些细节。它的哈希是：4c510779ab6a58a3bdbbe8d5f3ec568fcf33df81b0f1a5bdacabf78a9c62f492

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00088.gif)

根据微软网站，[`msdn.microsoft.com/`](https://msdn.microsoft.com/)，`GetProcAddress`从指定的**动态链接库**（**DLL**）中检索导出函数或变量的地址。因此，如果您想了解更多关于其他调用的信息，只需访问微软开发者网络并搜索 API 调用函数：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00089.jpeg)

报告包括对发现的完整总结，不仅包括 API 调用。它包括：

+   一般信息

+   恶意指标

+   异常特征

+   反检测/隐蔽性

+   反向工程

+   网络相关信息

以下是有关扫描的恶意软件的信息。我们之前讨论了大部分所需的发现（静态分析工件：大小、类型等）：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00090.jpeg)

对于我们的第二个恶意软件分类器，我们将使用 API 调用来构建一个机器学习恶意软件检测器。为了从恶意软件二进制文件中提取 API，恶意软件分析师需要按照明确定的步骤进行：

1.  恶意软件解包

1.  汇编程序检索

1.  API 调用提取

1.  使用官方微软网站分析 API 调用

您可以将恶意软件行为分为不同组。例如，巴拉瑞特大学在文章《通过提取 API 调用来理解恶意软件行为》中将 API 调用分为六类。您可以使用它来分析您的发现：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00091.jpeg)

作为演示，让我们使用支持向量机学习算法和 API 调用数据集构建一个 Android 恶意软件检测项目。本章的 GitHub 文件夹包含一个准备好的数据集来构建我们的模型：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00092.jpeg)

在构建模型之前，我们需要导入一些有用的模块：

```py
>>> from sklearn.feature_selection import mutual_info_classif
>>> from sklearn import preprocessing
>>> import numpy as np
>>> from sklearn.svm import SVC, LinearSVC
>>> from sklearn import svm
>>> import csv
>>> import random
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00093.jpeg)

首先，让我们预处理我们的 CSV 文件（`Android_Feats.csv`）：

```py
>>> PRatio = 0.7
>>> Dataset =  open('Android_Feats.csv')
>>> Reader = csv.reader(Dataset)
>>> Data = list(Reader)
>>> Data = random.sample(Data, len(Data))
>>> Data = np.array(Data)
> Dataset.close()
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00094.gif)

使用 NumPy 标识文件中的数据和标签：

```py
>>> cols = np.shape(Data)[1]
>>> Y = Data[:,cols-1]
>>> Y = np.array(Y)
>>> Y = np.ravel(Y,order='C')
>>> X = Data[:,:cols-1]
>>> X = X.astype(np.float)
>>> X = preprocessing.scale(X)
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00095.gif)

到目前为止，处理阶段已经完成。如前所述，我们需要提取最重要的特征，因为计算所有可用的特征将是一项繁重的任务：

```py
Features = [i.strip() for i in open("Android_Feats.csv").readlines()]
Features = np.array(Features)
MI= mutual_info_classif(X,Y)
Featureind = sorted(range(len(MI)), key=lambda i: MI[i], reverse=True)[:50]
SelectFeats = Features[Featureind]
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00096.gif)

现在，将数据集（数据和标签）分成训练集和测试集：

```py
PRows = int(PRatio*len(Data))
TrainD = X[:PRows,Featureind]
TrainL = Y[:PRows]
TestD = X[PRows:,Featureind]
TestL = Y[PRows:]
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00097.gif)

特征选择已成功完成。为了训练模型，我们将使用支持向量机分类器：

```py
>>> clf = svm.SVC()
>>> clf.fit(TrainD,TrainL)
>>> score = clf.score(TestD,TestL)
>>> print (score * 100)
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00098.gif)

哇！我们新模型的准确率为 98%，这是一个很高的检测率。

# 总结

恶意软件是困扰现代组织安全的最普遍的网络威胁之一。黑客不断改进，因此传统的检测技术已经过时，杀毒产品通常无法检测到高级持久性威胁。这就是为什么机器学习技术可以帮助我们检测恶意软件。

在本章中，我们学习了如何使用许多机器学习算法和开源 Python 库构建恶意软件分类器。下一章将教我们如何使用与人类思维相同的算法构建更加健壮的系统来检测恶意软件。我们将学习如何使用深度学习来检测恶意软件，使用本书中一直使用的 Python 库。

# 问题

现在您可以构建一个机器学习模型。让我们练习一下，将我们的新技能付诸实践。在本章的 GitHub 存储库中，您将找到一个包含有关 Android 恶意软件样本信息的数据集。现在您需要按照这些说明构建自己的模型。

在`Chapter3-Practice` GitHub 存储库中，您将找到一个包含超过 11,000 个良性和恶意 Android 应用程序特征向量的数据集：

1.  使用`pandas` python 库加载数据集，并且这次添加`low_memory=False`参数。搜索该参数的作用。

1.  准备用于训练的数据。

1.  使用`test_size=0.33`参数拆分数据。

1.  创建一个包含`DecisionTreeClassifier()`、`RandomForestClassifier(n_estimators=100)`和`AdaBoostClassifier()`的分类器集合。

1.  `AdaBoostClassifier()`是什么？

1.  使用这三个分类器训练模型，并打印出每个分类器的指标。

# 进一步阅读

欲了解更多信息，请查看以下日志帖子和文档：

+   PE 格式（Windows）：[`msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx`](https://msdn.microsoft.com/en-us/library/windows/desktop/ms680547(v=vs.85).aspx)

+   *恶意软件分析：介绍*：[`www.sans.org/reading-room/whitepapers/malicious/malware-analysis-introduction-2103`](https://www.sans.org/reading-room/whitepapers/malicious/malware-analysis-introduction-2103)

+   VirusTotal 文档：[`www.virustotal.com/en/documentation/`](https://www.virustotal.com/en/documentation/)


# 第四章：使用深度学习进行恶意软件检测

人类大脑是一个迷人的实体。我们的潜意识和无意识思维的力量是不可思议的。使这种力量变得真实的是我们不断自学和快速适应的能力。这种自然的惊人天赋可以在你意识到之前计算数十亿个任务。几十年来，科学家一直在努力构建能够像人类大脑一样同时执行任务的机器，换句话说，能够高效地以令人难以置信的速度执行大量任务的系统。一个名为**深度学习（DL）**的机器学习子领域应运而生，帮助我们构建像人类大脑一样工作并受其结构启发的算法。信息安全专业人员也对这些技术感兴趣，因为它们在防御重大网络威胁和攻击方面取得了有希望的结果。深度学习的最佳实施候选之一是恶意软件分析。

在本章中，我们将发现：

+   人工神经网络：深入概述

+   如何使用 Python 构建你的第一个神经网络

+   如何使用多层感知器构建恶意软件检测器

+   恶意软件可视化技术以及如何使用卷积神经网络构建恶意软件分类器

# 技术要求

基本上，在本章中，我们将使用已经安装的相同的 Python 库。通常情况下，我们将在本书的大多数章节中使用这些库。因此，我们在第一章花了时间教你如何安装我们在大多数章节和项目中将要使用的所有必需库。在此链接找到代码文件：[`github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter04`](https://github.com/PacktPublishing/Mastering-Machine-Learning-for-Penetration-Testing/tree/master/Chapter04)。

# 人工神经网络概述

我们的大脑在眨眼之间执行许多复杂的功能。因此，为了构建能够执行和学习使用与人类思维相同的技术的算法，我们必须了解大脑的工作原理是至关重要的。通过对人类大脑功能的公平理解，我们将更好地理解深度学习。三个主要的独特的大脑功能是：

+   思考（分析、比较和判断）

+   情感（快乐、悲伤和兴奋）

+   渴望（动机、欲望和目标）

这三个功能在一个动态的过程中不断地相互作用。

大脑主要由三个部分组成：**大脑皮层**，它是大脑的最大部分，控制着视觉、听觉和味觉等高级功能；**小脑**，它负责协调肌肉运动和人体的一般姿势，包括平衡；第三部分称为**脑干**，它连接了前两部分并控制许多其他任务，包括打喷嚏、咳嗽和消化。

大脑通过其不同的部分执行复杂的操作。从逻辑上讲，人类大脑的解剖结构由许多区域组成，因此每个区域都基于特定的算法工作。尽管大脑的每个部分都使用自己的算法工作，但令人惊讶的是，人类大脑基本上使用相同的算法来理解许多不同的输入模式。这个假设被称为**一个学习算法**假设。1992 年*Roe 等人*进行的许多研究证明了这一点，特别是雪貂实验，其中视觉输入被插入到雪貂大脑的听觉部分，听觉皮层学会了如何看。

以下图表描述了**人工智能（AI）**、**机器学习（ML）**和**深度学习（DL）**之间的关系：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00099.jpeg)

从生物学上讲，人类大脑由数十亿个称为神经元的小器官组成。神经元是通过电信号和化学信号处理和传递信息的单位。这些神经细胞主要由以下组成：

+   树突

+   轴突

+   突触

+   细胞体

+   细胞核

以下图表说明了生物神经元的不同组成部分：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00100.jpeg)

生物神经元的类比表示被称为**感知器**。感知器可以分解为：

+   输入

+   权重

+   净输入函数

+   激活函数

+   输出

感知器和人类神经元之间的类比并不完全正确。它只是用来让人们对感知器的工作有所了解。人类大脑比人工神经网络复杂得多。有一些相似之处，但直接将大脑和神经网络进行比较是不合适的。

# 在 Python 中实现神经网络

经典的计算机程序在基于一系列指令和算术的计算操作方面表现出色，但在许多其他情况下都面临困难和挑战；例如，手写识别。作为热身，让我们构建一个手写数字识别器，以便有机会安装下一节中所需的 Python 库，并学习如何在 Python 中构建和实现我们的第一个神经网络。要训练模型，我们需要用数据来喂养它。在我们的实现中，我们将使用 MNIST 数据集：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00101.gif)

首先，让我们使用`pip install`命令安装`keras`库，如下所示：

```py
# pip install keras
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00102.jpeg)

然后，使用以下命令安装 TensorFlow（`tensorflow`）：

```py
# pip install tensorflow
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00103.jpeg)

最后，安装`np_utils`：

```py
# pip install np_utils
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00104.jpeg)

打开 Python 命令行界面，并使用导入命令导入以下模块：

+   `mnist` 数据集

+   `Sequential` 模型

+   `Dense` 和 `Dropout` 层

+   `np_utils` 模块

```py
>>> from keras.models import Sequential
>>> from keras.layers import Dense
>>> from keras.layers import Dropout
>>> from keras.utils import np_utils
```

以下图表说明了前面的代码：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00105.jpeg)

使用种子是因为我们希望结果是可重复的。`numpy.random.seed(seed)`用于给生成器设定种子：

```py
>>> seed = 7
>>> numpy.random.seed(seed)
>>> (X_train, y_train), (X_test, y_test) = mnist.load_data()
```

从[`s3.amazonaws.com/img-datasets/mnist.pkl.gz`](https://s3.amazonaws.com/img-datasets/mnist.pkl.gz)下载数据：

```py
>>> num_pixels = X_train.shape[1] * X_train.shape[2]
>>> X_train = X_train.reshape(X_train.shape[0], num_pixels).astype('float32')
>>> X_test = X_test.reshape(X_test.shape[0], num_pixels).astype('float32')
>>> X_train = X_train / 255
>>> X_test = X_test / 255

>>> y_train = np_utils.to_categorical(y_train)
>>> y_test = np_utils.to_categorical(y_test)
>>> num_classes = y_test.shape[1]
>>> model = Sequential()
>>>model.add(Dense(num_pixels, input_dim=num_pixels, activation='relu'))
>>>model.add(Dense(num_classes,activation='softmax'))
>>>model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
```

这里，`.astype()`用于转换变量，`.reshape()`用于给数组一个新的形状而不改变数据：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00106.gif)

我们手写数字分类器的准确率为 99.8%，这是一个惊人的结果。现在我们已经学会了如何构建我们的第一个神经网络程序，是时候利用我们的技能并亲自体验如何使用人工神经网络构建恶意软件分类器，特别是 DL 网络了。

# 使用 PE 头构建深度学习模型

根据我们学到的概念，我们将使用人工神经网络构建一个恶意软件检测器。让我们从识别我们的数据集开始。到目前为止，您已经熟悉了构建机器学习模型所需的步骤。对于这个模型，我们将使用**可移植可执行文件**（**PE**）文件作为输入数据。正如您在上一章中注意到的，我们安装了一个名为`pefile`的 Python 库。现在是时候在这个模型中使用它了。一旦我们使用 Python 包安装管理器 PIP 安装了`pefile`，我们就可以开始使用`pefile`从任何 PE 文件中提取信息。为了从 PE 文件中收集信息，导入`os`和`pefile`库。`os`库允许您与 Python 正在运行的底层操作系统进行交互。

作为演示，我们将下载由 Palo Alto 网络提供的用于实验目的的恶意软件 PE 文件。使用`wget`命令下载如下：

```py
# wget https://wildfire.paloaltonetworks.com/publicapi/test/pe  
```

安装 PE 文件后，打开 Python 环境并导入所需的库，如下所示：

```py
>>> import os
>>> import pefile
```

使用以下命令加载文件：

```py
>>> PEfile = pefile.PE("pe", fast_load=True)
```

现在我们能够从 PE 文件中提取`PE_HEADER_OPTIONAL`信息，包括`MajorLinkerVersion`、`MajorLinkerVersion`、`SizeOfImage`和`DllCharacteristics`。您可以通过查看微软文档找到完整的列表：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00107.jpeg)

在下面的脚本中，我提取了关于的信息：

+   `LinkerVersion`

+   `NumberOfSections`

+   `ImageVersion`

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00108.gif)

我们知道，训练模型在计算方面是一个高消耗的任务。因此，处理和提供所有头信息给模型并不是一个明智的决定。因此，我们需要对其进行特征工程。选择好的特征是每个数据科学任务中需要的技能。Adobe Systems 的**产品安全事件响应团队**（**PSIRT**）的 Karthik Raman 进行的一项名为*选择用于分类恶意软件的特征*的研究提出了解决这个问题的建议，建议我们选择最重要的 PE 头部，它们如下：

+   `DebugSize`

+   `DebugRVA`

+   `ImageVersion`

+   `OperatingSystemVersion`

+   `SizeOfStackReserve`

+   `LinkerVersion`

+   `DllCharacteristics`

+   `IatRVA`

+   `ExportSize`

+   `ExportRVA`

+   `ExportNameLen`

+   `ResourceSize`

+   `ExportFunctionsCount`

要提取它们，您可以像之前一样使用导入的`PEfile`模块：

```py
DebugSize = PEfile.OPTIONAL_HEADER.DATA_DIRECTORY[6].Size
print (DebugSize)
DebugRVA = PEfile.OPTIONAL_HEADER.DATA_DIRECTORY[6].VirtualAddress
print (DebugRVA)
 ImageVersion = PEfile.OPTIONAL_HEADER.MajorImageVersion
 print (ImageVersion)
OSVersion = PEfile.OPTIONAL_HEADER.MajorOperatingSystemVersion
print (OSVersion)
ExportRVA = PEfile.OPTIONAL_HEADER.DATA_DIRECTORY[0].VirtualAddress
 print (ExportRVA)
ExportSize = PEfile.OPTIONAL_HEADER.DATA_DIRECTORY[0].Size
print (ExportSize)
IATRVA = PEfile.OPTIONAL_HEADER.DATA_DIRECTORY[12].VirtualAddress
 print (IATRVA)
ResSize = PEfile.OPTIONAL_HEADER.DATA_DIRECTORY[2].Size
 print (ResSize)
LinkerVersion = PEfile.OPTIONAL_HEADER.MajorLinkerVersion
 print (LinkerVersion)
NumberOfSections = PEfile.FILE_HEADER.NumberOfSections
 print (NumberOfSections)
StackReserveSize = PEfile.OPTIONAL_HEADER.SizeOfStackReserve
 print (StackReserveSize)
Dll = PEfile.OPTIONAL_HEADER.DllCharacteristics
print (Dll)
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00109.gif)

为了训练模型，有许多公开可用的来源。您可以从大量的组织和教育机构的列表中下载不同类型的文件（清洁和恶意）：

+   **ViruSign**: [`www.virusign.com/`](http://www.virusign.com/)

+   **MalShare**: [`malshare.com/`](http://malshare.com/)

+   **Malware DB**: [`ytisf.github.io/theZoo/`](http://ytisf.github.io/theZoo/)

+   **Endgame Malware BEnchmark for Research (EMBER)**：这是最大的数据集之一，包含 2017 年某个时候扫描的 1.1 百万个 PE 文件的 SHA256 哈希值。我强烈建议您下载并尝试使用它构建您的模型。您可以从[`pubdata.endgame.com/ember/ember_dataset.tar.bz2`](https://pubdata.endgame.com/ember/ember_dataset.tar.bz2)下载（1.6 GB，扩展到 9.2 GB）：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00110.jpeg)

您的数据集应包含两类 PE 文件：**清洁**和**恶意文件**。我们需要至少 10,000 个文件来训练模型。您将需要开始使用先前的脚本提取头信息。您可以通过自己开发自动化脚本来自动化任务。可以使用任何编程语言。最好的方法是将所有文件的选定特征导出到 CSV 文件中，这样我们可以使用前几章学到的知识，以后可以使用 pandas 加载它们：

```py
Malware  = pd.read_csv("Malware.csv")
Clean_Files = pd.read_csv("Clean_Files.csv")
```

准备好特征后，我们需要将两种类型的数据合并为一种。例如，我们可以使用`pd.concat`来合并这两个文件。为了训练模型，我们需要导入所需的模块：

```py
>>> import numpy as np
>>> from sklearn.model_selection import train_test_split
>>> from sklearn.metrics import confusion_matrix
>>> from sklearn.neural_network import MLPClassifier
>>> from sklearn.preprocessing import StandardScaler
```

数据准备：

```py
y = dataset['Clean_Files']
X = dataset.drop('Clean_Files',axis = 1)
X = np.asarray(X)
y = np.asarray(y)
```

这行是用于分割，就像我们在其他模型中做的那样：

```py
X_train,X_test,y_train,y_test = train_test_split(X,y,test_size = 0.3,random_state=0)
```

为了更好的预测，我们可以使用`StandScaler()`；它用于通过去除均值和缩放到单位方差来标准化特征：

```py
scaler = StandardScaler()
scaler.fit(X_train)
X_train = scaler.transform(X_train)
X_test = scaler.transform(X_test)
```

准备和特征工程数据后，我们必须构建**多层感知器**（**MLP**）网络：

```py
MLP = MLPClassifier(hidden_layer_sizes=(12,12,12,12,12,12))
```

这里，`12`是层数和特征数。让我们训练模型并计算预测：

```py
MLP.fit(X_train,y_train)
Predictions = MLP.predict(X_test)
```

要检查评估指标，请添加以下行：

```py
TN, FP, FN TP = confusion_matrix(y_test,predictions).ravel()
```

在这里使用`ravel()`返回一个连续的扁平数组。它相当于`reshape(-1, order=order)`：

```py
print ("True Positive:" , TP)
print ("True Negative:" , TN)
print ("False Positive:" , FP)
print ("False Negative:" , FN)
```

# 使用卷积神经网络和恶意软件可视化的深度学习模型

上一节是用 MLP 网络来检测恶意软件的真实实现。现在，我们将探索其他人工网络架构，并学习如何使用其中之一来帮助恶意软件分析师和信息安全专业人员检测和分类恶意代码。在深入技术细节和 DL 方法的实际实施步骤之前，了解和发现其他不同的人工神经网络架构是至关重要的。我们在第一章中简要讨论了其中一些。现在讨论主要的人工神经网络。

# 卷积神经网络（CNN）

**卷积神经网络**（**CNNs**）是解决图像分类问题的深度学习方法，或者我们称之为计算机视觉问题，因为经典的计算机程序面临许多挑战和困难，无法识别对象，包括光照，视角，变形和分割。这种技术受到了眼睛工作的启发，特别是动物视觉皮层功能算法。在 CNN 中，以宽度，高度和深度为特征排列成三维结构。对于图像，高度是图像高度，宽度是图像宽度，深度是 RGB 通道。要构建 CNN，我们需要三种主要类型的层：

+   **卷积层**：卷积操作是指从输入图像中提取特征，并将滤波器中的值与原始像素值相乘

+   **池化层**：池化操作减少每个特征图的维度

+   **全连接层**：全连接层是具有 softmax 激活函数的经典多层感知器

要使用 Python 实现 CNN，可以使用以下 Python 脚本：

```py
import numpy
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import Flatten
from keras.layers.convolutional import Conv2D
from keras.layers.convolutional import MaxPooling2D
from keras.utils import np_utils
from keras import backend 
backend.set_image_dim_ordering('th')

model = Sequential()
model.add(Conv2D(32, (5, 5), input_shape=(1, 28, 28), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.2))
model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dense(num_classes, activation='softmax'))
model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])
```

# 循环神经网络（RNNs）

**循环神经网络**（**RNNs**）是人工神经网络，我们可以利用序列信息，例如句子。换句话说，RNN 对序列的每个元素执行相同的任务，输出取决于先前的计算。RNN 广泛用于语言建模和文本生成（机器翻译，语音识别等许多应用）。RNN 不能长时间记住事情。

# 长短期记忆网络

**长短期记忆**（**LSTM**）通过构建一个记忆块来解决循环神经网络中的短期记忆问题。这个块有时被称为**记忆单元**。

# Hopfield 网络

Hopfield 网络是由 John Hopfield 于 1982 年开发的。Hopfield 网络的主要目标是自动关联和优化。我们有两类 Hopfield 网络：**离散**和**连续**。

# 玻尔兹曼机网络

玻尔兹曼机网络使用循环结构，只使用局部可用信息。它们是由 Geoffrey Hinton 和 Terry Sejnowski 于 1985 年开发的。此外，玻尔兹曼机的目标是优化解决方案。

# 使用 CNN 进行恶意软件检测

对于这个新模型，我们将探讨如何使用 CNN 构建恶意软件分类器。但我敢打赌，你一定想知道我们如何做到这一点，因为 CNN 是以图像作为输入的。答案很简单，这里的诀窍是将恶意软件转换为图像。这可能吗？是的，是可能的。在过去几年中，恶意软件可视化是许多研究课题之一。其中一种提出的解决方案来自一项名为*Malware Images: Visualization and Automatic Classification*的研究，作者是加州大学圣巴巴拉分校的 Vision Research Lab 的*Lakshmanan Nataraj*。

以下图表详细说明了如何将恶意软件转换为图像：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00111.jpeg)

以下是**Alueron.gen!J**恶意软件的图像：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00112.gif)

这种技术还使我们能够以详细的方式可视化恶意软件部分：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00113.jpeg)

通过解决如何通过图像为使用 CNN 的恶意软件机器学习分类器提供数据的问题，信息安全专业人员可以利用 CNN 的力量来训练模型。最经常用来为 CNN 提供数据的恶意软件数据集之一是**Malimg 数据集**。这个恶意软件数据集包含来自 25 个不同恶意软件家族的 9,339 个恶意软件样本。您可以从 Kaggle（一个用于预测建模和分析竞赛的平台）下载它，访问以下链接：[`www.kaggle.com/afagarap/malimg-dataset/data`](https://www.kaggle.com/afagarap/malimg-dataset/data)。

这些是恶意软件家族：

+   Allaple.L

+   Allaple.A

+   Yuner.A

+   Lolyda.AA 1

+   Lolyda.AA 2

+   Lolyda.AA 3

+   C2Lop.P

+   C2Lop.gen!G

+   即时访问

+   Swizzor.gen!I

+   Swizzor.gen!E

+   VB.AT

+   Fakerean

+   Alueron.gen!J

+   Malex.gen!J

+   Lolyda.AT

+   Adialer.C

+   Wintrim.BX

+   Dialplatform.B

+   Dontovo.A

+   Obfuscator.AD

+   Agent.FYI

+   Autorun.K

+   Rbot!gen

+   Skintrim.N

将恶意软件转换为灰度图像后，您可以获得以下恶意软件表示，以便以后用于为机器学习模型提供数据：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00114.jpeg)

将每个恶意软件转换为灰度图像可以使用以下 Python 脚本完成：

```py
import os
import scipy
import array
 filename = '<Malware_File_Name_Here>';
 f = open(filename,'rb');
 ln = os.path.getsize(filename);
width = 256;
 rem = ln%width;
 a = array.array("B");
 a.fromfile(f,ln-rem);
 f.close();
 g = numpy.reshape(a,(len(a)/width,width));
 g = numpy.uint8(g);
 scipy.misc.imsave('<Malware_File_Name_Here>.png',g);
```

对于特征选择，您可以提取或使用任何图像特征，比如纹理模式、图像中的频率、强度或颜色特征，使用不同的技术，比如**欧几里得距离**，或者均值和标准差，以后生成特征向量。在我们的情况下，我们可以使用诸如颜色布局描述符、均匀纹理描述符或**全局图像描述符**（**GIST**）等算法。假设我们选择了 GIST；`pyleargist`是一个很棒的 Python 库来计算它。要安装它，像往常一样使用 PIP：

```py
# pip install pyleargist==1.0.1
```

作为一个用例，要计算 GIST，您可以使用以下 Python 脚本：

```py
import Image
Import leargist
 image = Image.open('<Image_Name_Here>.png');
 New_im = image.resize((64,64));
des = leargist.color_gist(New_im);
Feature_Vector = des[0:320];
```

这里，`320`指的是我们使用灰度图像时的前`320`个值。不要忘记将它们保存为*NumPy 数组*，以便以后用于训练模型。

在获得特征向量之后，我们可以训练许多不同的模型，包括 SVM、k-means 和人工神经网络。其中一个有用的算法是 CNN 的算法。

特征选择和工程完成后，我们可以构建 CNN。例如，对于我们的模型，我们将构建一个具有两个卷积层的卷积网络，输入为*32 * 32*。使用 Python 库构建模型时，我们可以使用之前安装的 TensorFlow 和 utils 库来实现它。

因此，整体的 CNN 架构将如下图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/ms-ml-pentest/img/00115.jpeg)

这种 CNN 架构不是构建模型的唯一提议，但目前我们将用它来实现。

要构建模型和一般的 CNN，我强烈推荐 Keras。所需的导入如下：

```py
import keras
 from keras.models import Sequential,Input,Model
 from keras.layers import Dense, Dropout, Flatten
 from keras.layers import Conv2D, MaxPooling2D
 from keras.layers.normalization import BatchNormalization
 from keras.layers.advanced_activations import LeakyReLU
```

正如我们之前讨论的，灰度图像的像素值范围从 0 到 255，我们需要将*32 * 32 * 1*维度的图像作为结果输入到网络中：

```py
train_X = train_X.reshape(-1, 32,32, 1)
test_X = test_X.reshape(-1, 32,32, 1)
```

我们将使用以下参数训练我们的网络：

```py
batch_size = 64
epochs = 20
num_classes = 25
```

要构建架构，关于其格式，使用以下内容：

```py
Malware_Model = Sequential()
Malware_Model.add(Conv2D(32, kernel_size=(3,3),activation='linear',input_shape=(32,32,1),padding='same'))
Malware_Model.add(LeakyReLU(alpha=0.1))
Malware_model.add(MaxPooling2D(pool_size=(2, 2),padding='same'))
Malware_Model.add(Conv2D(64, (3, 3), activation='linear',padding='same'))
Malware_Model.add(LeakyReLU(alpha=0.1))
Malware_Model.add(Dense(1024, activation='linear'))
Malware_Model.add(LeakyReLU(alpha=0.1))
Malware_Model.add(Dropout(0.4))
Malware_Model.add(Dense(num_classes, activation='softmax'))
```

要编译模型，使用以下内容：

```py
Malware_Model.compile(loss=keras.losses.categorical_crossentropy, optimizer=keras.optimizers.Adam(),metrics=['accuracy'])
```

适应并训练模型：

```py
Malware_Model.fit(train_X, train_label, batch_size=batch_size,epochs=epochs,verbose=1,validation_data=(valid_X, valid_label))
```

正如您注意到的，我们尊重了在前几章中讨论的训练神经网络的流程。要评估模型，使用以下代码：

```py
Malware_Model.evaluate(test_X, test_Y_one_hot, verbose=0)
print('The accuracy of the Test is:', test_eval[1])
```

# 将深度学习应用于恶意软件检测的承诺和挑战

机器学习从业者和恶意软件分析师提出了许多不同的深度网络架构，用于检测已知和未知的恶意软件；一些提出的架构包括受限玻尔兹曼机和混合方法。您可以在*进一步阅读*部分中查看其中一些。检测恶意软件和恶意软件的新方法显示出许多有希望的结果。然而，恶意软件分析师在使用深度学习网络检测恶意软件时面临许多挑战，特别是在分析 PE 文件时，因为要分析 PE 文件，我们将每个字节作为一个输入单元，因此我们需要处理包含数百万步的序列分类，另外还需要保持由于函数调用和跳转命令而产生的复杂的空间相关性。

# 总结

恶意软件对每个现代组织来说都是一场噩梦。攻击者和网络犯罪分子总是想出新的恶意软件来攻击他们的目标。安全供应商正在尽力防御恶意软件攻击，但不幸的是，每月发现数百万种恶意软件，他们无法做到。因此，需要新的方法，这正是我们在本章和上一章中研究的内容。我们发现了如何使用不同的机器学习算法构建恶意软件检测器，特别是利用深度学习技术的力量。在下一章中，我们将学习如何通过构建和开发强大的智能系统来检测僵尸网络。

# 问题

1.  MLP 网络和深度学习网络之间有什么区别？

1.  为什么最近 DL 开始起飞？

1.  为什么我们需要通过不同的模型进行多次迭代？

1.  翻译英语到法语语言需要哪种 DL 类型？

1.  为什么恶意软件可视化是分类恶意软件的好方法？

1.  激活函数的作用是什么？

1.  你能提到三种 DL 架构吗？

# 进一步阅读

+   **博客文章**：

+   Keras 教程：Python 中的深度学习（[`www.datacamp.com/community/tutorials/deep-learning-python`](https://www.datacamp.com/community/tutorials/deep-learning-python)）

+   使用 Keras 逐步在 Python 中开发您的第一个神经网络（[`machinelearningmastery.com/tutorial-first-neural-network-python-keras/`](https://machinelearningmastery.com/tutorial-first-neural-network-python-keras/)）

+   手写数字的 MNIST 数据库（[`yann.lecun.com/exdb/mnist`](http://yann.lecun.com/exdb/mnist)/）

+   **论文和演示**：

+   恶意软件家族的高维可视化（[`www.rsaconference.com/writable/presentations/file_upload/tta-f04-high-dimensional-visualization-of-malware-families.pdf`](https://www.rsaconference.com/writable/presentations/file_upload/tta-f04-high-dimensional-visualization-of-malware-families.pdf)）

+   基于深度学习的混合恶意代码检测方法（[`www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Malicious%20Code%20Detection%20Method%20based%20on%20Deep%20Learning.pdf`](http://www.covert.io/research-papers/deep-learning-security/A%20Hybrid%20Malicious%20Code%20Detection%20Method%20based%20on%20Deep%20Learning.pdf)）

+   使用 API 调用序列中有用的文件访问模式的恶意软件分类的多任务学习模型（[`www.covert.io/research-papers/deep-learning-security/A%20Multi-task%20Learning%20Model%20for%20Malware%20Classification%20with%20Useful%20File%20Access%20Pattern%20from%20API%20Call%20Sequence.pdf`](http://www.covert.io/research-papers/deep-learning-security/A%20Multi-task%20Learning%20Model%20for%20Malware%20Classification%20with%20Useful%20File%20Access%20Pattern%20from%20API%20Call%20Sequence.pdf) )

+   将受限玻尔兹曼机和单侧感知器结合用于恶意软件检测（[`www.covert.io/research-papers/deep-learning-security/Combining%20Restricted%20Boltzmann%20Machine%20and%20One%20Side%20Perceptron%20for%20Malware%20Detection.pdf`](http://www.covert.io/research-papers/deep-learning-security/Combining%20Restricted%20Boltzmann%20Machine%20and%20One%20Side%20Perceptron%20for%20Malware%20Detection.pdf)）

+   用于恶意软件分类的卷积神经网络-论文（[`www.covert.io/research-papers/deep-learning-security/Convolutional%20Neural%20Networks%20for%20Malware%20Classification.pdf`](http://www.covert.io/research-papers/deep-learning-security/Convolutional%20Neural%20Networks%20for%20Malware%20Classification.pdf)）

+   用于恶意软件系统调用序列分类的深度学习（[`www.covert.io/research-papers/deep-learning-security/Deep%20Learning%20for%20Classification%20of%20Malware%20System%20Call%20Sequences.pdf`](http://www.covert.io/research-papers/deep-learning-security/Deep%20Learning%20for%20Classification%20of%20Malware%20System%20Call%20Sequences.pdf)）

+   基于二维二进制程序特征的深度神经网络恶意软件检测（[`www.covert.io/research-papers/deep-learning-security/Deep%20Neural%20Network%20Based%20Malware%20Detection%20Using%20Two%20Dimensional%20Binary%20Program%20Features.pdf`](http://www.covert.io/research-papers/deep-learning-security/Deep%20Neural%20Network%20Based%20Malware%20Detection%20Using%20Two%20Dimensional%20Binary%20Program%20Features.pdf)）

+   DL4MD：智能恶意软件检测的深度学习框架（[`www.covert.io/research-papers/deep-learning-security/DL4MD-%20A%20Deep%20Learning%20Framework%20for%20Intelligent%20Malware%20Detection.pdf`](http://www.covert.io/research-papers/deep-learning-security/DL4MD-%20A%20Deep%20Learning%20Framework%20for%20Intelligent%20Malware%20Detection.pdf)）

+   Droid-Sec：Android 恶意软件检测中的深度学习（[`www.covert.io/research-papers/deep-learning-security/DroidSec%20-%20Deep%20Learning%20in%20Android%20Malware%20Detection.pdf`](http://www.covert.io/research-papers/deep-learning-security/DroidSec%20-%20Deep%20Learning%20in%20Android%20Malware%20Detection.pdf)）

+   HADM：混合分析用于恶意软件检测（[`www.covert.io/research-papers/deep-learning-security/HADM-%20Hybrid%20Analysis%20for%20Detection%20of%20Malware.pdf`](http://www.covert.io/research-papers/deep-learning-security/HADM-%20Hybrid%20Analysis%20for%20Detection%20of%20Malware.pdf)）

+   使用循环网络进行恶意软件分类（[`www.covert.io/research-papers/deep-learning-security/Malware%20Classification%20with%20Recurrent%20Networks.pdf`](http://www.covert.io/research-papers/deep-learning-security/Malware%20Classification%20with%20Recurrent%20Networks.pdf)）
