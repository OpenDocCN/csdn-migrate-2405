# 精通安卓游戏开发（三）

> 原文：[`zh.annas-archive.org/md5/021B82B2841EB90A5AA147BA73C3393A`](https://zh.annas-archive.org/md5/021B82B2841EB90A5AA147BA73C3393A)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 第九章：推送通知和分析

我们将从讨论推送通知开始本章。你将学习如何使用谷歌云消息传递（Google Cloud Messaging）实现带有通知的自定义解决方案，包括服务器端和应用程序端。然后，我们将在示例中添加使用 Parse 的通知。为了完成通知部分，我们将使用`NotificationCompat`显示我们的自定义通知。

在本章的下半部分，我们将讨论分析。拥有分析功能来追踪用户在我们应用中的行为是了解用户如何行为的关键，这使我们能够识别模式并改善体验。我们将使用 Parse 实现一个示例，并概述市场上最受欢迎的解决方案。

+   推送通知

    +   使用 GCM 发送和接收

    +   来自 Parse 的通知

    +   NotificationCompat

+   分析

    +   使用 Parse 的分析

+   错误报告

# 推送通知

推送通知对于吸引用户和提供实时更新非常重要。它们有助于提醒用户有待执行的操作。例如，在万事达卡（MasterCard）创建的**Qkr!**应用中，用户可以在一些餐厅订餐订饮料，如果用户在相当长一段时间后仍未付款，他们会发送一个通知提醒用户在离开餐厅前需要付款。

当我们需要告诉用户我们有新内容或者其他用户给他们发送了消息时，它们也非常有效。服务器端发生的任何需要通知用户的变化都是使用通知的完美场景。

通知也可以从我们自己的应用程序本地发送；例如，我们可以设置一个闹钟并显示通知。它们不一定非要从服务器发送。

它们显示在屏幕顶部的状态栏中，在一个称为通知区域的地方。

![推送通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_01.jpg)

通知所需的最少信息包括一个图标、一个标题和详细文本。随着材料设计的到来，我们可以以不同方式自定义通知；例如，我们可以为它们添加不同的操作：

![推送通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_02.jpg)

如果我们从屏幕顶部向下滚动，将会显示通知抽屉，我们可以在其中看到所有由通知显示的信息：

![推送通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_03.jpg)

通知不应作为双向通道通信的一部分。如果我们的应用程序需要与服务器持续通信，例如在即时通讯应用中，我们应该考虑使用套接字、XMPP 或其他任何消息传递协议。理论上，通知是不可靠的，我们无法控制它们将在何时确切收到。

然而，不要滥用通知；它们是用户卸载你应用的一个很好的理由。尽量将通知降至最少，只在必要时使用。

你可以为通知分配一个优先级，从 Android Lollipop 开始，你可以根据这个优先级过滤你想接收的通知。

这些是你处理通知时应该牢记的关键点和概念。在深入了解更多理论知识之前，我们将实践向我们的应用发送通知。

## 使用 GCM 发送和接收通知

市场上存在不同的解决方案来发送推送通知；其中之一是 Parse，它有一个友好的控制面板，任何人都可以轻松地发送推送通知。我们将以 Parse 为例，但首先，了解其内部工作原理以及我们如何构建自己的通知发送系统是有好处的。

**GCM**（**谷歌云消息服务**）使用推送通知，我们将这些通知发送到我们的移动设备。谷歌有名为 GCM 连接服务器的服务器来处理这个过程。如果我们想要发送推送通知，我们首先需要告诉这些服务器，然后它们会在稍后发送到我们的设备。我们需要创建一个服务器或使用第三方服务器，通过 HTTP 或 XMPP 与 GCM 服务器通信，因为可以使用这两种协议进行通信。

![使用 GCM 发送和接收通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_04.jpg)

如我们之前所述，我们无法精确控制消息接收的时间，因为我们无法控制 GCM 服务器。它会将消息排队并在设备在线时发送。

要创建我们自己的解决方案，首先需要在谷歌开发者网站上的我们的应用中启用消息传递服务，网址为[`developers.google.com/mobile/add?platform=android`](https://developers.google.com/mobile/add?platform=android)。

![使用 GCM 发送和接收通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_05.jpg)

创建应用后，启用 GCM 消息传递，系统会提供给你一个发送者 ID 和一个服务器 API 密钥。发送者 ID 以前被称为项目编号。

如果我们想要接收 GCM 消息，需要将我们的客户端（也就是我们的移动应用）注册到这个项目中。为此，我们的应用将使用 GCM API 进行注册并获得一个令牌作为确认。完成这一步后，GCM 服务器就会知道你的设备已准备好接收来自这个特定项目/发送者的推送通知。

![使用 GCM 发送和接收通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_06.jpg)

我们需要添加 Play 服务以使用这个 API：

```java
 compile "com.google.android.gms:play-services:7.5.+"
```

注册是通过**实例 ID** API 完成的，调用`instanceID.getToken`时传入`SenderID`作为参数：

```java
InstanceID instanceID = InstanceID.getInstance(this);
String token = instanceID.getToken(getString(R.string.gcm_defaultSenderId),
GoogleCloudMessaging.INSTANCE_ID_SCOPE, null);
```

我们需要异步调用这个方法，并在我们的应用中保持一个布尔变量，以记录我们是否已成功注册。我们的令牌可能会随时间变化，通过`onRefreshToken()`回调我们可以知道何时发生变化。需要将令牌发送到我们的服务器：

```java
@Override
public void onTokenRefresh() {
  //Get new token from Instance ID with the code above
  //Send new token to our Server
}
```

完成这一步后，我们需要创建一个`GCMListener`并向 Android 清单中添加一些权限：

```java
<uses-permission android:name="android.permission.GET_ACCOUNTS" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />

<permission android:name="com.example.gcm.permission.C2D_MESSAGE"
  android:protectionLevel="signature" />
<uses-permission android:name="com.example.gcm.permission.C2D_MESSAGE" />

<application ...>
  <receiver
    android:name="com.google.android.gms.gcm.GcmReceiver"
    android:exported="true"
    android:permission="com.google.android.c2dm.permission.SEND" >
    <intent-filter>
      <action android:name="com.google.android.c2dm.intent.RECEIVE" />
      <category android:name="com.example.gcm" />
    </intent-filter>
  </receiver>
  <service
    android:name="com.example.MyGcmListenerService"
    android:exported="false" >
    <intent-filter>
      <action android:name="com.google.android.c2dm.intent.RECEIVE" />
    </intent-filter>
  </service>
  <service
    android:name="com.example.MyInstanceIDListenerService"
    android:exported="false">
    <intent-filter>
      <action android:name="com.google.android.gms.iid.InstanceID"/>
    </intent-filter>
  </service>
</application>

</manifest>
```

`GCMListener`将包含`onMessageReceived`方法，当我们接收到任何消息时会被调用。

这就是我们需要的客户端方面的全部内容；至于服务器端，由于它完全取决于所选的技术和语言，本书将不详细介绍。网上有很多用于发送通知的 Python、Grails、Java 等代码片段和脚本，很容易找到。

我们实际上并不需要一个服务器来发送通知，因为我们可以直接与 GCM 通信。我们需要做的就是向[`gcm-http.googleapis.com/gcm/send`](https://gcm-http.googleapis.com/gcm/send)发送一个`POST`请求。这可以通过任何在线的`POST`发送服务轻松完成，比如[hurl.it](http://hurl.it)或 Postman——一个用于发送网络请求的 Google Chrome 扩展程序。我们的请求需要如下所示：

```java
Content-Type:application/json
Authorization:key="SERVER_API_LEY"
{
  "to" : "RECEIVER_TOKEN"
  "data" : {
    "text":"Testing GCM"
  },
}
```

![使用 GCM 发送和接收通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_07.jpg)

继续使用`MasteringAndroidApp`，我们将通过 Parse 实现推送通知。

## 使用 Parse 的推送通知

对于我们的示例，我们将坚持使用 Parse。主要原因是，我们不需要担心服务器端，也不需要使用这个解决方案在 Google 开发者控制台创建应用程序。另一个原因是它有一个很好的内置控制面板来发送通知，如果我们提前跟踪了不同参数的用户，我们还可以针对不同的用户。

![使用 Parse 的推送通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_08.jpg)

使用 Parse，我们不需要创建 GCM 监听器。相反，它使用 Parse 库中已经包含的服务，我们只需为这项服务注册一个订阅者。我们需要做的就是向我们的应用程序添加权限和接收器，然后就可以开始了：

```java
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="android.permission.VIBRATE" />
<uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED" />
<uses-permission android:name="android.permission.GET_ACCOUNTS" />
<uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
<permission android:protectionLevel="signature" android:name="com.packtub.masteringandroidapp.permission.C2D_MESSAGE" />
<uses-permission android:name="com.packtpub.masteringandroidapp.permission.C2D_MESSAGE" />
```

确保最后两个权限与您的包名相匹配。接收器需要放在`application`标签内：

```java
<service android:name="com.parse.PushService" />
<receiver android:name="com.parse.ParseBroadcastReceiver">
  <intent-filter>
    <action android:name="android.intent.action.BOOT_COMPLETED" />
    <action android:name="android.intent.action.USER_PRESENT" />
  </intent-filter>
</receiver>

<receiver android:name="com.parse.ParsePushBroadcastReceiver"
  android:exported="false">
  <intent-filter>
    <action android:name="com.parse.push.intent.RECEIVE" />
    <action android:name="com.parse.push.intent.DELETE" />
    <action android:name="com.parse.push.intent.OPEN" />
  </intent-filter>
</receiver>

<receiver android:name="com.parse.GcmBroadcastReceiver"
  android:permission="com.google.android.c2dm.permission.SEND">
  <intent-filter>
    <action android:name="com.google.android.c2dm.intent.RECEIVE" />
    <action android:name="com.google.android.c2dm.intent.REGISTRATION" />
    <category android:name="com.packtpub.masteringandroidapp" />
  </intent-filter>
</receiver>

</application>
```

为了监听通知，我们可以在`Application`类的`OnCreate`方法中注册一个订阅者：

```java
ParsePush.subscribeInBackground("", new SaveCallback() {
  @Override
  public void done(com.parse.ParseException e) {
    if (e == null) {
      Log.d("com.parse.push", "successfully subscribed to the broadcast channel.");
    } else {
      Log.e("com.parse.push", "failed to subscribe for push", e);
      }
  }
});
```

现在，一切准备就绪。只需进入 Parse 网页，选择**推送**标签，点击**+ 发送推送**。你可以指定受众，选择立即发送还是延迟发送以及其他参数。它会跟踪已发送的推送，并指明发送给了哪些人。

![使用 Parse 的推送通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_09.jpg)

如果你在**推送发送**列中看到**1**，然后查看设备中的通知，那么一切正常。你设备中的通知应该如下所示：

![使用 Parse 的推送通知](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_10.jpg)

## 使用 NotificationCompat

目前，我们可以看到由 Parse 接收器创建的默认通知。但是，我们可以设置自己的接收器，并通过`NotificationCompat`创建更美观的通知。这个组件在支持 v4 库中引入，可以显示 Android L 和 M 以及之前版本直到 API 4 的最新功能通知。

简而言之，我们需要做的是借助`NotificationCompat.Builder`创建一个通知，并通过`NotificationManager.notify()`将这个通知传递给系统：

```java
public class MyNotificationReceiver  extends BroadcastReceiver {

  @Override
  public void onReceive(Context context, Intent intent) {
    Notification notification = new NotificationCompat.Builder(context)
    .setContentTitle("Title")
    .setContentText("Text")
    .setSmallIcon(R.drawable.ic_launcher)
    .build();
    NotificationManagerCompat.from(context).notify(1231,notification);
  }

}
```

这将显示我们的通知。标题、文本和图标是必填项；如果我们不添加这三个属性，通知将不会显示。要开始使用我们的自定义接收器，我们需要在清单中指定我们想要使用的注册，而不是 Parse 推送接收器：

```java
receiver android:name="com.packtpub.masteringandroidapp.MyNotificationReceiver" android:exported="false">
  <intent-filter>
    <action android:name="com.parse.push.intent.RECEIVE" />
    <action android:name="com.parse.push.intent.DELETE" />
    <action android:name="com.parse.push.intent.OPEN" />
  </intent-filter>
</receiver>
```

我们讨论了如何使用`NotificationCompat`显示自定义通知。通知有自己的设计指南，并且是材料设计的重要组成部分。建议查看这些指南，并在在应用中使用此组件时牢记它们。

### 注意

你可以在[`developer.android.com/design/patterns/notifications.html`](http://developer.android.com/design/patterns/notifications.html)找到指南。

# 分析的重要性

了解用户如何使用你的应用非常重要。分析帮助我们理解哪些屏幕访问量最大，用户在我们的应用中购买哪些产品，以及为什么某些用户在注册过程中退出，同时获取有关性别、位置、年龄等信息。

我们甚至可以追踪用户在我们的应用中遇到的崩溃，以及有关设备型号、Android 版本、崩溃日志等信息。

这些数据帮助我们改善用户体验，例如，如果我们发现用户的行为并不像我们预期的那样。它有助于定义我们的产品；如果我们的应用中有不同的功能，我们可以确定哪个功能使用最多。它帮助我们了解受众，这对市场营销可能有益。通过崩溃报告，更容易保持应用的免费和崩溃。

我们将使用 Parse 作为一个例子来开始追踪一些事件。

## Parse 的统计分析

仅通过我们已经在调用的`Parse.init()`方法，无需添加任何额外代码，在 Parse 控制台的**分析**标签下就能看到一些统计数据。

![Parse 的统计分析](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_11.jpg)

在**受众**部分，我们可以看到每日、每周和每月显示的活跃安装和活跃用户。这有助于我们了解我们有多少用户以及其中有多少是活跃的。如果我们想知道有多少用户卸载了应用，我们可以查看**留存**部分。

我们将追踪一些事件和崩溃信息，以在这两个部分显示信息，但首先，我们将查看**资源管理器**。如果你点击左侧的**资源管理器**按钮，你应该会看到以下选项：

![Parse 的统计分析](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_12.jpg)

这将显示一个表格，我们可以从中看到过滤我们应用数据的各种选项。一旦我们开始追踪事件和动作，这里将会有更多的列，我们将能够创建复杂的查询。

默认情况下，如果我们点击运行查询，我们将看到以下表格图像：

![使用 Parse 的分析](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_13.jpg)

它显示了默认列下可用的所有信息；目前不需要额外的列。我们可以看到所有不同的请求类型以及操作系统、操作系统版本和我们应用程序的版本。

我们可以使用过滤器来产生不同的输出。一些有趣的输出可能是，例如，按应用版本排序和分组，以便了解每个版本有多少人在使用。

如果我们使用相同的 Parse 数据库用于不同的平台，比如 Android 和 iOS，我们可以按平台进行过滤。

下面是一个按操作系统版本过滤的示例，我们可以看到用户当前正在使用的所有 Android 版本：

![使用 Parse 的分析](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_14.jpg)

为了收集更多关于应用程序何时以及被打开频率的数据，我们可以在启动画面或第一个活动的`oncreate`方法中添加以下行。

```java
ParseAnalytics.trackAppOpenedInBackground(getIntent());
```

这是一个我们可以追踪的事件示例，但通常我们提到事件追踪时，是指自定义事件。例如，如果我们想追踪哪个职位招聘信息访问量最高，我们会在`JobOfferDetailActivity`中追踪一个事件，并附上访问文章的标题。我们还可以在点击行打开招聘信息时的`onlick`监听器中追踪此事件。这没有固定的规则；实现方式可能有所不同。但我们需要知道，目标是追踪查看招聘信息时的事件。

在`OfferDetailActivity`的`OnCreate`方法中选择跟踪事件的选项的代码将类似于以下代码：

```java
public class OfferDetailActivity extends AppCompatActivity {

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_offer_detail);

    String job_title = getIntent().getStringExtra("job_title");

    Map<String, String> eventParams = new HashMap<>();
    eventParams.put("job_title", job_title);
    ParseAnalytics.trackEventInBackground("job_visited", eventParams);
```

`trackEventInBackground`方法会启动一个后台线程来为我们创建网络上传请求。参数作为具有最多八个的`Map`字符串发送。

如果我们在不同时间访问不同的招聘信息，然后进入分析浏览器部分，我们可以轻松创建一个查询来查看每个职位招聘信息被打开的次数。

![使用 Parse 的分析](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_15.jpg)

通过将数据按维度分组，这些维度包括与事件追踪一起发送的不同参数，并使用计数的聚合，我们可以得到每个访问过的职位招聘信息的计数。

接下来，我们将看看如何利用这种事件追踪来使用 Parse 作为错误报告工具。

## 错误报告

当我们的应用程序被分发时，报告崩溃对于保持应用程序无错误和崩溃至关重要。市场上有成百上千的 Android 设备，以及即使是最好的质量保证人员或测试员在发布应用程序时也可能失误的不同情况，最终导致应用程序崩溃。

我们需要假设我们的应用程序可能会崩溃。我们必须尽可能编写最好的代码，但如果发生崩溃，我们需要有工具来报告并修复它。

Parse 允许我们使用以下代码跟踪错误：

```java
Map<String, String> dimensions = new HashMap<String, String>(); dimensions.put('code', Integer.toString(error.getCode())); ParseAnalytics.trackEvent('error', dimensions);
```

然而，这种解决方案只允许我们跟踪受控代码段的错误。例如，假设我们有一个网络请求，它返回了一个错误。这种情形可以轻松处理；我们只需追踪来自服务器的错误响应事件。

当我们的应用程序中出现 `NullPointerException` 时，就会有一个问题，这就是因为发生了我们无法在代码中检测到的意外情况而导致崩溃。例如，如果工作的图片链接为空，而我尝试读取链接而不检查属性是否为空，我将得到 `NullPointerException`，应用程序将崩溃。

如果我们不能控制发生错误的代码部分，我们如何跟踪这个问题呢？幸运的是，市场上有些工具可以为我们完成这项工作。HockeyApp 是一个帮助分发测试版本并收集实时崩溃报告的工具。这是一个在网页面板上显示我们应用程序错误报告的工具。集成非常简单；我们只需添加以下内容到库中：

```java
compile 'net.hockeyapp.android:HockeySDK:3.5.0-b.4'
```

然后，我们需要调用以下方法来报告错误：

```java
CrashManager.register(this, APP_ID);
```

当你将 APK 上传到 HockeyApp 或者在 Hockey 网站上手动创建一个新应用程序时，你将找到 `APP_ID`。

![错误报告](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_16.jpg)

一旦我们知道 `App_ID` 并注册了崩溃报告，如果我们遇到崩溃，我们将看到一个带有发生次数的列表，如下面的屏幕截图所示：

![错误报告](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_09_17.jpg)

在分析方面，我们最后要说的是，Parse 只是一个选择之一；通常还会使用 Google Analytics，它包含在 Google Play 服务库中。Google Analytics 允许我们创建更复杂的报告，例如漏斗跟踪，以查看在漫长的注册过程中我们失去了多少用户，我们还可以在不同的图表和直方图中查看数据。

如果你属于一个大机构，可以看看 Adobe Omniture。这是一个企业工具，可以帮助你跟踪不同的事件作为变量，然后创建公式来显示这些变量。它还允许你将移动分析数据与其他部门（如销售、市场营销和客户服务）的数据结合起来。根据我的个人经验，我看到使用 Omniture 的公司通常会有专人全职从事分析研究。在这种情况下，开发者需要知道的只是如何实现 SDK 和跟踪事件；创建复杂报告不是开发者的任务。

# 总结

在本章中，你学习了如何为我们的应用程序添加通知。我们使用 Parse 实现了推送通知，并讨论了如何使用 Google Cloud Messaging 创建我们自己的自定义通知服务，包括客户端所需的所有代码和测试服务器端的工具。在章节的后半部分，我们介绍了分析，解释了它们的重要性，并用 Parse 跟踪事件。在分析领域，一个重要的方面是错误报告。我们还使用 Parse 和 HockeyApp 跟踪了应用程序中的错误。最后，我们概览了其他分析解决方案，例如 Google Analytics 和 Adobe Omniture。

在下一章中，我们将使用位置服务，并学习如何将`MapView`添加到我们的示例中，显示带有位置标记的谷歌地图。


# 第十章：位置服务

在本章中，我们将学习如何使用 Google 的 Map Fragment 向我们的应用程序添加地图视图。我们将在地图上添加标记，用于指出感兴趣的位置。

为了实现这一点，我们还将讨论如何在 Google 开发者控制台创建项目，并设置我们的应用程序以使用 Google Play 服务 SDK，这是在任何 Android 应用程序中使用 Google 服务的必要条件。

Parse 中的每个工作机会都有一个位置字段；基于此，我们将在地图上显示标记。

+   配置项目

    +   获取 Google Maps API 密钥

    +   配置`AndroidManifest.xml`

+   添加地图

    +   为 ViewPager 创建片段

    +   实现地图片段

+   添加标记

    +   从 Parse 检索数据

    +   为每个位置显示标记

+   添加标题

# 配置项目

为了让我们使用 Google Play 服务 API，我们需要使用 Google Play 服务 SDK 设置我们的项目。如果你还没有安装，请前往 Android SDK 管理器并获取 Google Play 服务 SDK。

既然我们的应用使用了 Google Play 服务，为了测试应用，你必须确保在以下设备之一上运行应用：

1.  配备有 Android 2.3 或更高版本且安装有 Google Play 商店的 Android 设备（推荐）。

1.  已设置 Google Play 服务的模拟器。如果你使用的是 Genymotion，则默认不会安装**Google Play 服务**：![配置项目](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_10_01.jpg)

我们需要让 Google Play 服务 API 对应用可用。

打开应用的`build.gradle`文件，并在 dependencies 下添加`play-services`库。添加到`build.gradle`文件的行应该类似于这样：

```java
compile 'com.google.android.gms:play-services:7.8.0'
```

确保将此更新为`play-services`的最新版本，并在发布新版本时进行更新。

保存文件，并点击**与 Gradle 文件同步项目**。

## 获取 API 密钥

为了使用 Google Maps API，我们需要在 Google 开发者控制台注册我们的项目并获得一个 API 密钥，然后将其添加到我们的应用中。

首先，我们需要获取我们唯一应用程序的 SHA-1 指纹。我们可以从**调试证书**或**发布证书**中获得此信息。

+   **调试** **证书**在执行调试构建时会自动创建。此证书只能用于当前正在测试的应用。不要使用调试证书发布应用。

+   **发布** **证书**在执行发布构建时创建。也可以使用**keytool**程序创建证书。当应用准备发布到 Play 商店时，必须使用此证书。

### 显示调试证书指纹

+   找到名为`debug.keystore`的调试密钥库文件。此文件通常在与 Android 虚拟设备文件相同的目录中：

    +   **OS X 和 Linux**: `~/.android/`

    +   **Windows Vista 和 Windows 7**: `C:\Users\your_user_name\.android\`

+   要显示 SHA-1 指纹，请打开终端或命令提示符窗口，并输入以下内容：

    +   **OS X 和 Linux**：我们使用 `keytool -list -v -keystore ~/.android/debug.keystore -alias androiddebugkey -storepass android -keypass android` 命令。

    +   **Windows Vista 和 Windows 7**：我们使用 `keytool -list -v -keystore "%USERPROFILE%\.android\debug.keystore" -alias androiddebugkey -storepass android -keypass android` 命令。

输入命令并按下 *Enter* 键后，您将看到类似这样的输出：

```java
Alias name: androiddebugkey
Creation date: Dec 16, 2014
Entry type: PrivateKeyEntry
Certificate chain length: 1
Certificate[1]:
Owner: CN=Android Debug, O=Android, C=US
Issuer: CN=Android Debug, O=Android, C=US
Serial number: 32f30c87
Valid from: Tue Dec 16 11:35:40 CAT 2014 until: Thu Dec 08 11:35:40 CAT 2044
Certificate fingerprints:
         MD5:  7E:06:3D:45:D7:1D:48:FE:96:88:18:20:0F:09:B8:2A
         SHA1: BD:24:B2:7C:DA:67:E5:80:78:1D:75:8C:C6:66:B3:D0:63:3E:EE:84
         SHA256: E4:8C:BD:4A:24:CD:55:5C:0E:7A:1E:B7:FC:A3:9E:60:28:FB:F7:20:C6:C0:E9:1A:C8:13:29:A6:F2:10:42:DB
         Signature algorithm name: SHA256withRSA
         Version: 3
```

### 创建 Google 开发者控制台项目

前往 [`console.developers.google.com/project`](https://console.developers.google.com/project) 并创建一个账户，如果您还没有这么做的话。首先，创建一个以您希望的名字命名的新项目。项目创建后，执行以下步骤：

1.  在左侧边栏中，点击 **APIs & auth**，然后选择 **APIs** 选项：![创建 Google 开发者控制台项目](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_10_02.jpg)

1.  选择 **Google Maps Android API** 并启用它。

1.  打开 **凭据**，然后点击 **[创建新密钥]**。

1.  选择 **Android 密钥**，并输入您的 **SHA-1** 指纹，然后是您的项目包名，两者之间用分号隔开，如下所示：

    ```java
    BD:24:B2:7C:DA:67:E5:80:78:1D:75:8C:C6:66:B3:D0:63:3E:EE:84;com.packtpub.masteringandroidapp
    ```

1.  完成这些操作后，您将能够像以下截图一样查看凭据：![创建 Google 开发者控制台项目](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_10_03.jpg)

## 配置 AndroidManifest.xml

既然我们已经为 Android 应用获取了 API 密钥，我们需要将其添加到 `AndroidManifest.xml` 文件中。

打开您的 `AndroidManifest.xml` 文件，并在 `<application>` 元素下添加以下代码作为子元素：

```java
<meta-data
  android:name="com.google.android.geo.API_KEY"
  android:value="API_KEY"/>
```

将 `value` 属性中的 `API_KEY` 替换为 Google 开发者控制台给出的 API 密钥。

我们还需要将其他几个设置添加到 `AndroidManifest` 中。按如下方式设置 Google Play 服务版本：

```java
<meta-data
  android:name="com.google.android.gms.version"
  android:value="@integer/google_play_services_version" />
```

按如下方式设置必要的权限：

+   `INTERNET`：此权限用于从 Google Maps 服务器下载地图数据。

+   `ACCESS_NETWORK_STATE`：这将允许 API 检查连接状态，以确定是否能够下载数据。

+   `WRITE_EXTERNAL_STORAGE`：这将允许 API 缓存地图数据。

+   `ACCESS_COARSE_LOCATION`：这允许 API 使用 Wi-Fi 或移动数据获取设备的位置。

+   `ACCESS_FINE_LOCATION`：这将比 `ACCESS_COARSE_LOCATION` 提供更精确的位置，并且还将使用 GPS 以及 Wi-Fi 或移动数据。请查看以下代码：

    ```java
    <uses-permission android:name="android.permission.INTERNET"/>
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
    ```

您还需要设置您的 OpenGL ES。Maps API 使用 OpenGL ES 来渲染地图，因此需要安装它才能显示地图。为了通知其他服务这一需求，并防止不支持 OpenGL 的设备在 Google Play 商店显示您的应用，请在 `AndroidManifest.xml` 文件的 `<manifest>` 下添加以下内容作为子元素：

```java
<uses-feature
  android:glEsVersion="0x00020000"
  android:required="true"/>
```

您当前的 `AndroidManifest.xml` 文件应与以下代码类似：

```java
<?xml version="1.0" encoding="UTF-8"?>
<manifest  package="com.packtpub.masteringandroidapp">
  <uses-feature android:glEsVersion="0x00020000" android:required="true" />
  <uses-permission android:name="android.permission.INTERNET" />
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
  <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
  <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
  <application android:name=".MAApplication" android:allowBackup="true" android:icon="@drawable/ic_launcher" android:label="@string/app_name" android:theme="@style/AppTheme">
    <activity android:name=".SplashActivity" android:label="@string/app_name">
      <intent-filter>
        <action android:name="android.intent.action.MAIN" />
        <category android:name="android.intent.category.LAUNCHER" />
      </intent-filter>
    </activity>
    <activity android:name=".MainActivity" android:label="@string/title_activity_main" />
    <activity android:name=".OfferDetailActivity" android:label="@string/title_activity_offer_detail" />
    <provider android:name=".MAAProvider" android:authorities="com.packtpub.masteringandroidapp.MAAProvider" />
    <meta-data android:name="com.google.android.geo.API_KEY" android:value="AIzaSyC9o7cLdk_MIX_aQhaOLvoqYywK61bN0PQ" />
    <meta-data android:name="com.google.android.gms.version" android:value="@integer/google_play_services_version" />
  </application>
</manifest>
```

# 添加地图

既然我们的应用程序已配置好使用地图服务，我们可以开始讨论如何在应用程序中添加视觉地图。对于地图，我们将创建另一个 Fragment，它将被加载到`ViewPager`的第二个页面上。

有两种方法可以显示谷歌地图；一个`MapFragment`或一个`MapView`对象都可以表示它。

## 添加 fragment

在我们的`fragments`目录中创建一个新的 Java 类，名为`MyMapFragment`。该类应扩展`Fragment`类型。然后，重写`OnCreateView`方法，并让它返回`fragment_my_map`的膨胀视图：

```java
package com.packtpub.masteringandroidapp.fragments;

import …

/**
* Created by Unathi on 7/29/2015.
*/
public class MyMapFragment extends Fragment {

  @Nullable
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_my_map, container, false);

    return view;
  }
}
```

接下来，创建 fragment 的布局文件，并将其命名为`fragment_my_map`。将布局的根元素设置为`FrameLayout`。我们暂时将`TextView`添加到我们的布局中，只是为了验证它是否有效。`fragment_my_map.xml`文件的代码应类似于以下内容：

```java
<?xml version="1.0" encoding="UTF-8"?>
<FrameLayout  android:layout_width="match_parent" android:layout_height="match_parent">
  <TextView android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="This is a TextView" android:layout_gravity="center" android:textSize="25dp" />
</FrameLayout>
```

将我们的 fragment 添加到应用程序的最后一步将是编辑`MyPagerAdapter.java`文件，使其作为第二个页面显示。为此，将`getItem`方法的第二个 case 更改为返回`MyMapFragment`的实例，并将`getPageTitle`方法的第二个 case 中的页面标题更改为返回`MAP`：

```java
@Override
public Fragment getItem(int i) {
  switch (i) {
    case 0 :
    return new ListFragment();
    case 1 :
    return new MyMapFragment();
    case 2 :
    return new SettingsFragment();
    default:
    return null;
  }
}

@Override
public CharSequence getPageTitle(int position) {
  switch (position) {
    case 0 :
    return "LIST";
    case 1 :
    return "MAP";
    case 2 :
    return "SETTINGS";
    default:
    return null;
  }
}
```

现在，当您运行应用程序时，`ViewPager`的第二个页面应该被我们新的 fragment 替换。

![添加 fragment](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_10_04.jpg)

## 实现 MapFragment

我们现在将使用`MapFragment`在我们的应用程序上显示地图。我们可以通过添加一个带有`android:name`为`com.google.android.gms.maps.MapFragment`的`<fragment>`布局来实现。这样做将自动将`MapFragment`添加到`activity`：

以下是`fragment_my_map.xml`的代码：

```java
<?xml version="1.0" encoding="UTF-8"?>
<FrameLayout  android:layout_width="match_parent" android:layout_height="match_parent">
  <fragment android:name="com.google.android.gms.maps.MapFragment" android:id="@+id/map" android:layout_width="match_parent" android:layout_height="match_parent" />
</FrameLayout>
```

接下来，为了能够处理我们添加到布局中的`MapFragment`，我们需要使用`FragmentManager`，我们从`getChildFragmentManager`获取它，通过`findFragmentById`。这将在`OnCreateView`方法中完成：

```java
FragmentManager fm = getChildFragmentManager();
mapFragment = (SupportMapFragment) fm.findFragmentById(R.id.map);
if (mapFragment == null) {
  mapFragment = SupportMapFragment.newInstance();
  fm.beginTransaction().add(R.id.map, mapFragment).commit();
}
```

我们将把我们的 fragment 分配给`SupportMapFragment`，而不是仅仅`MapFragment`，这样应用程序就可以支持低于**12**的 Android API 级别。使用以下代码：

以下是`MyMapFragment.java`的代码：

```java
public class MyMapFragment extends Fragment{

  private SupportMapFragment mapFragment;

  @Nullable
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_my_map, container, false);

    FragmentManager fm = getChildFragmentManager();
    mapFragment = (SupportMapFragment) fm.findFragmentById(R.id.map);
    if (mapFragment == null) {
      mapFragment = SupportMapFragment.newInstance();
      fm.beginTransaction().add(R.id.map, mapFragment).commit();
    }

    return view;
  }

}
```

现在，当我们运行应用程序时，地图将在屏幕上显示。

![实现 MapFragment](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_10_05.jpg)

# 添加标记

谷歌地图现在可见，但它还没有为用户显示任何有用的数据。为了实现这一点，我们将添加**地图标记**来指示用户感兴趣的点。这些将是不同工作机会的位置，我们将从 Parse 数据库中下载。

我们还将学习如何将用于在地图上标记点的图标更改为自定义图像，并在标记上加上标题。这将使我们的应用程序看起来更有趣、更具有信息性。

## 从 Parse 获取数据

在我们能够显示所有标记之前，需要从 Parse 下载所有必要的数据。

在 `MyMapFragment.java` 中，我们将使用 `ParseQuery` 获取位置列表，并在显示每个职位之前获取相关信息。执行以下步骤：

+   创建一个名为 `googleMap` 的 `GoogleMap` 类型的私有成员变量，并覆盖 `onResume()` 方法。

+   在 `onResume()` 中，检查 `googleMap` 是否为空；如果是，这意味着我们还没有向当前地图实例添加标记。如果 `googleMap` 为空，从我们已创建的 `MapFragment` 分配地图。这是使用 `getMap()` 实现的：

    ```java
    if (googleMap == null) {

      googleMap = MapFragment.getMap();

    }
    ```

+   创建一个 `ParseQuery`，它将检索我们 Parse 数据库中 `JobOffer` 表的所有数据。使用 `findInBackground()` 函数和 `FindCallback`，这样我们就可以在数据全部下载完成后开始处理数据。使用以下代码：

    ```java
    ParseQuery<JobOffer> query = ParseQuery.getQuery("JobOffer");
    query.findInBackground(new FindCallback<JobOffer>() {
      @Override
      public void done(List<JobOffer> list, ParseException e) {

      }
    });
    ```

## 为每个位置显示一个标记

现在，我们将遍历从 Parse 收到的职位列表，并使用 `addMarker()` 向 `googleMap` 添加标记。执行以下步骤：

1.  当 `findInBackground` 执行完毕后，创建一个 `ParseGeoPoint` 变量和一个循环，该循环将遍历列表中的每个项目。我们将使用 `ParseGeoPoint` 变量来存储来自 Parse 数据库的坐标：

    ```java
    ParseGeoPoint geoPoint = new ParseGeoPoint();

    for(int i =0;i<list.size();i++){

    }
    ```

1.  在循环内，从列表中获取 `GeoPoint` 数据并保存到我们的 `ParseGeoPoint` 变量中：

    ```java
     geoPoint = list.get(i).getParseGeoPoint("coordinates");
    ```

1.  最后，在每次迭代中使用 `addMarker()` 向 `googleMap` 添加标记：

    ```java
    googleMap.addMarker(new MarkerOptions()
    .position(new LatLng(geoPoint.getLatitude(), geoPoint.getLongitude())));
    ```

你的 `MyMapFragment.java` 文件应该与以下内容类似：

```java
public class MyMapFragment extends Fragment{

  private SupportMapFragment mapFragment;
  private GoogleMap googleMap;

  @Nullable
  @Override
  public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
    View view = inflater.inflate(R.layout.fragment_my_map, container, false);

    FragmentManager fm = getChildFragmentManager();
    mapFragment = (SupportMapFragment) fm.findFragmentById(R.id.map);
    if (mapFragment == null) {
      mapFragment = SupportMapFragment.newInstance();
      fm.beginTransaction().add(R.id.map, mapFragment).commit();
    }

    return view;
  }

  @Override
  public void onResume() {
    super.onResume();

    if (googleMap == null) {
      googleMap = mapFragment.getMap();

      ParseQuery<JobOffer> query = ParseQuery.getQuery("JobOffer");
      query.findInBackground(new FindCallback<JobOffer>() {
        @Override
        public void done(List<JobOffer> list, ParseException e) {

          ParseGeoPoint geoPoint;

          for(int i =0;i<list.size();i++){
            geoPoint = list.get(i).getParseGeoPoint("coordinates");

            googleMap.addMarker(new MarkerOptions()
            .position(new LatLng(geoPoint.getLatitude(), geoPoint.getLongitude())));
          }

        }
      });

    }
  }
}
```

这些标记现在应该在应用中可见：

![为每个位置显示标记](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_10_06.jpg)

## 向标记添加标题

地图上标记的实用性不仅仅在于显示一个点，还在于为用户提供一种简单且易于访问的方式来获取此位置的信息。当用户点击标记时，我们将通过显示标题来实现这一点。

这可以通过简单地在我们的 `addMarker()` 方法中添加 `.title(string)` 来实现：

```java
googleMap.addMarker(new MarkerOptions()
.position(new LatLng(geoPoint.getLatitude(), geoPoint.getLongitude()))
.title(list.get(i).getTitle()));
```

现在我们有一个完全功能的地图显示，当用户点击它时，会在标记上方显示标题，如下面的图片所示：

![为标记添加标题](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/4887_10_07.jpg)

# 概述

在本章中，你学习了如何向我们的应用添加地图。这需要我们在 Google Developer Console 上创建一个项目，并配置我们的应用以访问必要的 API。一旦我们的应用完全配置好，我们就继续将地图添加到我们选择的视图中。我们讨论了在片段中处理一个片段（`MapFragment` 与我们的 `MyMapFragment`）。尽管单个 `MapFragment` 可以通过代码单独添加，但将其放在带有布局的另一个片段中，如果我们需要，可以让我们有可能向页面添加其他 UI 小部件，例如 `FloatingActionButton`。最后，我们通过显示从 Parse 下载的位置的标记和信息，使地图变得有用。

在下一章中，你将学习如何调试和测试我们的应用程序。


# 第十一章：在 Android 上进行调试和测试

在本章中，你将学习如何在 Android 中进行调试，这是在开发应用程序时查找和解决问题的必备实践，可以节省大量时间。

我们将学习如何创建自动化测试，用以测试按钮的点击或单个方法的结果。这是一组你可以在 Android Studio 中运行的测试，以确保每次开发新功能时，不会破坏现有的功能。

你还将学习如何使用**Robolectric**进行单元测试以及使用 Espresso 进行集成测试。

在本章末尾，我们将讨论如何使用 Monkey 对 UI 进行数百万次随机点击测试，如何通过应用记录点击序列，以及如何使用 MonkeyTalk 基于这些记录配置测试。

+   日志与调试模式

+   测试

    +   使用 Robolectric 进行单元测试

    +   使用 Espresso 进行集成测试

+   UI 测试

    +   使用 MonkeyRunner 进行随机点击

    +   使用 MonkeyTalk 记录点击

+   持续集成

# 日志与调试模式

如果不提及日志以及如何在开发过程中解决问题，这本书就不算完整。如果你知道如何解决自己的问题，那么在 Android 上的开发就不仅仅是复制粘贴 Stack Overflow 的内容。

调试模式和日志是帮助开发者定位问题的机制。随着时间的推移，每个开发者都会进步并减少使用这些技术的频率，但在开始时，应用中充满了日志是很常见的。我们不希望用户在应用发布后能够看到日志，也不希望手动移除日志并在发布新版本时再次添加。我们将探讨如何避免这种情况。

## 处理日志

`Log`类用于打印消息和错误，我们可以通过`LogCat`实时读取。以下是记录消息的一个例子：

```java
Log.i("MyActivity", "Example of an info log");
```

`Log`类有五种方法，它们用于对日志设置不同的优先级。这允许我们在`LogCat`中按优先级进行筛选。在某些情况下，我们会显示不同的日志，例如，查看每次请求下载的工作机会数量。如果我们的应用崩溃了，此时错误类型的日志是我们的优先关注点，我们希望隐藏其他优先级较低的日志，以便尽快找到错误。

五个优先级分别是（从低到高）：详细、调试、信息、警告和错误（`Log.v`，`Log.d`，`Log.i`，`Log.w`和`Log.e`）。

我们可以通过日志窗口顶部的条形栏按进程进行筛选。我们可以按优先级和关键词进行筛选，并且可以创建自定义过滤器，按标签、进程 ID 等进行筛选。

![处理日志](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_01.jpg)

如果日志不显示或者它们是旧的且不刷新，尝试打开右侧的下拉菜单，选择**无** **过滤**，然后再次选择**仅显示选定应用程序**。这会强制控制台刷新。

![处理日志](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_02.jpg)

为了完成日志，我们将创建一个包装器，并使用第三方库，目的是只需更改一个布尔值，就能在项目中禁用所有日志。为此，我们只需创建一个具有与`Log`类相同方法的类，这些方法依赖于这个布尔值：

```java
public class MyLogger {

  static final boolean LOG = false;

  public static void i(String tag, String string) {
    if (LOG) android.util.Log.i(tag, string);
  }

  public static void e(String tag, String string) {
    if (LOG) android.util.Log.e(tag, string);
  }
  …
```

我们每次想要编写日志时都需要使用这个包装器—使用`MyLogger.d()`而不是`Log.d()`。这样，如果我们更改`MyLogger`类中的布尔值`LOG`，它将同时停止我们项目中的所有日志。

建议使用`BuildConfing.DEBUG`变量的值：

```java
static final boolean LOG = BuildConfing.DEBUG; 
```

如果我们的应用处于调试模式，这将返回 true，发布应用时将返回 false。因此，我们不需要记住在发布模式下关闭日志，也没有日志会显示给最终用户的风险。

### 使用 Timber，日志包装器

Timber 是 Jake Wharton 创建的日志包装器，它将日志提升到了一个高级水平，允许我们使用日志树概念来拥有不同的日志行为。看看以下代码：

```java
compile 'com.jakewharton.timber:timber:3.1.0'
```

使用 Timber 的一个优点是，我们在同一个活动中不需要多次编写日志标签：

```java
Timber.tag("LifeCycles");
Timber.d("Activity Created");
```

我们的日志树可以有不同的行为；例如，我可能想在发布模式下禁用日志，但我仍然想处理错误；所以，我会种植一个错误树，它将向 Parse 报告错误：

```java
if (BuildConfig.DEBUG) {
  Timber.plant(new Timber.DebugTree());
} else {
  Timber.plant(new CrashReportingTree());
}

/** A tree which logs important information for crash reporting. */
private static class CrashReportingTree extends Timber.Tree {
  @Override protected void log(int priority, String tag, String message, Throwable t) {
    if (priority == Log.VERBOSE || priority == Log.DEBUG) {
      return;
    }
    //Track error to parse.com
  }
}
```

## 调试我们的应用

日志可以在开发过程中用于查找问题，但如果我们掌握了调试模式，会发现这个实践要快得多。

当我们处于调试模式时，可以在代码中设置断点。通过这些断点，我们可以指定一个代码行，我们希望执行在这里停止，以显示那一刻变量的值。要设置断点，只需在左侧边栏上双击：

![调试我们的应用](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_03.jpg)

我们在获取职位信息的方法响应中设置了一个调试点。我们可以从顶部栏启动调试模式：

![调试我们的应用](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_04.jpg)

如果我们在**调试**模式下运行应用，当执行到这一点时，Android Studio 将会暂停：

![调试我们的应用](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_05.jpg)

Android Studio 将自动提示**调试器**窗口，我们可以在执行点的位置看到变量。我们可以在前面的截图中看到职位列表，并导航查看每个职位内部的内容。

这里重要的特性是左侧的绿色**播放**按钮，它会继续执行我们的应用到下一个断点，以及红色方块，它会退出调试模式并继续执行应用。

我们还有不同的控制选项可以跳转到下一行，进入一个方法，或者跳出到方法外。例如，假设我们在以下命令的第一行设置了一个断点：

```java
MasteringAndroidDAO.getInstance().clearDB(getActivity());
MasteringAndroidDAO.getInstance().storeOffers(getActivity(), jobOffersList);
```

在此情况下，**单步跳过**（指向下方的蓝色箭头）将把我们的执行移到下一行。如果我们点击**单步进入**（指向右下角的蓝色箭头），我们将进入 `getInstace()` 方法。结合这些控制，我们可以实时控制流程。

解释了调试模式后，我们现在可以继续进行自动化测试。

# 在 Android 上进行测试

任何新功能在完成之前都需要先进行测试。我们作为开发者，曾多次掉入在未先编写通过测试的情况下提交代码更改的陷阱，结果在后续迭代中发现预期的行为被破坏了。

我们通过艰难的方式学到了编写测试可以提升我们的生产力，提高代码质量，并帮助我们更频繁地发布。因此，Android 提供了多种工具，以帮助我们从早期阶段开始测试应用。

在接下来的两个部分，我们将讨论我最喜欢的设置：用 Robolectric 进行单元测试和用 Espresso 进行集成测试。

## 使用 Robolectric 的单元测试

在 Robolectric 出现之前，编写单元测试意味着我们必须在真实设备或模拟器上运行它们。这个过程可能需要几分钟，因为 Android 构建工具需要打包测试代码，将其推送到连接的设备，然后运行它。

Robolectric 通过使我们能够在工作站的 JVM 中运行单元测试，而无需 Android 设备或模拟器，从而减轻了这个问题。

要使用 Gradle 包含 Robolectric，我们可以在 `build.gradle` 文件中添加以下依赖：

```java
testCompile "org.robolectric:robolectric:3.0"
```

我们使用 `testCompile` 来指定我们希望这个依赖被包含在测试项目中。对于测试项目，默认源目录是 `src/test`。

### Robolectric 配置

在撰写本文时，Robolectric 3.0 版本支持以下 Android SDK：

+   Jelly Bean，SDK 版本 16

+   Jelly Bean MR1，SDK 版本 17

+   Jelly Bean MR2，SDK 版本 18

+   KitKat，SDK 版本 19

+   Lollipop，SDK 版本 21

默认情况下，测试将针对 `AndroidManifest` 文件中定义的 `targetSdkVersion` 运行。如果你想针对不同的 SDK 版本运行测试，或者如果你的当前 `targetSdkVersion` 不被 Robolectric 支持，你可以使用位于 `src/test/resources/robolectric.properties` 的属性文件手动覆盖它，内容如下：

```java
robolectric.properties
sdk=<SDK_VERSION>
```

### 我们的第一单元测试

我们将从设置一个非常简单且常见的场景开始：一个带有**登录**按钮的欢迎活动，该按钮将用户导航到登录活动。欢迎活动的布局如下：

```java
<?xml version="1.0" encoding="UTF-8"?>
<LinearLayout  android:layout_width="match_parent" android:layout_height="match_parent">
  <Button android:id="@+id/login" android:text="Login" android:layout_width="wrap_content" android:layout_height="wrap_content" />
</LinearLayout>
```

在 `WelcomeActivity` 类中，我们只需设置登录按钮以启动登录活动：

```java
public class WelcomeActivity extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.welcome_activity);

    View button = findViewById(R.id.login);
    button.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View view) {
        startActivity(new Intent(WelcomeActivity.this, LoginActivity.class));
      }
    });
  }
}
```

为了测试这一点，我们可以确保通过发送正确的 `Intent` 启动 `LoginActivity`。因为 Robolectric 是一个单元测试框架，`LoginActivity` 实际上不会启动，但我们能够检查框架是否捕获了正确的意图。

首先，我们将在`src/test/java/`路径中正确包内创建测试文件`WelcomeActivityTest.java`。Robolectric 依赖于 JUnit 4，因此我们将从指定 Robolectric 的 Gradle 测试运行器开始，并添加一些额外的配置，框架将使用这些配置来查找`AndroidManifest`资源和资产。运行以下命令：

```java
@RunWith(RobolectricGradleTestRunner.class)
@Config(constants = BuildConfig.class)
```

现在，我们可以编写第一个测试。首先创建并将欢迎活动带到前台：

```java
WelcomeActivity activity = Robolectric.setupActivity(WelcomeActivity.class);
```

既然我们已经有了`WelcomeActivity`的实例，点击登录按钮就变得简单了：

```java
activity.findViewById(R.id.login).performClick();
```

最后，我们需要验证框架是否捕获了本应启动`LoginActivity`的意图：

```java
Intent expectedIntent = new Intent(activity, LoginActivity.class);
assertThat(shadowOf(activity).getNextStartedActivity(), is(equalTo(expectedIntent)));
```

`shadowOf`静态方法返回一个`ShadowActivity`对象，该对象存储了与当前待测活动的大部分交互。我们需要使用`@Test`注解，这会告诉 JUnit 该方法可以作为测试用例运行。将所有内容整合在一起，我们得到以下测试类（`WelcomeActivityTest.java`）：

```java
@RunWith(RobolectricGradleTestRunner.class)
@Config(constants = BuildConfig.class)
public class WelcomeActivityTest {

  @Test
  public void loginPress_startsLoginActivity() {
    WelcomeActivity activity = Robolectric.setupActivity(WelcomeActivity.class);

    activity.findViewById(R.id.login).performClick();

    Intent expectedIntent = new Intent(activity, LoginActivity.class);
    assertThat(shadowOf(activity).getNextStartedActivity(), is(equalTo(expectedIntent)));
  }
}
```

### 运行单元测试

在能够运行单元测试之前，我们需要在 Android Studio 中选择正确的**测试构件**。为此，我们将打开**构建变种**工具栏并选择**单元测试**构件，如下截图所示：

![运行单元测试](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_06.jpg)

现在，从**项目**窗口中，我们可以通过右键点击测试类并选择**运行**选项来运行测试。确保项目路径中没有空格；否则，Robolectric 在执行单元测试之前会抛出异常。

![运行单元测试](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_07.jpg)

我们还可以从命令行运行单元测试。为此，使用带有`--continue`选项的`test`任务命令：

```java
./gradlew test --continue
```

如果我们配置了持续集成系统，例如 Jenkins、Travis 或 wercker，这个选项是理想的。

这是 Robolectric 部分的结束。接下来，我们将讨论使用**Espresso**进行集成测试。

## 使用 Espresso 进行集成测试

由于 Android 的固有特性和市面上大量的设备，我们无法确定发布应用时它的表现。

我们倾向于尽可能在多个不同设备上手动测试我们的应用，这是一个繁琐的过程，每次发布时都必须重复。在本节中，我们将简要讨论 Espresso 以及如何编写可以在真实设备上运行的测试。

### Espresso 配置

在编写我们的第一个集成测试之前，需要安装并配置测试环境。执行以下步骤：

1.  从 Android SDK 管理器中，我们需要选择并安装**Extras**文件夹中的**Android Support Repository**，如下截图所示：![Espresso 配置](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_08.jpg)

1.  创建用于集成测试代码的文件夹；该文件夹应位于`app/src/androidTest`。

1.  我们还需要在项目的`build.gradle`中指定一些依赖项。使用以下代码：

    ```java
    dependencies {
      androidTestCompile 'com.android.support.test:runner:0.3'
      androidTestCompile 'com.android.support.test:rules:0.3'
      androidTestCompile 'com.android.support.test.espresso:espresso-core:2.2'
      androidTestCompile 'com.android.support.test.espresso:espresso-intents:2.2'
    }
    ```

最近，Android 添加了对 JUnit 4 风格测试案例的支持。为此，我们将在`build.gradle`文件中将`AndroidJUnitRunner`添加为默认的测试仪器运行程序：

```java
android {
  defaultConfig {
    testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
  }
}
```

### 编写集成测试

对于这个例子，我们将从 Robolectric 停下的地方继续；我们将为`LoginActivity`编写一个测试。对于这个活动，我们将设置一个简单的布局，包含两个`EditTexts`和一个登录按钮。运行以下代码（`activity_login.xml`）：

```java
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout 
  android:orientation="vertical"
  android:layout_width="match_parent"
  android:layout_height="match_parent">

  <EditText
    android:id="@+id/input_username"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:inputType="textEmailAddress" />

  <EditText
    android:id="@+id/input_password"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:inputType="textPassword" />

  <Button
    android:id="@+id/button_signin"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:text="@string/signin"/>
</LinearLayout>
```

在`LoginActivity`中，当用户点击登录按钮时，我们将使用以下代码（`LoginActivity.java`）将凭据发送到闪屏活动：

```java
public class LoginActivity extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.activity_login);

    final EditText inputUsername = (EditText) findViewById(R.id.input_username);
    final EditText inputPassword = (EditText) findViewById(R.id.input_password);

    Button buttonLogin = (Button) findViewById(R.id.button_signin);

    buttonLogin.setOnClickListener(new View.OnClickListener() {
      @Override
      public void onClick(View v) {
        startActivity(new Intent(getApplicationContext(), SplashActivity.class)
        .putExtra("username", inputUsername.getText().toString())
        .putExtra("password", inputPassword.getText().toString()));
        finish();
      }
    });
  }
}
```

对于这个测试，我们将在两个输入字段中输入用户凭据，并验证我们是否在意图中正确地捆绑它们。

首先，我们将在`src/test/androidTest/`路径中正确的包内创建`LoginActivityTest.java`测试文件。我们将使用 JUnit 4，因此我们将从指定`AndroidJUnit4`测试运行器开始。使用以下命令：

```java
@RunWith(AndroidJUnit4.class)
```

与 Robolectric 的另一个区别是，在 Espresso 中，我们需要指定一个规则来准备被测试的活动。为此，使用以下命令：

```java
@Rule
public IntentsTestRule<LoginActivity> mActivityRule =
  new IntentsTestRule<>(LoginActivity.class);
```

现在，我们可以开始编写测试。首先，我们需要在两个输入字段中输入登录详情：

```java
String expectedUsername = "mastering@android.com";
String expectedPassword = "electric_sheep";

onView(withId(R.id.input_username)).perform(typeText(expectedUsername));
onView(withId(R.id.input_password)).perform(typeText(expectedPassword));
```

然后，我们将通过点击登录按钮发送意图：

```java
onView(withId(R.id.button_signin)).perform(click());
```

最后，我们必须验证捕获的意图是否包含登录凭据：

```java
intended(hasExtras(allOf(
  hasEntry(equalTo("username"), equalTo(expectedUsername)),
  hasEntry(equalTo("password"), equalTo(expectedPassword)))));
```

将所有内容整合在一起，我们将得到以下测试类（`LoginActivityTest.java`）：

```java
@RunWith(AndroidJUnit4.class)
public class LoginActivityTest {

  @Rule
  public IntentsTestRule<LoginActivity> mActivityRule =
  new IntentsTestRule<>(LoginActivity.class);

  @Test
  public void loginButtonPressed_sendsLoginCredentials() {
    String expectedUsername = "mastering@android.com";
    String expectedPassword = "electric_sheep";

    onView(withId(R.id.input_username)).perform(typeText(expectedUsername));
    onView(withId(R.id.input_password)).perform(typeText(expectedPassword));

    onView(withId(R.id.button_signin)).perform(click());

    intended(hasExtras(allOf(
    hasEntry(equalTo("username"), equalTo(expectedUsername)),
    hasEntry(equalTo("password"), equalTo(expectedPassword)))));
  }
}
```

### 运行集成测试

与我们使用 Robolectric 所做的类似，要运行集成测试，我们需要在 Android Studio 中切换到正确的**测试工件（Test Artifact）**。为此，我们将打开**构建变体（Build Variants）**工具栏并选择**Android Instrumentation Tests**工件：

![运行集成测试](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_09.jpg)

现在，从**项目**窗口，我们可以通过右键点击测试类并选择**运行**选项来运行测试。

我们还可以从命令行运行集成测试。为此，我们将调用`connectedCheck`（或`cC`）任务：

```java
./gradlew cC
```

如果我们有连接设备或模拟器的持续集成系统，使用命令行是首选方式。一旦我们编写了足够的集成测试，我们可以轻松地在数百个真实设备上部署和运行它们，使用如**Testdroid**之类的服务。

![运行集成测试](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_10.jpg)

# 从 UI 的角度进行测试

我们现在将进行的测试与使用应用程序的人可能会进行的测试类似。实际上，在拥有**质量保证（QA）**的的公司中，人们将这些工具作为手动测试的补充。

UI 测试也可以自动化，但它们与单元测试和集成测试不同；这些是在屏幕上执行的操作，从点击按钮到使用记录的事件完成注册过程。

我们将从使用**猴子（The Monkey）**进行压力测试开始。

## 启动猴子

Monkey 是一个可以从命令行通过 ADB 启动的程序。它可以在我们的设备或模拟器中生成随机事件，并且通过使用一个种子，我们可以重现相同的随机事件。为了解释清楚，让我们考虑一个数字的例子。想象一下，我执行了 Monkey，它产生了 1 到 10 的随机数；如果我再次启动它，我会得到不同的数字。当我用种子（这个种子是一个数字）执行 Monkey 时，我得到了一组不同的从 1 到 10 的数字，如果我用相同的种子再次启动它，我会得到相同的数字。这很有用，因为如果我们使用一个种子来生成随机事件并且出现了崩溃，我们可以修复这个崩溃，并再次运行相同的种子，以确保我们解决了问题。

这些随机事件可以从点击和滚动手势到系统级别的事件（如音量增大、音量减小、截图等）不等。我们可以限制事件的数量和类型以及运行它的包。

终端中的基本语法是以下命令：

```java
$ adb shell monkey [options] <event-count>
```

如果你从未使用过 ADB，你可以在你的系统安装的 Android SDK 目录中的`platform-tools`文件夹里找到它：

```java
../sdk/platform-tools/adb
```

当我们打开终端并导航到这个目录时，我们可以写下以下代码行：

```java
adb shell monkey -p com.packtpub.masteringandroidapp -v 500
```

当你尝试使用`adb`并且输出是`command not found`时，你可以重启`adb`，使用`adb kill-server`、`adb start-server`，以及在 Linux 或 Mac 上使用`./adb`（点斜杠 adb）。

我们可以增加事件的数量到`5000`或者产生无限事件，但通常建议设置一个数字限制；否则，你将不得不重启设备来停止 Monkey。当你执行命令时，你将能够看到产生的随机事件，并且它将指示使用的种子，以防你想重复相同的事件链：

![启动 Monkey](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_11.jpg)

根据应用程序的不同，我们可能需要调整事件之间的时间，使用节流毫秒属性以模拟真实用户。

使用下一个测试工具，我们将进行一种不同类型的 UI 测试，目的是跟随一个流程。例如，如果我们有一个由三个屏幕组成的注册过程，每个屏幕都有不同的表单，并且我们想要记录一个测试，用户填写表单并通过三个屏幕逻辑地继续。在这种情况下，Monkey 实际上并不太有帮助；在大量的事件中，它最终会用随机字符填写所有输入字段，并点击按钮进入下一个屏幕，但这并不是我们真正想要的。

## 使用 MonkeyTalk 记录 UI 测试

记录一系列测试（如注册过程）的目的是为了保存这些测试，以便在我们对代码进行更改后能够再次运行它。我们可能需要修改注册过程的网络请求，而不改变 UI，所以这些测试非常完美。我们可以在完成修改后运行它们，而无需手动完成注册或填写表单。这里我们并不是在偷懒；如果我们有数百个测试，这对于一个人来说将是大量的工作。此外，通过自动化测试，我们可以确保事件序列始终如一。

**MonkeyTalk**是一个免费且开源的工具，有两个版本；在我们的示例中，我们将使用社区版。

### 注意

有关社区版和专业版的比较列表，可以在他们的网站[`www.cloudmonkeymobile.com/monkeytalk`](https://www.cloudmonkeymobile.com/monkeytalk)上查看。

MonkeyTalk 可以在真实设备和模拟器上使用。它通过在*录制模式*下记录一系列事件来工作：

![使用 MonkeyTalk 录制 UI 测试](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_12.jpg)

一旦我们通过点击工具中的**录制**进入录制模式，每个事件都将按执行的操作和使用的参数顺序记录下来。在上面的截图中，我们可以看到点击`TextView`并在上面输入一些内容是如何被记录为两个事件的。

我们可以在一个脚本文件中创建这个，MonkeyTalk 将会复现它；这样，我们就可以在不录制的情况下创建自己的事件序列。对于前面的事件，我们将编写如下脚本：

```java
Input username tap
Input username enterText us
```

如果我们点击**立即播放**按钮，我们将在任何设备上看到所有这些步骤的执行。我们可以在安卓手机上录制脚本，然后在 iOS 设备上播放它们。

除了录制和播放脚本，我们还可以有验证命令。例如，如果我们有一个清除所有输入字段的按钮，我们可以在脚本中使用`currentValue`添加一个验证命令：

```java
Input username tap
Input username enterText us
Input clearform click
Input currentvalue ""
```

这将在执行过程中报告验证的结果，这样我们就能检查我们的所有验证是否都正确通过了。例如，点击清除表单的按钮需要一个点击监听器来清除每个输入文本。如果由于某种原因我们进行了修改，元素的 ID 发生了变化，MonkeyTalk 测试会通过一个失败的命令来报告问题。

如果我们有一个工具，可以在我们每次更改应用时为我们运行这些 UI 测试以及单元测试和集成测试，那不是很好吗？这个解决方案是存在的，它被称为**持续集成**。

# 持续集成

我们无意解释如何构建一个持续集成系统，因为这超出了本书的范围，而且通常设置环境不是安卓开发者的职责。然而，你应该了解它是什么以及它是如何工作的，因为它与安卓直接相关。

一套良好的自动化测试套件总是与 CI（持续集成）解决方案结合使用更为有效。这个解决方案将允许我们在每次代码更改时构建和测试我们的应用程序。

这就是大多数拥有大型项目的公司的工作方式。如果他们有一个开发团队，代码通常会在一个仓库中共享，并且他们会构建一个与仓库相连的 CI 系统。每当开发者对仓库进行更改并提交时，就会执行测试集合，如果结果成功，就会构建一个新的 Android 可执行文件（**APK**）。

这样做是为了尽量减少问题的风险。在一个大型的应用程序中，需要数年时间由不同的人共同开发，对于新开发者来说，在不破坏或更改任何现有功能的情况下开始进行更改是不可能的。这是因为项目中的所有人并不都了解所有代码的用途，或者代码过于复杂，以至于修改一个组件就会影响其他组件。

### 注意

如果你对接入这个解决方案感兴趣，我们可以为你推荐**Jenkins**，它最初被称为 Hudson，更多信息请访问[`wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins`](https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins)。

![持续集成](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_11_13.jpg)

除了测试和构建我们的应用程序之外，Jenkins 还会生成一个测试覆盖率报告，这将使我们能够了解单元测试和集成测试覆盖了我们代码的百分比。

# 概要

在本章中，我们开始学习如何在我们的应用程序中以高级方式使用日志，并快速概览了调试过程。我们解释了什么是测试，以及如何分别使用 Robolectric 和 Espresso 创建单元测试和集成测试。

我们还创建了 UI 测试，从使用 The Monkey 进行压力测试开始，然后生成随机事件，后来开始使用 MonkeyTalk 测试，记录可以再次播放以验证输出的事件流程。最后，我们讨论了持续集成，以了解公司是如何为 Android 应用程序将测试和构建系统集成在一起的。

在下一章，也就是本书的最后一章中，我们将探讨如何对我们的应用程序进行货币化，如何使用不同的构建版本构建应用程序，以及混淆代码，使其准备好上传到 App Store。


# 第十二章：盈利、构建过程和发布

这是本书的最后一章；我们剩下要做的就是使我们的应用盈利，生成其不同版本，并将其发布并上传到 Play 商店。

我们将通过创建不同的构建类型来完成构建过程，生成不带广告的付费版本和带广告的免费版本的应用。所有这些都在同一个项目中，但将作为两个不同的应用导出。

构建过程完成后，我们将开始实施广告并解释关于广告盈利的关键点；这将使我们的应用程序能够产生收入。

最后，我们将发布应用，并使用发布证书对我们的 APK 进行签名，混淆代码以防止被反编译。我们将上传到 Play 商店，并解释在应用发布过程中需要牢记的关键点。

+   构建变体

+   盈利

    +   广告盈利的关键点

    +   添加广告

+   发布

    +   代码混淆和签名

    +   使用 Gradle 导出

+   上传至 Play 商店

# 使用构建变体

为了解释如何在 Android 上通过广告实现盈利，我们将在应用中添加广告，但在这一步之前，我们将设置一个构建过程，允许我们导出两个版本：付费版和免费版。这种策略在 Play 商店中很常见（提供一个带广告的免费版本和一个不带广告的付费版本），这样所有用户都能免费使用该应用，但那些不喜欢广告并希望支持你应用的用户可以选择购买付费版本。

实施此策略的另一种方法是只创建一个版本，并在应用内提供购买附加组件以移除广告的选项，通过应用内购买产品来实现。这种方式的缺点是，你的应用在 Play 商店中不会列为免费应用；它将被归类为“提供应用内购买”，因此可能有些用户对此感到不适应，或者家长不允许孩子使用付费应用或包含支付的应用。第二个问题是应用内购买不容易实现；这个过程非常复杂，涉及很多步骤，包括设置服务、在 Play 商店中创建产品、从应用中消费这些产品，以及设置一个测试环境，我们可以在不产生费用的前提下测试购买。

![使用构建变体](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_01.jpg)

构建变体是构建类型和产品风味的组合。

如果我们有构建类型`A`和`B`，以及产品风味`1`和`2`，那么结果将如下构建变体：

```java
A 1
A 2
B 1
B 2
```

为了更好地理解这一点，我们可以了解构建类型和构建风味的概念以及如何创建它们。

## 创建构建类型

构建类型允许我们为调试或发布目的配置应用的打包。

让我们先看看我们的 `build.gradle` 文件：

```java
buildTypes {
  release {
    minifyEnabled false
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
  }
}
```

在 `build.gradle` 中，我们可以看到构建类型 release 有两个属性，我们将在本章末尾解释它们。

默认情况下，我们有两个构建类型：**debug** 和 **release**。即使我们没有看到 debug 构建类型，所有变体也将在 release 和 debug 模式下生成。

我们可以创建更多具有不同参数的构建类型；我们可以使用的参数包括：

+   签名配置

+   调试签名标志

+   更改版本名称或包名后缀

这意味着我们可以拥有不同类型的签名，使用不同的证书，启用或禁用 debug 模式，以及不同的包名。

构建类型并不是用来创建我们应用程序的不同版本，如演示版或完整版，免费或付费等。为此，我们有产品风味。每个构建类型应用于每个构建风味，创建我们之前看到的构建变体。

## 产品风味

我们将创建两个产品风味，并在 `build.gradle` 中使用以下代码声明它们：

```java
productFlavors {
  paid {
    applicationId "com.packtpub.masteringandroidapp"
  }
  free {
    applicationId "com.packtpub.masteringandroidapp.free"
  }
}
```

我们有一个付费风味，即没有广告的应用，还有一种名为 *free* 的风味，包含广告的免费版本。对于每个产品风味，我们可以在项目的 `../src/` 级别创建一个文件夹。我们的付费版本默认是主要的，所以不需要文件夹。

![产品风味](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_02.jpg)

这样，我们可以为每个构建拥有不同的类和资源，甚至一个不同的 `AndroidManifest.xml` 文件。我们的应用程序将在 `main` 文件夹中共享付费和免费版本的通用代码，在 `free` 文件夹中有针对广告的特定代码。

要在不同版本之间切换，我们可以简单地更改构建变体窗口中的下拉菜单，如下面的截图所示：

![产品风味](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_03.jpg)

选择一个构建变体后，我们可以运行应用或导出它，相应地运行或导出所选的风味。这些可以配置为具有不同的包名和不同的版本名称。

现在，我们将看看如何向免费版本添加一个特定代码，该代码不会包含在主要付费版本中。

# 安卓的货币化

我们将描述通过应用程序赚钱的三种常见方式。

首先，我们可以在 Play Store 中为应用程序设定一个价格。在某些情况下，为你的应用收费比提供带有广告或应用内产品的免费应用更有意义。如果你为一小部分用户创造了高价值的应用，你绝对应该考虑这个选项。例如，如果我们发布一个为建筑师专业设计房屋的应用，我们知道我们的应用不会被数百万用户下载；它是针对特定和目标用户群的高质量软件需求。我们无法通过广告获得足够的利润，而我们的用户将愿意为使他们的工作更轻松的软件支付一笔不错的费用。要求用户预先支付费用总是存在风险的；即使用户可以选择退还应用费用，他/她可能也不够吸引人去尝试。这就是为什么我们应该考虑第二种模式的原因。

第二个选项被称为**免费增值**模式。我们发布一个免费的应用程序，但其中包括应用内购买。以同样的房屋设计应用为例，我们可以提供三种免费设计，以便当用户对我们的产品感到满意时，我们可以要求他/她购买一次性许可或订阅以继续使用该应用。这在游戏中非常常见，你可以为你的角色购买物品。在游戏中，我们可以看到这个模型也可以与第三种模型结合，以获得尽可能最大的收益。

第三种货币化模型是**广告模型**；我们在应用中放置广告，当用户点击它们时，我们获得收入。我们可以使用不同类型的广告——从全屏广告到底部的小横幅。我们将关注这个模型。其实施比你想象的要容易。但在实施之前，我们需要解释诸如**CPC**（**每次点击成本**）、**CTR**（**点击通过率**）、填充率等术语，这将帮助我们选择一个好的广告平台和提供商。这对于理解指标并能够阅读图表以了解应用中的广告表现也是必要的。在不同的位置放置广告可能会改变收入；然而，我们需要在不烦扰用户的情况下最大化收益。如果我们为用户提供以小额费用通过应用内产品或无广告的付费版本来移除广告的选项，我们可以增加广告的数量。如果用户知道他们有选择，这对他们来说是最好的。如果他们选择与广告共存，这是他们的决定，不会像我们没有提供移除广告的选项而放置大量广告那样让他们感到烦恼。

## 广告收益化的关键点

我们将解释基础知识，以了解广告收益化是如何运作的。商业中有一些带有缩写的概念，一开始可能会让人感到困惑。

一旦我们在广告平台上注册，我们就会看到一个关于我们应用的统计数据报告页面。以下是来自广告网络`AdToApp`的仪表盘示例：

![广告货币化的关键点](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_04.jpg)

在这里，我们可以看到请求、填充率、展示量、点击量、CTR、eCPM 和收入。让我们逐一考虑它们。

请求是指我们的应用向广告网络请求广告的次数。例如，如果我们决定在应用开始时添加一个全屏广告，那么每次启动应用时，都会向服务器发送请求以获取广告。

我们的应用中并没有实际的广告内容；我们拥有的是一个占位符、一个框架以及一个`AdView`，它将由广告网络提供的内容填充。有时，在请求时刻广告网络可能没有广告给我们，这就是下一个概念重要的原因。

填充率是通过已投放广告数除以请求广告数得出的百分比。例如，如果我们启动应用 10 次，只收到 5 次广告，那么我们的填充率为 50%。在一个好的广告网络中，我们希望填充率为 100%。我们希望展示尽可能多的广告，并且点击单价要高。

CPC，即每次点击成本，是指用户在我们的应用中点击广告时我们获得的收入；这个数值越高，我们获得的收入越多。广告商决定了广告的 CPC。一些广告商可能愿意为每次点击支付更多的费用。

许多低 CPC 的点击不一定比少量高 CPC 的点击更好。这就是为什么我们拥有的广告质量重要的原因。

展示量是指广告向用户展示的次数。在上一个例子中，如果有 10 次广告请求，其中 5 次失败，我们就会有 5 次展示量。如果用户不点击，展示量不会产生收入。

点击量是指用户点击广告的次数。这是基于 CPC 产生收入的方式。因此，5 次点击，每次点击 0.5 美元，将会产生 5x0.5，即 2.5 美元的收入。

CTR，即点击通过率，是通过应用收到的点击量除以展示量得出的百分比。如果我们有 100 次广告展示，并且有 1 次点击，我们的 CTR 为 1%。这个数值通常低于 5%，因为用户不会点击他们看到的每一个广告。如果你通过强制用户点击广告来作弊，比如**Admob**这样的广告平台可能会取消你的账户和支付。例如，如果我们在应用开始时显示一个对话框，要求用户点击广告才能继续使用我们的应用，这将基本上给我们带来 100%的 CTR；每个展示量都会有一次点击，这是不允许的。在任何情况下，我们都不可以推广点击。

广告提供商希望他们的广告能被对其感兴趣的人看到；他们不希望为那些对广告不感兴趣、一秒钟后就会关闭广告的人的点击付费。可能你有一个高的点击通过率（CTR），因为你在应用中有一个好的广告位置，而且广告对每个用户都有吸引力。如果发生这种情况，你将不得不向你的广告网络解释，或者像**Admob**这样的广告网络可能会关闭你的账户。但我们也不应该对他们太不公平；他们这样做是因为他们发现很多人试图破坏规则，这样一个庞大的公司无法专注于个人，所以他们需要有客观的筛选机制。

其他广告网络公司在这一点上更加灵活；他们通常会为你分配一个代理人，你可以通过 Skype 或电子邮件频繁联系他，在有任何问题时，他们通常会通知你。

eCPM 代表“每千次展示的有效成本”。它是通过将总收入除以总展示次数（以千为单位）来计算的。这基本上是一种只需查看一个数字就能快速了解你表现如何的方法——非常有助于比较广告网络。这个数字通常在$0 到 3$之间。

我们需要考虑到这并不包括填充率。它是每千次展示的成本，而不是每千次请求的成本。一个 3 美元的 eCPM，如果填充率为 50%，与 1.5 美元的 eCPM 和 100%的填充率是相同的。

一个优秀的广告网络应具备高填充率和高的 eCPM。我们需要这两者都高；如果广告点击费用昂贵但填充率不足，将无法产生收入，因为它们根本不会被展示。

**AdToApp**的团队制作了一张不错的图来解释这一点：

![广告货币化的关键点](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_05.jpg)

这张图展示了我们一直在讨论的内容；一个高端广告网络，其 eCPM 非常高而填充率低，被表现为一座高但空荡荡、灯光熄灭的大楼。

我们已经完成了理论学习，可以开始整合广告解决方案；在本例中，我们将选择 AdToApp。

## 使用 AdToApp 添加广告

没有办法知道哪个广告提供商更适合你；你能做的最好的事情就是尝试不同的提供商，并查看统计数据。

根据经验，我们喜欢使用 AdToApp，除了它良好的投放效果外，它真的很容易集成，即使你已经集成了其他网络，也可以将它包含在你的应用中。因此，衡量其性能真的很简单。

在这本书中使用它搭配`MasteringAndroidApp`非常理想，因为它允许我们使用不同类型的广告，包括全屏广告、横幅、视频等。

有超过 20 个不同广告网络的调解者，因此包含他们的 SDK，我们将有大量保证高填充率的广告可供选择。至于他们的 eCPM，他们会分析哪个网络能为你带来更好的结果；因此，如果他们可以从多个网络投放广告，他们会选择效果更好的。

![通过 AdToApp 添加广告](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_06.jpg)

我们可以开始创建一个账户，地址是[`adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow`](https://adtoapp.com/?r=OZ-kU-W9Q2qeMmdJsaj3Ow)。

创建账户后，我们将使用我们应用的包名创建一个应用。

![通过 AdToApp 添加广告](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_07.jpg)

我们将点击 SDK 按钮下载他们的 SDK，并获取集成所需的配置值。

![通过 AdToApp 添加广告](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_08.jpg)

集成非常简单；SDK 将包含一个`AdToAppSDK.jar`文件，我们需要将其复制到`libs`目录中。我们还需要在`build.gradle`中添加 Google Play Services 和*v7*支持库，但我们已经有这些了。

我们需要在清单中添加基本权限，我们已经有这些了，使用以下代码：

```java
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
```

然后，我们需要在清单中添加额外的必要资产，这可以复制自同一网站；它包含我们账户的密钥。你可以在以下截图所示的第一部分找到它们：

![通过 AdToApp 添加广告](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_09.jpg)

最后，我们可以看看如何实现**插屏广告和横幅广告**或激励广告。激励广告是游戏中弹出的广告，提示*观看此视频并获得（金币、宝石等）*。是否观看这些广告完全取决于用户是否想要奖励。

![通过 AdToApp 添加广告](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_10.jpg)

如果我们选择插屏广告和横幅广告，我们需要根据是需要仅视频广告、仅图片（横幅）广告，还是插屏中同时包含图片和视频广告来初始化它们。

在网站上，根据你想要的广告类型，将展示必要的代码。

SDK 非常灵活；我们可以更进一步设置回调，以了解横幅广告何时加载和点击。这允许我们跟踪广告的点击次数，并验证它们与 AdToApp 控制台中的数据一致，使整个过程透明。

如果我们需要额外的帮助，可以在 SDK 中激活日志，它会在出现任何问题时通知我们。

现在请记住我们在本节开始时提到的良好实践，即在不过多打扰用户的前提下最大化广告数量，并在你的应用中实施这些方法，开始获得收益！

![通过 AdToApp 添加广告](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_11.jpg)

# 将我们的应用发布到 Play 商店。

最后，我们的应用准备好了！这是开发新应用时最美好的时刻；是时候将其上传到 Play 商店，获取用户的反馈，并希望获得成千上万的下载量。

我们需要将应用导出为 APK 文件；为了上传到 Play 商店，它必须使用发布证书进行签名。这一点非常重要；一旦应用程序用证书签名，如果我们将其上传到 Play 商店，并在将来想要上传新版本，就必须使用同一证书进行签名。

我们在发布过程中会创建这个证书。它需要一个别名和密码，因此请确保你记住这些细节并将证书文件保存在安全的地方。否则，假设你的应用得到了好的评分和大量的下载，当你想要更新版本时，如果没有证书或忘记了密码，就无法进行更新。在这种情况下，你将不得不上传一个具有不同包名的全新应用，并且它的下载量和评分将从零开始。

## 代码混淆

在发布应用时需要考虑的另一个重要事项是代码混淆。如果我们导出应用而不混淆代码，任何人都可以下载 APK 并反编译它，使他们能够看到你的代码，如果你在其中包含了 Parse IDs、服务器访问细节、GCM 项目编号等，这可能会成为一个安全问题。

我们可以使用**Proguard**混淆代码。Proguard 是 Android 构建系统中包含的一个工具。它混淆、缩小和优化代码，移除未使用的代码，并重命名类、字段和方法，以防止逆向工程。

注意类和方法的重命名，它可能会影响你的崩溃和错误报告，因为堆栈追踪将会被混淆。然而，这不是问题，因为我们可以在发布应用时保存一个映射文件，用它可以重新追踪，这将允许我们将崩溃和报告转换成可读的、未被混淆的代码。

要激活 Proguard，我们需要在`buildTypes`中将`minifyEnabled`属性设置为`true`。你可以执行以下代码来实现这一点：

```java
buildTypes {
  release {
    minifyEnabled true
    proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
  }
}
```

在我们的项目中，有一个`proguard-rules.pro`文件，我们可以在其中添加混淆时要考虑的规则。例如，如果我们混淆一些第三方库，它们可能无法正常工作，而这些库没有混淆的风险，因为它们不是我们创建的；我们只是将它们添加到我们的项目中。

![代码混淆](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_12.jpg)

为了防止第三方库被混淆，我们可以添加`-keep`规则以及`-dontwarn`规则来忽略警告。例如，我们添加了`calligraphy`以使用自定义字体；这样我们可以在混淆过程中忽略它：

```java
# DONT OBFUSCATE EXTERNAL LIBRARIES

# CALLIGRAPHY
-dontwarn uk.co.chrisjenx.calligraphy.**
-keep class uk.co.chrisjenx.calligraphy.** {*;}
# TIMBER
-dontwarn timber.log.**
-keep class timber.log.** {*;}
```

使用`keep`和包名，我们将保留该包内所有的类。

我们将在调试模式下添加 Proguard，故意创建一个崩溃，以查看混淆后的堆栈追踪的样子：

```java
Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.view.View.setVisibility(int)' on a null object reference
            at com.packtpub.masteringandroidapp.SplashActivity.onCreate(Unknown Source)
```

我们可以复制这个`stracktrace`到文本文件中，并前往`app/build/outputs/mapping/product_flavor_name/ release_or_debug/mapping.txt`获取我们的`mapping.txt`文件。

请考虑我们在`<sdk_root>/tools/proguard`中执行以下代码的 retrace 命令：

```java
retrace.sh [-verbose] mapping.txt [<stacktrace_file>]
```

在这种情况下，我们将有正确的行号出现崩溃，如下所示：

```java
Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.view.View.setVisibility(int)' on a null object reference
at com.packtpub.masteringandroidapp.SplashActivity.onCreate(SplashActivity.java:21)
at android.app.Activity.performCreate(Activity.java:6289)
```

请记住，在每次发布应用时保存`mapping.txt`文件的副本；每次发布时这个文件都会被覆盖，因此在每次发布时保存文件非常重要。或者，如果你有一个仓库，并且为每次发布标记提交，你可以回退并重新生成相同的发布，理论上这将具有相同的映射文件。

既然我们的应用已经针对逆向工程进行了保护，我们可以继续发布流程。

## 导出应用

当我们导出应用程序时，我们实际上是在发布模式下创建一个 APK 文件，并用证书对其进行签名。这个证书证明了 Play Store 中的应用程序属于我们，有了它，我们可以上传我们之前解释的同一个应用程序。这次我们将导出应用并创建一个证书。

要导出我们的应用程序，有两种方法：一种是在 Android Studio 中使用 Gradle 和终端，第二种是使用 Android Studio 中的向导。我们将了解这两种方法，但首先使用第二种方法创建证书。

导航到**构建** | **生成签名的 APK**；你会看到一个类似的对话框：

![导出应用](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_13.jpg)

如果我们之前导出过这个应用并为其创建了证书，那么我们只需选择一个路径并输入别名和密码，这将使用现有证书导出一个新版本的应用。

对我们来说，这是第一次导出`MasteringAndroidApp`，所以我们将点击**创建新的...**。在下一个屏幕上，我们需要选择保存证书的路径，这是一个`.keystore`文件。

我们还需要为`keystore`和证书中的别名设置密码。对于有效期为 100 年的日期来说是可以的；如果你的应用比你活得更长，那就不是你的问题了！最后，在这里至少需要一个字段填写个人信息：

![导出应用](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_14.jpg)

最后，它会询问我们想要导出哪个版本的应用，并创建`.apk`文件，同时指出文件的路径。

这种方法很直接，但还有一种使用命令行和 Gradle 自动导出应用的方法；如果我们想用 Jenkins 构建应用程序，这非常有用。

为此，我们需要在`build.gradle`中添加一个签名配置，以便在自动生成应用程序时，它知道要使用哪个`keystore`以及哪个别名和密码。以下代码将有助于实现这一点：

```java
signingConfigs {
  release {
    storeFile file("certificate.keystore")
    storePassword "android"
    keyAlias "android"
    keyPassword "android"
  }
}
```

不用说，这可能导致安全问题；密码写在 `build.gradle` 中，证书文件包含在我们的项目中。如果我们这样做，需要确保项目安全。如果这是一个关注点，你可以使用以下代码在运行时读取密码和别名：

```java
storePassword new String(System.console().readPassword("\n\$ Enter keystore password: "))
keyAlias System.console().readLine("\n\$ Enter key alias: ")
keyPassword new String(System.console().readPassword("\n\$ Enter key password: "))
```

当我们运行生成签名 APK 的命令时，它会要求我们输入密码别名和别名密码。我们可以使用以下代码行来完成这个操作：

```java
>./gradlew assembleRelease
```

![导出应用](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_15.jpg)

当我们的应用导出后，可以继续最后一步：上传到 Play 商店。

## 将我们的应用上传到 Play 商店

要发布一个应用，我们需要一个 Google 开发者账户。如果你没有，可以从 [`play.google.com/apps/publish/`](https://play.google.com/apps/publish/) 获取一个。

### 创建发布者账户

创建发布者账户的第一步是输入基本信息，并阅读并接受开发者分销协议。第二步是支付 25 美元的开发许可费用以创建账户。这是我们发布应用所需支付的全部费用，只需一次性支付——一次付费，终身许可。考虑到在 iOS 上，费用是每年 99 美元，我们不应该抱怨。

最后第三步需要开发者姓名，它将显示在我们应用程序名称下方。以下是 Google Inc 的一个示例：

![创建发布者账户](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_16.jpg)

我们还需要电子邮件、手机号码以及我们的网站（可选）。根据 Google 的说法，这是为了在有人需要就发布的内容联系我们时使用。

### Google Play 开发者控制台

当我们打开发布者账户时，如果我们还没有发布任何应用，我们将看到开发者控制台四个主要功能，如下面的图片所示：

![Google Play 开发者控制台](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_17.jpg)

第一个选项是发布一个 Android 应用，这是我们将在书中遵循的选项。然而，在此之前，我们将快速描述其他需要记住的选项。

第二个选项是关于 Google Play 游戏服务。如果你开发了一个游戏，希望玩家保存并提交他们的得分，并有一个得分排行榜，你需要一个服务器来存储这些分数并检索它们，甚至可能需要玩家用户名和登录。游戏服务为我们完成这些工作。

它提供了一个 API，跨游戏共享，与用户的 Google 账户关联，我们可以管理排行榜和成就。它甚至提供了 API 和基础设施来实现多人游戏，包括实时多人和回合制游戏。

左侧底部的第三个选项是关于分享开发者控制台的。我们可能希望允许其他开发者更新应用。例如，在公司中，这将有助于那些负责设置应用名称、描述、图片以及整体市场营销的人员，以及其他负责应用上传和开发的人员。我们可以配置对控制台和特定应用的访问权限。

![Google Play 开发者控制台](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_18.jpg)

第四个也是最后一个选项是商家账户；如果我们想要销售付费应用或应用内产品，就需要这个。这是来自付费应用的商家账户示例；我们可以看到完成的支付和取消的支付。如果用户购买了我们的应用，他/她在两小时内可以申请退款，如果他/她不喜欢这个应用。

![Google Play 开发者控制台](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_19.jpg)

因为我们还没有发布应用，所以我们看到了一个空的开发者控制台和四个主要选项；如果我们有已发布的应用，我们就会看到这个样子。在这种情况下，**发布**按钮在顶部：

![Google Play 开发者控制台](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_20.jpg)

在初始屏幕上，我们可以看到不同的应用，无论它们是免费的还是付费的，活跃安装数量和总安装数量。活跃安装意味着目前拥有该应用并且下载后没有卸载的人。总安装数量意味着应用被安装的所有次数的总计。

我们还可以看到评分和崩溃次数。如果我们点击应用并进入详细视图，我们还可以查看更多详细信息，例如用户的评论和错误崩溃报告。

### 发布应用

继续上传过程，当我们点击**+ 添加**新应用时，系统会要求我们输入名称和默认语言。在此之后，我们可以选择通过上传 APK 或准备商店列表来开始流程。

![发布应用](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_21.jpg)

这两个是不同的过程：一个是上传 APK 文件，另一个是设置应用的标题、描述、图片、是否付费或免费等——所有在 Play 商店中显示的不同选项。

让我们从上传 APK 文件和不同的测试组开始。

### 上传 APK 文件

请记住，当我们上传 APK 时，我们应用的包名必须在 Play 商店中是唯一的；如果我们想要更新之前由我们发布的某个应用，并且使用签名的初始下载的证书与签名新 APK 的证书相同，那么我们可以上传具有现有包名的 APK。

当我们点击**上传 APK**时，首先注意到的就是带有名称的三个不同标签：**生产环境**，**测试版**和**Alpha 版**。

![上传 APK 文件](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_22.jpg)

我们可以在两个测试组中以及生产环境中发布我们的应用。生产环境意味着它在 Play 商店中发布；它是公开的，每个人都可以看到。一段时间以来，开发人员控制台只有这个选项，直到他们添加了分阶段推出的功能。

分阶段推出使我们能够将应用发布给一组有限的用户。为了选择这些用户，我们有多种选项；我们可以通过电子邮件邀请这些用户，分享链接，或者创建一个 Google 群组或 G+ 社区，邀请用户加入该群组并在其中分享应用的链接。只有这些用户才会在 Play 商店中看到应用。这有助于在应用面向全球发布之前，从部分用户那里获取反馈，当然，还可以防止生产环境中的应用出现错误和负面评价。我们还可以选择在生产环境中发布我们应用的用户百分比；例如，如果我们有百万用户，可以先向 10%的用户发布，然后再进行双重检查，确保一切正常，再进行大规模发布。

我们的应用可以在不同的阶段有不同的版本；例如，我们可以发布版本 1.0.0，1.0.1 处于 beta 测试阶段，1.0.2 处于 alpha 测试阶段。我们可以从 alpha 向 beta 推出 APK，从 beta 向生产环境推出，但我们不能回滚。

我们现在要解释的概念非常重要。一旦我们发布了应用的一个版本，我们就不能回到之前的发布版本。可能会发生这样的情况：我们在 Play 商店中有一个应用的工作版本，我们开发了一个新版本，在我们的设备上运行良好，我们认为它已经可以上传了。现在是周五下午，我们不想进行测试，因为我们认为，“哦，我确信它没问题。我只是做了两行小改动，不会影响任何东西”。我们上传了版本 1.0.4。几小时后，我们开始收到来自 Play 商店的崩溃报告。这是恐慌的时刻；我们现在能做的唯一事情是撤销当前应用的发布，以防止更多损失，并尽快开始修复。然而，如果修复不容易，最明智的做法是再次生成最后一个已知的工作版本（1.0.3），将版本号和代码增加到 1.0.5，并将其上传到 Play 商店。

然而，情况可能会更糟；如果我们有一个数据库，并且其结构从 1.0.3 变化到 1.0.4，如果我们的代码还没有准备好接受从 1.0.4 到作为 1.0.5 重新命名的 1.0.3 的数据库降级，我们将知道我们整个周末都要工作，结果在周一早上被解雇。总之，我们的观点是，预防胜于治疗；因此，使用分阶段推出，在发布之前进行所有必要的测试，并且避免在周五下午发布，以防万一。

### 准备商店列表

对于开发者来说，准备商店列表可能是最无聊的部分，但为了发布应用，这是必须要做的；有一些我们不能跳过的必填资产和字段。

首先，我们需要为我们的应用起一个标题，一个最多 80 个字符的简短描述和一个最多 4000 个字符的长描述。标题将是我们搜索应用时首先看到的内容；简短描述例如在平板电脑浏览应用时可见。这是我们的应用的*elevator pitch*（电梯游说），我们需要在这里的主函数中描述它：

![准备应用商店列表](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_23.jpg)

长描述将在我们查看应用详情视图时显示。为了在更多搜索中出现并获得可见性，在描述中识别并添加与应用相关的关键词是很有帮助的。使用不相关关键词吸引用户下载是被 Google 禁止的，如果你这样做，你将在开发者控制台收到警告，并且你的应用在重新获得批准和发布之前需要做出一些更改。

在这一点上，我们有权选择国际化我们应用列表，重复这些前面提到的三个字段，以我们想要的任何语言，它们将根据用户的语言自动显示在不同的语言中。

下一步是开发图形，我们需要在这里拍摄截图。截图可以通过设备上的按键组合轻松完成；例如，在三星 Galaxy 3 上，这是通过同时按下*音量下*和*菜单*键完成的。也可以从 Android Studio 中通过选择 Android 视图中的相机图标来拍摄。

![准备应用商店列表](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_24.jpg)

除了截图，我们还需要一个 512 x 512 高分辨率的图标；这必须与我们在上传版本中为应用使用的图标相同或非常相似，否则它会发出警告。因此，始终创建 512 x 512 的图标，然后将其缩小以在我们的应用中使用是很好的做法。反其道而行之将导致图像质量差地放大。以下是图标显示的一个示例：

![准备应用商店列表](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_25.jpg)

我们需要的最后一张图片是功能图。这是一张 1024 x 500 的图片，展示了我们应用的功能。如果我们的应用在 Google Play 上被精选，这张图片将被展示。它将在 Play 商店应用中显示；如果我们有促销视频，当视频不播放时，功能图仍然会显示。

![准备应用商店列表](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_26.jpg)

我们需要继续进行分类；根据我们的应用是游戏还是应用程序，我们需要选择不同的类别。如果你不确定选择哪个类别，可以在 Play 商店查看与你应用相似的应用。

之后，我们需要选择内容评级；从 2015 年 5 月开始，每个应用程序都需要有新的评级系统。根据谷歌的说法，这个新的内容评级提供了一种简单的方法，向用户传达熟悉且与本地相关的内容评级，并通过针对您内容的目标受众来帮助提高应用程序的参与度，具体内容请参阅[`support.google.com/googleplay/android-developer/answer/188189`](https://support.google.com/googleplay/android-developer/answer/188189)。

我们的联系方式会自动填写，所以我们需要做的最后一件事是接受隐私政策，然后我们可以点击**定价与分发**。

![准备商店列表](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_27.jpg)

在这里，我们可以决定应用程序是免费还是付费；这一步无法撤销。如果应用程序是付费的，我们可以设置一个价格，谷歌会将它转换成不同国家的不同货币；尽管如此，我们可以为每个国家设置不同的价格。我们可以选择加入不同的开发者群体；例如，如果我们开发了一个儿童应用程序，我们可以将其包含在**为家庭设计**中。这将增加我们在儿童专区被突出显示的机会，并关联到与儿童应用程序相关的第三方网络。

在这一部分，我们还可以选择希望发布应用程序的国家。这也可以用作应用程序首次发布时的分阶段发布策略。

![准备商店列表](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_28.jpg)

完成以上所有步骤后，我们可以通过点击右上角的**发布**来发布我们的应用程序。

![准备商店列表](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/ms-andr-gm-dev/img/B04887_12_29.jpg)

如果按钮不可用，您可以点击**为什么我不能发布？**，它将在左侧列出要求。应用程序发布后，可能需要几个小时才能在 Play 商店中显示。确定应用程序是否已发布的最简单方法是使用包名在 URL 中导航到我们的应用程序。在我们的例子中，URL 将是[`play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp`](https://play.google.com/store/apps/details?id=com.packtpub.masteringandroidapp)。

就这样！我们从初学者到更高级别完成了本书的学习，具备了上传设计良好、构建完善、向下兼容并能实现盈利的应用程序所需的知识。

我们祝愿您的应用程序取得成功，并希望您能打造出下一个《愤怒的小鸟》或下一个 WhatsApp！

### 注意

非常感谢您购买并读完这本书。对于建议、改进或任何反馈，请毫不犹豫地通过`<Antonio@suitapps.com>`联系我，或者在 Twitter 上关注我`@AntPachon`。

# 总结

在本书的最后一章中，我们开始学习如何创建应用程序的不同版本，将构建类型与产品风味结合以获得构建变体。

之后，我们学习了如何对我们的应用程序进行货币化，添加了不同类型的广告，并解释了广告货币化的关键要点。

我们还从 Android Studio 和使用 Gradle 命令行导出了应用程序，进行了混淆并使用发布证书进行了签名。

最后，我们在 Play 商店上传并发布了我们的应用程序。
