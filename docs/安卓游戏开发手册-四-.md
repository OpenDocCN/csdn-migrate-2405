# 安卓游戏开发手册（四）

> 原文：[`zh.annas-archive.org/md5/677EF72CE0EEA561393A2FD5106AE241`](https://zh.annas-archive.org/md5/677EF72CE0EEA561393A2FD5106AE241)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 第十一章：使用 C ++和 OpenGL 进行 Android 游戏开发

我们已经看到了 Android 应用程序和 Android 游戏之间的区别。 Android SDK 非常擅长处理这两者。当然，引起的问题是“在本地语言（如 C 和 C ++）中需要单独的开发工具集是什么要求？”与 Java 相比，C 和 C ++更难管理和编写代码。答案就在问题本身。 Java 架构在 JVM 上运行，与 Android 操作系统相关联。这会产生额外的延迟，导致性能滞后。滞后的规模取决于应用程序的规模。

高度 CPU 密集型的应用程序可能会在 Java 架构中导致大量可见的延迟。本地语言代码可以更快地处理。此外，本地代码可以根据 CPU /平台架构的不同而变化，而在 Android SDK 使用的 Java 架构中是不可能的。

Android 使用 OpenGL 渲染系统。因此，使用 OpenGL 制作的应用程序也可以选择 Android 作为目标平台。本地代码有助于直接使用 OpenGL 构建应用程序。

我们将通过以下主题在本章中详细了解这些方面：

+   介绍 3Android NDK

+   游戏中的 C ++-优缺点

+   本地代码性能

+   OpenGL 简介

+   使用 OpenGL 进行渲染

+   不同的 CPU 架构支持

# Android NDK 简介

Android 实际上是基于 Java 架构的。但是，Android 应用程序的一部分可以使用 C 和 C ++等本地语言开发。这就是 Android NDK 出现的地方。

Android NDK 是一个工具集，用于开发将与硬件交互得更快的应用程序模块。众所周知，C 和 C ++能够直接与本地组件交互，从而减少应用程序和硬件之间的延迟。

## NDK 的工作原理

Android 本地代码段通过**Java 本机接口**（**JNI**）与主应用程序进行交互。 Android NDK 附带一个构建脚本，将本地代码转换为二进制代码并将其包含在主 Android 应用程序中。

该二进制代码基本上是一个本地代码库，可以根据需要在任何 Android 应用程序中使用。 NDK 构建脚本创建`.so`文件并将其添加到应用程序路径中。

Android 构建过程创建 Dalvik 可执行文件（`.dex`）以在 Android OS 的 Dalvik 虚拟机（或 ART）上运行。 Java 可执行文件识别本地库并加载已实现的方法。本地方法使用`native`关键字声明：

```kt
public native void testFunc (int param);
```

该方法始终具有公共访问权限，因为本地库始终被视为外部来源。在这里，开发人员应始终牢记，对于所有包含的本地库的同一声明，永远不应该有多个方法的定义。这将始终创建编译错误。

本地构建过程可以将本地项目构建为两种类型的库：

+   本地共享库

+   本地静态库

### 本地共享库

本地构建脚本从 C ++文件创建`.so`文件，称为本地共享库。但是，它并不总是在真正意义上在应用程序之间共享。 Android 应用程序是一个 Java 应用程序，但是本地应用程序可以通过本地共享库触发。

对于游戏开发，如果游戏是用本地语言编写的，则游戏代码将包含在共享库中。

### 本地静态库

本地静态库基本上是已编译对象的集合，并由`.a`文件表示。这些库包含在其他库中。编译器可以在编译过程中删除未使用的代码。

## 构建依赖

Android SDK 能够使用 Java 构建和打包 Android 应用程序项目为 APK 文件。然而，NDK 不足以构建和打包 APK 文件。除了 NDK 之外，创建 Android 应用程序 APK 的依赖如下：

+   Android SDK

+   C++编译器

+   Python

+   Gradle

+   Cygwin

+   Java

### Android SDK

Android 应用程序基本上是 Java 应用程序。因此，有必要拥有 Android SDK 来创建 Android 应用程序包。

### C++编译器

本机 Android 应用程序是用 C++编写的，因此需要 C++编译器在开发平台上编译代码库。C++编译器是平台相关的，因此可能不是每个平台上都是相同的 C++编译器。

例如，在 Windows 机器上，目前在开发行业中使用 C++11 编译器，而在 Linux 机器上使用 GC++编译器。

这可能会在语法和 API 调用方面为实际开发项目创建不同的代码库。

### Python

Python 是一种独立的开发语言。它可以用于创建 Android 应用程序，并通过将源代码转换为本机语言来支持多个平台。在 Android NDK 开发的情况下，Python 用于将 C++代码转换为本机二进制。

### Gradle

Gradle 被构建脚本和 Android 本机构建工具使用，将本机代码转换为共享库。它还提供了一个虚拟的 Unix 环境来制作应用程序包。

### Cygwin

Android 需要一个 Unix 环境来构建 NDK 应用程序项目。Windows 系统没有 Unix 环境。需要 Cygwin 来提供虚拟的 Unix 环境来支持构建平台。

### Java

最后但并非最不重要的是需要 Java 来创建 Android 应用程序包。然而，对于任何类型的 Android 开发，都需要 Java。

## 本机项目构建配置

为了从本机源代码创建应用程序包，Android 项目需要以下配置。本机项目构建取决于这两个文件中定义的配置：

+   `Android.mk`

+   `Application.mk`

### Android.mk 配置

**位置**

`Android.mk`文件可以在`<应用程序项目路径>/jni/`中找到。

**配置选项**：

`Android.mk`文件包含以下选项来创建应用程序包：

+   `CLEAR_VARS`：这清除本地和用户定义的变量。这个选项由`include $(CLEAR_VARS)`语法调用。

+   `BUILD_SHARED_LIBRARY`：这包括所有本地文件，在`LOCAL_MODULE`和`LOCAL_SRC_FILES`中定义，以共享库的形式。它由`include $(BUILD_SHARED_LIBRARY)`语法调用。

+   `BUILD_STATIC_LIBRARY`：这指定静态库以创建由共享库使用的`.a`文件。它由`include $(BUILD_STATIC_LIBRARY)`语法调用。

+   `PREBUILT_SHARED_LIBRARY`：这表示特定路径上的预构建共享库，用于从本地包含构建依赖的共享库。它由`include $(PREBUILT_SHARED_LIBRARY)`语法调用。

+   `PREBUILT_STATIC_LIBRARY`：这表示特定路径上的预构建静态库，用于从本地包含构建依赖的共享库。它由`include $(PREBUILT_STATIC_LIBRARY)`语法调用。

+   `TARGET_ARCH`：这表示基本处理器架构系列，如 ARM、x86 等。

+   `TARGET_PLATFORM`：这定义目标 Android 平台。所述平台必须通过 Android SDK 管理器安装在开发系统中。它指示 Android API 级别以创建应用程序包。

+   `TARGET_ARCH_ABI`：这表示目标处理器架构的特定 ABI，如 armeabi、armeabi-v7、x86 等。

+   `LOCAL_PATH`：这指向当前文件目录。这个变量不会被`CLEAR_VARS`命令清除。它由`LOCAL_PATH := $ (call my-dir)`语法调用。

+   `LOCAL_MODULE`：这表示所有唯一的本地模块名称。它由`LOCAL_MODULE := "<模块名称>"`语法调用。

+   `LOCAL_MODULE_FILENAME`：这表示包含已定义`LOCAL_MODULE`的库名称。它由`LOCAL_MODULE_FILENAME := "<模块库文件名>"`语法调用。

+   `LOCAL_SRC_FILES`：这表示要编译为共享库的所有本地源代码文件路径。它由`LOCAL_SRC_FILES := <本地源文件路径>`语法调用。

还有其他可选配置可以在此文件中设置，例如`LOCAL_C_INCLUDES`、`LOCAL_CFLAGS`、`LOCAL_CPP_EXTENSION`、`LOCAL_CPP_FEATURES`、`LOCAL_SHARED_LIBRARIES`、`LOCAL_STATIC_LIBRARIES`和`LOCAL_EXPORT_CFLAGS`。

### Application.mk 配置

**位置**

`Application.mk`文件可以位于`<应用程序项目路径>/jni/`。

**配置选项**

`Application.mk`文件包含以下选项以创建应用程序包：

+   `APP_PROJECT_PATH`：这是项目根目录的绝对路径。

+   `APP_OPTIM`：这表示可选设置，用于将构建包创建为发布版或调试版。

+   `APP_CFLAGS`：这定义了一组 C 编译器标志，用于构建而不是在`Android.mk`文件中更改。

+   `APP_CPPFLAGS`：这定义了一组 C++编译器标志，用于构建而不是在`Android.mk`文件中更改。

+   `APP_BUILD_SCRIPT`：这是一个可选设置，用于指定除默认的`jni/Android.mk`脚本之外的构建脚本。

+   `APP_ABI`：此选项指定要为 Android 应用程序包进行优化的 ABI 集。以下是每个 ABI 支持的完整列表和关键字：

+   ARMv5：`armeabi`

+   ARMv7：`armeabi-v7a`

+   ARMv8：`arm64-v8a`

+   Intel 32 位：`x86`

+   Intel 64 位：`x86_64`

+   MIPS 32 位：`mips`

+   MIPS 64 位：`mips64`

+   ALL-SET：`all`

+   `APP_PLATFORM`：此选项指定目标 Android 平台。

+   `NDK_TOOLCHAIN_VERSION`：此选项指定 GCC 编译器的版本。默认情况下，64 位和 32 位分别使用版本 4.9 和 4.8 进行编译。

+   `APP_STL`：这是一个可选的配置，用于链接替代 C++实现。

+   `APP_LDFLAGS`：在构建共享库和可执行文件的情况下，此选项用于将链接标志链接到构建系统以链接应用程序。

# 用于游戏的 C++-优点和缺点

C++和 Java 之间有一个永无止境的争论。然而，我们不会讨论争议，而是试图从游戏开发的角度来看待它们。C++在性能上略优于 Java，而 Java 以其简单性而闻名。

可能有许多程序员更喜欢 C++而不是 Java，或者反之亦然。在游戏开发中，编程语言的个人选择并不重要。因此，使用 NDK 或 SDK 必须根据需求来确定。建议您始终使用 Android SDK 来开发应用程序，而不是使用 NDK。

让我们讨论使用本地语言进行游戏编程的优缺点。

## 使用 C++的优势

让我们首先从以下几点来看看使用 C++进行游戏编程的积极方面：

+   通用游戏编程语言

+   跨平台可移植性

+   更快的执行

+   CPU 架构支持

### 通用游戏编程语言

在游戏开发的情况下，C++被广泛用于许多平台，特别是用于主机和 PC 游戏开发。这就是为什么许多游戏引擎选择 C++作为主要编程语言的原因。

有时，学习许多编程语言以在不同架构的不同平台上工作是困难的。C++提供了这个问题的最常见解决方案，因为大多数程序员都熟悉 C++库和 API 的使用。

### 跨平台可移植性

相同的 C++代码被编译为针对特定操作平台的库。因此，同一个项目可以编译为不同的平台。因此，如果游戏是用 C++编写的，那么将游戏移植到各种平台就会变得非常容易。

例如，著名而有效的跨平台游戏引擎 Cocos2d-x 使用 C++作为开发语言。因此，相同的游戏可以轻松移植到许多平台，如 Android、iOS、Mac OS 和 Windows。

### 更快的执行

C++能够很好地与平台硬件交互，并且使用 C++编写游戏有助于提高性能。然而，在 Android 的情况下，如果游戏不是 CPU 密集型，性能提升几乎是不可察觉的。

### CPU 架构支持

C++代码可以针对特定的目标 CPU 架构进行编译，如 x86、ARM、Neon 或 MIPS。这种规范表明在特定处理器上有更好的性能。

在 Android NDK 中为 CPU 架构配置编译器确保在每个平台上获得最佳结果。然而，并不总是需要为避免额外的编译而定义每个平台。

## 使用 C++的缺点

现在，让我们通过以下几点来讨论问题的另一面：

+   高程序复杂性

+   依赖平台的编译器

+   手动内存管理

### 高程序复杂性

C++带来了额外的程序复杂性。在 Java 编程的情况下，JVM 完全负责内存管理，并遵循面向对象的概念。C++在提供这一特性方面存在不足。因此，开发人员需要额外的工作来处理每个编程方面。

与 Java 相比，C++本身的架构更加复杂。如果使用 C++，面临异常和错误的机会会增加。

### 依赖平台的编译器

使用 C++进行跨平台开发很容易。然而，在大多数情况下，配置构建脚本可能会很麻烦。同样的游戏由于错误的配置而无法在移植的平台上运行是非常常见的情况。此外，由于游戏在其他平台上成功运行，因此很难找出问题所在。

大多数情况下，不同的平台使用不同的 C++编译器。因此，需要额外的努力来识别特定于平台的代码，并在必要时为每个平台找到替代方案。 

### 手动内存管理

Java 不需要开发人员实现内存管理，内存由 JVM（在 Android 的情况下是 DVM）高效管理。因此，不会出现内存泄漏或碎片化的情况。JVM 会运行垃圾收集器来自动释放未使用的内存。然而，垃圾收集器的调用会消耗一些性能，频繁的垃圾收集器调用可能会导致严重的性能下降。

开发人员应该使用最佳内存，因为如果代码中有任何活动引用，垃圾收集器无法识别未使用的内存块。

## 结论

C++有其自身的优势。然而，当涉及到为 Android 进行游戏编程时，在技术上并没有太大帮助。因此，如果我们比较选择 C++和在 Android 上使用 Java 编码所需的工作量和风险，Java 应该始终优先考虑。DVM 能够有效地运行 Java 代码，以在 Android 设备上实现合理的性能。此外，Android NDK 库实际上并不是为开发独立的 Android 应用程序而设计的。尽管它具有本地活动支持，作为 DVM 和用 C++编写的本地应用程序之间的中间层，但并没有太大帮助。

如果开发人员选择不跨平台，并将游戏范围限制在 Android 上，那么建议您使用 Android SDK 而不是 Android NDK。这将减少开发的麻烦和复杂性，同时性能损失可以忽略不计。

# 本地代码性能

正如我们已经知道的，本地代码可以以更快的处理速度运行。这可以进一步针对特定的 CPU 架构进行优化。这种性能提升的主要原因是在内存操作中使用指针。但是，这取决于开发人员和编码风格。

让我们看一个简单的例子，我们可以更好地理解本地语言中的性能增益。

考虑这段 Java 代码：

```kt
int[] testArray = new int[1000];
for ( int i = 0; i < 1000; ++ i)
{
  testArray[i] = i;
}
```

在这种情况下，数组中 1000 个字段的地址由 JVM（在 Android Dalvik 系统中为 DVM）处理。因此，解释器每次解析到第*i*个位置并执行赋值操作，这需要很长时间。

现在，让我们使用本地 C/C++语言实现相同的功能并使用指针：

```kt
int testArray[1000];
int *ptrArray = testArray;
for ( int i = 0; i < 1000; ++ i)
{
  *ptrArray = i;
  ptrArray += i * sizeof(int);
}
```

在这个例子中，解释器不需要解析到目标内存位置。`ptrArray`指出了位置的地址。因此，值可以直接赋给内存位置。

特别是对于多维数组，在正确编写的本地代码中可以观察到显著的性能增益，用于相同功能。本地代码的另一个重要用途是二进制数据处理和图像处理，在这些情况下，大量数据一次性处理。

# 使用 OpenGL 进行渲染

Android 使用 OpenGL 进行渲染。Android SDK 库包括专门针对 Android 进行优化的 OpenGL 库。Android 从 API 级别 4 开始支持 OpenGL，然后随着级别的增加而增加其支持。目前，OpenGL 的最大支持版本是从 API 级别 21 开始的 OpenGL ES 3.1。

## OpenGL 版本

不同的 OpenGL 版本具有不同的功能集。版本 1.0 和 2.0 在编码风格、API 便利性、功能和特性支持方面有很多不同之处。让我们讨论一下对 Android 开发具有重要意义的以下 OpenGL ES 版本：

+   OpenGL ES 1.x

+   OpenGL ES 2.0

+   OpenGL ES 3.0

+   OpenGL ES 3.1

### OpenGL 1.x

从 Android API 级别 4 开始支持 OpenGL 版本 1.x，使用共享的 OpenGL ES 1.x 库`libGLESv1.so`。头文件`gl.h`和`glext.h`包含了 OpenGL 功能所需的所有必要 API。

### OpenGL 2.0

在当前行业中，开发人员更倾向于在游戏中使用 OpenGL ES 2.0，因为几乎每台设备都支持这个 OpenGL 版本，并且它提供了对游戏有用的顶点和片段着色器。OpenGL ES 2.0 可以通过在项目中包含`libGLESv2.so`共享库来用于 Android 本地开发项目，如下所示：

```kt
LOCAL_LDLIBS := -lGLESv2
```

头文件是`gl2.h`和`gl2ext.h`。OpenGL ES 2.0 从 Android API 级别 5 开始支持。

### OpenGL 3.0

从 Android API 级别 21 开始，支持 OpenGL ES 3.0。开发人员可以包含`libGLESv3.so`来使用 OpenGL 3.1，如下所示：

```kt
LOCAL_LDLIBS := -lGLESv3
```

头文件是`gl3.h`和`gl3ext.h`。

### OpenGL 3.1

从 Android API 级别 21 开始，支持 OpenGL ES 3.1。开发人员可以包含`libGLESv3.so`来使用 OpenGL 3.1，如下所示：

```kt
LOCAL_LDLIBS := -lGLESv3
```

头文件是`gl31.h`和`gl3ext.h`。

许多 Android 设备不支持 OpenGL ES 3.0 和 OpenGL ES 3.1。如果开发人员打算使用它们，则在使用版本之前应该进行 OpenGL 版本检查。此外，必须使用适当的 OpenGL ES 版本在特定设备上运行游戏。最新的 Android N 支持 OpenGL ES 3.2。

### 检测和设置 OpenGL 版本

这段 Android Java 代码可以用来为 Android 游戏实现适当的 OpenGL ES 支持：

```kt
private GLSurfaceView glSurfaceView;
void setOpenGLVersion()
{
  final boolean supportOpenGLEs3 = configurationInfo.reqGlEsVersion >= 0x30000;

  if (supportOpenGLEs3) 
  {
    glSurfaceView = new GLSurfaceView(this);
    glSurfaceView.setEGLContextClientVersion(3);
    glSurfaceView.setRenderer(new RendererWrapper());
    setContentView(glSurfaceView);
  }
  else
  {
  final boolean supportOpenGLEs2 = configurationInfo.reqGlEsVersion >= 0x20000;

  if (supportsOpenGLEs2) 
    {
      glSurfaceView = new GLSurfaceView(this);
      glSurfaceView.setEGLContextClientVersion(2);
      glSurfaceView.setRenderer(new RendererWrapper());
      setContentView(glSurfaceView);
    }
    else
    {
      glSurfaceView = new GLSurfaceView(this);
      glSurfaceView.setEGLContextClientVersion(1);
      glSurfaceView.setRenderer(new RendererWrapper());
      setContentView(glSurfaceView);
    }
  }
}
```

## 纹理压缩和 OpenGL

纹理压缩对由 OpenGL 处理的渲染过程有重要影响。它可以增加或减少不同类型的纹理压缩的性能。让我们快速看一下一些重要的纹理压缩格式：

+   ATC

+   PVRTC

+   DXTC

### ATC

ATI 纹理压缩通常称为 ATITC。该压缩支持 RGB 和带或不带 alpha 通道。这是 Android 最常见和广泛使用的压缩技术。

### PVRTC

Power VR 纹理压缩使用 2 位和 4 位像素压缩，带有或不带有 alpha 通道。这被全球许多游戏开发人员使用。

### DXTC

DXTC 也被称为 S3 纹理压缩，也用于 OpenGL。这使用 4 位或 8 位 ARGB 通道。

## OpenGL 清单配置

Android 需要应用程序中使用的 OpenGL 版本定义，以及其他所需选项。

以下是 OpenGL ES 的版本声明语法：

```kt
<uses-feature android:glEsVersion=<Target version goes here> android:required="true" />
```

以下是目标版本选项：

+   `0x00010000`代表版本 1.0

+   `0x00010001`代表版本 1.1

+   `0x00020000`代表版本 2.0

+   `0x00030000`代表版本 3.0

+   `0x00030001`代表版本 3.1

+   `0x00030002`代表版本 3.2

以下是纹理压缩声明的可选设置：

```kt
<supports-gl-texture android:name=<Compression support type goes here> />
```

这些是压缩类型选项：

+   `GL_OES_compressed_ETC1_RGB8_texture`

+   `GL_OES_compressed_paletted_texture`

+   `GL_EXT_texture_compression_s3tc`

+   `GL_IMG_texture_compression_pvrtc`

+   `GL_EXT_texture_compression_dxt1`

+   `GL_EXT_texture_compression_dxt2`

+   `GL_EXT_texture_compression_dxt3`

+   `GL_EXT_texture_compression_dxt4`

+   `GL_EXT_texture_compression_dxt5`

+   `GL_AMD_compressed_3DC_texture`

+   `GL_EXT_texture_compression_latc`

+   `GL_AMD_compressed_ATC_texture`

+   `GL_ATI_texture_compression_atitc`

然而，并非所有设备都支持所有纹理压缩。开发人员应根据硬件和 Android 版本要求始终选择目标纹理压缩。

### 注意

如果目标设备不支持声明的纹理格式，则 Google 会自动进行设备过滤。

## 选择目标 OpenGL ES 版本

正如您已经了解的，不是所有设备都支持所有 OpenGL 版本。因此，在开发游戏之前选择正确的 OpenGL 版本非常重要。在选择 OpenGL 版本时，应评估以下几个因素：

+   性能

+   纹理支持

+   设备支持

+   渲染特性

+   编程舒适性

### 性能

注意到 OpenGL 版本 3.x 比 OpenGL 版本 2.x 更快，后者比 OpenGL 1.x 更快。因此，在游戏中始终最好使用最新可能的版本。

### 纹理支持

纹理压缩支持因 OpenGL 版本而异。旧版本支持旧的纹理压缩因素。此外，Android 版本支持并非所有 OpenGL 版本都通用。因此，最好使用最新可能的版本来支持纹理。

### 设备支持

这个限制使开发人员脚踏实地。并非所有设备都支持最新版本的 OpenGL。因此，为了针对更广泛的设备范围，用户应将 OpenGL 版本更改为 2.0，因为大多数设备支持这个版本。

### 渲染特性

随着 OpenGL 版本的增加，功能列表成为选择 OpenGL 版本的重要因素。开发人员必须了解开发应用程序所需的支持，并相应地选择版本。

### 编程舒适性

OpenGL 的各个版本之间存在巨大的编码风格和 API 更改。开发人员应该选择版本，如果可以在公司轻松开发。

# 不同的 CPU 架构支持

开发人员有机会为单独的处理器架构优化 Android 应用程序。从高层次的角度来看，这是一个很好的功能。然而，这个功能是以巨大的成本为代价的。让我们来看看这个功能的细节。

## 可用的 CPU 架构

以下是 NDK 构建当前支持的架构：

+   ARM

+   x86

+   Neon

+   MIPS

### ARM

**ARM**代表**Acorn RISC Machine**。这是一个基于**RISC**（**Reduced Instruction Set Computing**）的处理器，主要针对嵌入式或移动计算。正如其基础所说，它对于 Android 等操作系统非常高效。

目前，Android 平台上使用最多的处理器来自 ARM 家族。它可以进一步细分如下：

+   ARMv5TE

+   ARMv7

+   ARMv8

### x86

英特尔推出了处理器的**x86**架构。最初，这些处理器主要用于台式机/笔记本电脑。然而，它们经过优化后也可以用于移动设备，以 Celeron 或 Atom 处理器的形式。

Android NDK 构建可以设置两种类型的 x86 架构：

+   i686

+   x86-64

### Neon

**Neon**架构是基于 ARM 技术的，以进一步优化移动计算。Android 构建也可以针对这种特定架构进行优化。所有 Cortex 处理器基本上都是基于 Neon 的处理器。

### MIPS

**MIPS**代表**无互锁流水线级**微处理器。在这个类别中有 32 位和 64 位处理器的变体。正如名称所示，这种架构用于嵌入式设备中的微处理器进行小规模计算。后来，它以 64 位架构引入到 Android 中。然而，这种类型的处理器在今天的 Android 系统中很少使用。

## 集成多种架构支持的优缺点

Android 移动设备在内存和处理能力方面有不同的配置。包括单独的架构支持可能会增加与更大的构建大小相对应的性能。

本地构建工具为每个目标处理器构建一个单独的共享库，并将其包含在构建包中。

以下是提供单独处理器架构支持的一些优缺点。

现在让我们先看看优点：

+   **更快的操作**：为单独的处理器提供单独的架构会导致游戏指令的处理速度更快。如果处理器架构受到 Android 应用的支持，那么处理器就不需要执行任何转换，并且可以以更快的速度运行指令。

+   **处理器的最佳使用**：操作系统总是寻找集成处理器的特定架构。相同的架构可以最佳地利用处理器。

+   最低功耗：最佳处理直接意味着最佳和最低的处理功耗。

+   **最佳内存使用**：如果 Android 应用支持相同的处理器架构，处理器就不需要使用额外的运行时内存来执行指令。

现在让我们看看缺点：

+   **更大的构建大小**：为单独的架构使用单独的共享库会显著增加构建包的大小。整个本地指令代码都会在具有不同处理器优化的单独共享库中重新编写。

+   **减少目标设备数量**：如果 APK 的大小很大，将其适应低存储设备会带来更多问题。因此，设备支持变得更少。

# 总结

我们在本章中简要介绍了 Android NDK，并解决了一些关于本地开发的疑惑。有许多开发人员认为用本地语言开发游戏可以获得巨大的处理能力。然而，这并不总是正确的。处理和性能取决于开发风格和标准。在大多数常见情况下，本地开发和 SDK 开发之间的差异是可以忽略不计的。

OpenGL 在任何情况下都可以与 Android 一起工作。后端渲染基于 OpenGL，无论是 NDK 还是 SDK。我们已经讨论了 OpenGL 的所有技术方面。在这里，您了解了哪个版本的 OpenGL 适用于 Android 以及我们应该使用哪个版本。显然，OpenGL ES 2.0 是一个不错的选择，因为大多数 Android 设备都支持它。另一方面，OpenGL ES 1.0 已经过时，而 OpenGL ES 3.0 尚未得到大多数 Android 设备的支持。

到目前为止，我们已经涵盖了 Android 游戏开发的几乎所有方面。然而，完成游戏的实现并不意味着开发周期的完成。开发人员需要在游戏达到发布准备状态后对其进行打磨，以提高其整体质量。我们将在下一章讨论游戏的打磨，以表示游戏开发过程的完成。


# 第十二章：抛光安卓游戏

开发的游戏质量大部分取决于最终的抛光。抛光基本上是开发的一个阶段，在这个阶段游戏在各个方面得到改进，以提供最大的用户体验。这种改进没有限制。大多数游戏开发人员将大部分时间用于抛光。

在抛光阶段，游戏应该准备好发布。在开发过程的最后，开发人员大多面临时间紧迫。抛光需要大量时间。有很多例子表明，开发人员选择在发布后抛光游戏。然而，从用户体验和留存的角度来看，这是不推荐的。

抛光工作由整个开发团队完成，包括设计师、艺术家和开发人员。确保游戏的目标抛光水平是产品经理和制作人的责任。

许多开发人员选择与大量但有限数量的用户进行游戏测试。然后，问题和改进被记录下来进行抛光。开发人员使用了几种抛光安卓游戏的方法。我们将在本章讨论抛光的一般和广泛使用的方法和实践。

我们将详细讨论以下主题：

+   抛光要求

+   游戏测试

+   关注用户体验

+   安卓特定的抛光

+   游戏可移植性

# 抛光要求

抛光任何游戏都定义了开发的质量。因此，在将游戏发布到市场之前，抛光游戏是绝对必要的。抛光游戏在可见性、流畅性和用户体验方面比未经抛光的游戏表现得更好。

抛光安卓游戏涵盖游戏的所有三个开发组成部分：

+   开发抛光

+   美术抛光

+   设计抛光

## 开发抛光

抛光工程或游戏开发过程的技术方面，以改善游戏的流畅性为主要目标。这部分包括编程优化、内存优化和剥离不必要的代码块，以避免任何额外的处理。

开发抛光可以进一步分为三个阶段：

+   内存优化

+   性能优化

+   可移植性

### 内存优化

我们已经在上一章中详细讨论了内存优化。内存优化确保游戏以最少的内存使用运行。在某种程度上，它有助于增加设备支持和游戏稳定性。一个好的游戏必须具有优秀的内存管理，以便即使内存容量有限，也能平稳运行。

### 性能优化

性能优化确保游戏在每个目标安卓设备上都能平稳运行。然而，并不总是可能在所有设备上测试这种流畅性。大多数情况下，开发人员选择几个几乎等同于其他目标设备的设备来测试游戏。

### 可移植性

多分辨率支持和多平台支持也是开发抛光的一部分。因此，游戏可以以最小的努力达到最大可能的受众。对于许多安卓游戏来说，可移植性可能是成功的关键。

## 美术抛光

在这个阶段进行游戏美术的抛光。抛光游戏美术的主要目标是在相同的美术空间内提供更好的视觉质量。

游戏美术是游戏的最初推动力。因此，游戏美术的抛光可能会在市场上创造或毁灭游戏的未来。特别是对于安卓来说，在市场上有各种不同视觉质量的设备变化，游戏美术的抛光变得极为有用。

美术抛光主要分为三个阶段：

+   UI 抛光

+   动画抛光

+   营销图形

### UI 抛光

UI 推动游戏流程。因此，UI 美术应该轻松传达用户在游戏中漫游的期望路径。因此，相应地抛光 UI 美术是绝对必要的。

### 动画打磨

几乎每个游戏都使用动画来实现各种目的。打磨动画意味着增加视觉效果，让用户从开发者的角度看游戏。主要用于体育游戏、FPS 和 RPG，动画是不可避免的。动画决定了游戏玩法的性格。

### 营销图形

当涉及到游戏时，营销资产是首先被可视化的东西。它们制造了炒作和兴趣，让用户开始玩游戏。如果营销艺术不足以吸引用户玩游戏，那么可能会有相当大的损失，无论实际游戏质量如何。

## 设计打磨

设计是一个预制阶段，并且可以在生产过程中进行改进的一般概念。然而，重要的是在开发后完善设计，以便最终应用程序可以提高质量。它有五个阶段：

+   设计用户体验

+   打磨游戏流程

+   打磨元游戏

+   游戏经济平衡

+   游戏难度平衡

### 设计用户体验

用户体验是用户从用户角度看游戏的整体游玩和浏览体验。有几种情况下，游戏由于用户体验设计不佳而未能留住用户。因此，UX 必须通过实际用户行为的帮助进行打磨。

### 打磨游戏流程

在游戏开发过程中，游戏流程可能包含一些不必要的循环或操作。用户应该以最少的操作获得游戏的最大体验。每个操作都应该足够简化，以便用户在没有任何教程的情况下理解。然而，将游戏流程简化到那个水平并不总是可能的。但它应该足够简化，以便易于理解。

### 打磨元游戏

元游戏基本上是核心游戏玩法的容器或包装。打磨元游戏意味着打磨包装，使游戏对用户更有趣和吸引力。元游戏也负责货币化。因此，非常精心打磨的元游戏增加了成功的收入机会。

### 游戏经济平衡

许多开发者通常会在元游戏打磨的同时打磨经济平衡。然而，根据核心游戏模型，有许多方面需要分别注意。几乎每个游戏都与经济相关。这一方面应该在整个游戏过程中保持平衡，以使用户保持活跃并给他们一种进步的感觉。

### 游戏难度平衡

正如他们所说，一只手上的所有手指都不一样。同样，用户效率也不一样。它最有可能会变化，并反映在游戏排行榜上。因此，游戏的难度应该平衡，以便几乎每个玩家都有机会继续玩游戏。

# 游戏测试

游戏测试是规划游戏打磨的一部分。游戏测试是在游戏根据最初设计制作完成后进行的。它基本上揭示了整个游戏过程中的用户行为。

以下是游戏测试期间的探索领域：

+   用户游戏难度水平

+   用户在游戏过程中的操作

+   用户在浏览游戏时的操作

+   用户是否付费

+   游戏是否运行顺畅

+   用户是否能够接受游戏玩法

+   用户留存

游戏测试是计划在有针对性的一小群用户中进行的。通常，开发者会在特定地区发布游戏的测试版进行游戏测试。前述观点基本上是游戏测试的优势。进行这种行为的唯一缺点是，由于初始游戏计划不佳，开发者可能会失去一些游戏测试地区的受众，但这在游戏测试后可以改进。因此，建议您在进行游戏测试之前完成具有最初阶段规划的完整游戏体验，并使游戏发布准备就绪。

## 用户游戏难度水平

游戏的难度方面因游戏设计和核心玩法而异。同一款游戏的所有用户在玩游戏时并不都同样高效。游戏测试揭示了用户在玩游戏时所面临的困难。

在收集了游戏测试结果的数据后，游戏平衡得到改进。这直接影响游戏的打磨。

## 用户在游戏过程中的操作

这一部分通常揭示了用户对游戏操作的使用。例如，它揭示了游戏机制是否支持少量游戏控制，如滑动、点击不同按钮、选择选项等。开发者在游戏测试期间收集所有这些数据。甚至每个动作的反应时间也可能被考虑。

根据这些数据，开发者可以了解游戏控制的便捷程度。用户是否能正确使用控制决定了游戏的成功与否。有时，如果开发者在用户操作方面遇到严重问题，他们会改变游戏控制。

## 用户在浏览游戏时的操作

在游戏测试阶段记录了用户在 UI 浏览期间的所有操作。游戏的 UI 流程和导航风格在整个过程中得到验证。有时，用户可能会忽略 UI 的某个部分。对于开发者来说，很难从用户的角度识别出这样的 UI 部分，尽管开发者可以轻松地浏览这些部分，因为他们自己已经实现了这些 UI 部分。这种情况表明，被相当数量的用户忽略的 UI 部分并没有得到足够的突出。

UI 中可能有几个不是主要游戏流程的直接部分，比如排行榜、优惠墙、成就、帮助、设置、IAP 屏幕、次要游戏模式等。如果用户长时间不访问这样的 UI 部分，而开发者无法预测到这一点，那么开发者可能会选择改变 UI 风格或找到替代解决方案。元游戏的成功大部分取决于这种打磨。游戏货币化也可以得到很大的改善。

## 用户是否付费与否

有几种游戏货币化模式可供选择。基本的三种类型是高级、免费和免费增值。开发者采用任何模式来为游戏产生收入。

顾名思义，高级游戏基本上是付费游戏。这意味着用户在第一次购买时就购买了整个游戏。因此，在这种情况下，用户在玩游戏时不需要付费。免费游戏完全免费玩，没有任何付费以获得任何优势的规定。开发者可以通过游戏广告计划收入。用户在开始玩游戏后有选择支付的选项。开发者设计元游戏使用户为了获得优势或增加游戏进度而支付游戏。

在游戏测试阶段，开发者监控用户是否为游戏付费。在免费增值模式中，开发者定义用户应付费以更快或更顺畅地进展的阶段。通过游戏测试验证这一计划以预测未来的收入。

## 游戏是否运行流畅

正如我们之前已经讨论过的，从优化的角度来看，流畅的游戏玩法是游戏打磨的主要部分之一。初始测试是在少数限制设备上进行的。然而，在游戏测试的情况下，更可靠的是专注于实时场景和真实设备以验证流畅的游戏玩法。然而，Android 上有各种硬件配置。开发者必须在游戏测试之前决定测试配置并设定基准。

开发者可以通过游戏测试记录实时 FPS、崩溃和其他性能数据。然后进一步优化游戏以达到目标可玩性。

## 用户是否能适应游戏玩法

并非每款游戏都容易理解。用户通常不会花时间去阅读单独的游戏说明部分来理解游戏，这是已经被证实的常见行为。相反，他们直接跳入游戏玩耍。因此，普通用户通常需要相当长的时间来理解游戏玩法。

一些开发者使用交互式教程来帮助用户理解游戏控制、玩法和游戏目标。有时，完成交互式教程才能继续游戏。这是解决问题的最佳方案。

然而，设计交互式教程的方式有很多种。游戏可能无法通过设计不佳的教程来理解。无法预测用户适应游戏玩法所需的时间。因此，通过游戏测试来了解用户是否在计划的时间内理解了游戏变得非常重要。这对用户留存有很大的影响。

## 用户留存

用户留存预测直接关联着游戏收入的预测，这代表着游戏的商业成功。如果用户第一次玩游戏后就再也不回来，那就意味着用户没有被留存。用户留存有几个部分：日留存、周留存、月留存等。

在游戏测试阶段，开发者会统计重复玩游戏的用户数量以及离开游戏的用户数量。开发者甚至会收集有关用户离开游戏的时间和具体点的数据。这可能揭示游戏模型存在问题。这个问题可以被纠正以留住更多的用户。

# 关注用户体验

游戏质量方面，用户体验（UX）是最重要的考虑因素。因此，对游戏的 UX 进行精细打磨变得极为必要。

我们可以将 UX 的打磨分为以下几个类别：

+   视觉效果

+   音效

+   交易效果

+   动作反馈

## 视觉效果

游戏的用户体验主要是视觉的。因此，每个视觉效果都为游戏增加了一层打磨，提高了体验质量。有几种类型的用户。视觉效果确保了用户的参与。基本上，打磨视觉效果意味着每个动作反馈都应该是视觉的。

例如，有一些用户可能是色盲。对于他们来说，仅有颜色视觉是不够的。通过引入具有不同形状的物体的视觉效果或其他动作，可以改善这种情况。

## 音效

声音定义了游戏的情绪。声音设计师根据游戏类型设计声音。有两种不同类型的音效：

+   主题音乐

+   SFX

### 主题音乐

主题音乐是持续循环播放的音乐。它为游戏创造了一种氛围。大多数情况下，它增强了游戏玩耍或浏览 UI 时的乐趣。一个好的游戏必须有一个与游戏相配的主题。

### SFX

SFX 是基于事件的声音，可以针对游戏中的特定动作或事件进行指定。SFX 的一些常见用途包括按钮点击、用户操作、游戏胜利、游戏失败、游戏开始等。

## 交易效果

大多数游戏有多个阶段的动作。主要的交易是各个阶段之间的交易。更流畅的交易效果会带来更好的用户体验，因为用户对游戏流程有清晰的了解。

还可能有其他交易。例如，如果游戏支持游戏内货币系统，那就必须有货币交易。大多数情况下，用户不会注意数字和文本的变化。然而，可见的交易会让用户注意到这些数字。

## 动作反馈

现在有许多游戏严格遵循动作反馈系统。用户的每个操作都应该有反馈。反馈可以是视觉的、声音的，或者两者兼有。更显著的反馈会带来更好的用户体验。

# 安卓特定的优化

安卓有一套特定的功能和限制。这为安卓特定的优化打开了可能性。这可以在以下安卓平台和设备的功能或限制上完成：

+   充分利用硬件按钮

+   坚持基本的安卓功能和功能

+   更长时间的后台运行

+   遵循谷歌 Play 商店效率指南

## 充分利用硬件按钮

典型的安卓手机或平板设备有以下按钮：

+   主页按钮

+   返回按钮

+   菜单按钮

+   音量增加按钮

+   音量减按钮

+   锁定/解锁/电源按钮

每个按钮都有基于安卓标准的功能。在游戏中使用这些按钮来实现完全相同的功能是一种良好的做法。

例如，按下返回按钮应该将用户带回到游戏的上一个屏幕或上一个状态。在游戏中最常见的使用返回按钮的方式是暂停游戏循环。同样，音量增加/减少按钮应该直接影响游戏声音，符合原生功能。

## 坚持基本的安卓功能和功能

在安卓游戏中实现基本的安卓功能并使用安卓特定功能是一种良好的做法。我们刚刚谈到了在安卓设备上使用设备按钮。

从功能的角度来看，安卓标准功能支持从游戏本身中退出游戏应用。与 iOS 不同，安卓游戏可以被退出。

## 更长时间的后台运行

用户通常不总是以传统方式退出游戏。相反，主页按钮被用来快速退出游戏。在这种情况下，游戏会进入后台并继续运行，除非用户恢复游戏或操作系统终止进程。游戏可以在后台停留的时间越长，游戏恢复的速度就越快。

主要是，使用低内存和低进程开销可以增加游戏在后台持续存在的时间。有时可能会有几次中断。在这种情况下，最好的做法是恢复到相同的状态，以获得更好的用户体验。

## 遵循谷歌 Play 商店效率指南

尽管安卓是一个开放源代码平台，但谷歌对安卓应用有一些指南；这些也适用于游戏。显然，谷歌 Play 商店是目前市场上吸引全球观众的最大平台。因此，遵循他们的指南以获得推荐总是明智的决定。

谷歌 Play 商店上有数百万款应用程序。如果没有被推荐，要吸引用户去玩某个特定的游戏或应用程序是非常困难的。

# 游戏可移植性

优化是最好的阶段，游戏可移植性应该在不影响游戏本身的情况下最大化。在这个阶段，可通过以下三种方式增加可移植性：

+   支持各种屏幕尺寸

+   支持多种分辨率

+   支持多种硬件配置

## 支持各种屏幕尺寸

安卓在屏幕尺寸方面有很多变化。游戏控制系统是受不同尺寸影响最大的部分。设计游戏时，控制系统也应根据用户的便利性进行规划。

对于安卓手机游戏开发，安卓平板控件通常与安卓手机控件有所不同。平板的屏幕尺寸通常比手机大。因此，用户可以使用更多的空间。游戏应该针对小屏幕和大屏幕情况进行优化，以便更容易控制。

## 支持多种分辨率

相比之下，有一些安卓设备具有相同的屏幕尺寸，但分辨率不同。在这种情况下，主要的区别在于可见性。因此，支持多种分辨率设备需要更多的艺术技巧。

许多开发人员使用不同的艺术资源来支持不同分辨率的设备。我们已经讨论了安卓中不同分辨率的 dpi。因此，可以检测设备分辨率并相应地使用艺术资源。

特别是对于谷歌 Play 商店的游戏，谷歌支持在同一个应用下使用四种不同的应用程序包。因此，开发人员可以灵活地为同一个游戏创建和使用四个不同的 APK。然而，还有更多的分辨率。因此，还有其他几种方法可以实现它们。

集成游戏特定服务器是完成工作的最流行的方式之一。开发人员不会在 APK 中包含大部分艺术资源。相反，他们将不同分辨率的不同艺术包放在游戏特定服务器上。因此，游戏可以在需要时下载特定分辨率的资源。通过这种方式，开发人员设法将 APK 大小保持在最小限度。

## 支持多种硬件配置

单个游戏无法在每个硬件平台上产生相同的视觉和性能影响。游戏开发人员努力保持一定的标准，以确保游戏在多种配置上平稳运行。

有时，游戏会专门针对某些硬件平台进行优化。这种优化的常见例子是处理器架构。我们已经讨论了安卓游戏中使用的各种处理器架构。因此，游戏可以为单独的处理器架构进行移植。

支持尽可能多的硬件配置对于目标或获取用户非常重要。开发人员可能需要编写单独的代码来执行这样的游戏优化功能。

# 总结

游戏优化是游戏开发不可避免的一部分。然而，游戏的改进是没有限制的。开发人员应该计划优化阶段和变化，以支持并满足开发时间表。游戏优化帮助游戏获得更多用户，更多留存，并最终获得更多收入。一个经过精心打磨的游戏涵盖了本章讨论的每个部分。

游戏必须看起来好，感觉好，并且足够有趣以持续下去。最后但同样重要的是，它应该是高质量的，以便用户为之付费或推荐其他用户。游戏优化增加了游戏的寿命。它帮助开发人员规划更新和功能，并使用户在游戏中停留更长的时间。

到目前为止，我们已经涵盖了安卓游戏开发的几乎每个方面。然而，即使在开发游戏之后，开发人员也不能休息。有一些特定的参数需要满足才能使游戏成功。因此，开发人员必须在游戏中包含一些非游戏功能和功能。我们将深入探讨这些额外的第三方集成，并尝试在本书的最后一章中探索盈利技术。


# 第十三章：第三方集成、货币化和服务

Android 游戏开发或任何其他智能手机游戏开发都不完整，如果不实现后台服务。后台服务有助于游戏扩展和提升，达到更高的水平。

随着时间的推移，游戏开发的风格发生了很大变化。引入了新的风格和货币化技术。为支持这些技术，创建了新的游戏服务。许多科技公司开始推出自己的服务，以创建新的行业。我们所做的任何专业工作主要是为了谋生，游戏行业也不例外。然而，这个行业的目标是娱乐、乐趣和设备与用户之间的互动。开发人员通过这种方式赚钱。所有第三方集成和服务都有助于开发人员货币化游戏，直接或间接地增加收入。

服务可以是任何不特定于游戏的后台支持，可以改善游戏体验。大多数服务使用互联网和设备硬件和软件程序。大多数基于服务器的服务与应用程序一起工作，提供服务。

我们将通过以下主题在本章中详细了解这些方面：

+   Google Play 服务

+   多人游戏实现

+   分析工具

+   Android 应用内购买集成

+   Android 游戏内广告

+   货币化技术

+   规划游戏收入

+   用户获取技术

+   推出 Android 游戏

+   发布 Android 游戏

# Google Play 服务

Google 目前是 Android 应用的最大平台。此外，Google 是 Android 操作系统的所有者。因此，没有人比 Google 更适合成为 Android 平台的服务提供商。

Google Play 服务是为所有 Android 设备提供访问所有 Google 服务产品 API 的后台服务。它于 2012 年推出，以支持 Android 开发并将其提升到新的水平。

Google Play 服务包中最常用的服务有：

+   Google Analytics

+   Google IAB

+   Google 排行榜

+   推送通知

## Google Analytics

Google Analytics 是一种用于跟踪游戏中每一个事件的服务。这可以揭示用户行为、用户操作、每天玩游戏的用户数量、每个用户的游戏时间等。因此，开发人员不会错过任何数据。这些分析数据帮助开发人员识别游戏中的关键部分。借助这些帮助，开发人员可以改进游戏，提供更好的体验。

### 重要性

在测试或游戏测试阶段，通常无法追踪每个问题。当游戏规模变大，用户基数庞大时，更有可能暴露未知问题。Google Analytics 在这些领域有所帮助，不仅可以了解用户当前行为，还可以了解游戏性能。

### 集成技巧

Google Analytics 主要用于跟踪游戏事件。因此，跟踪事件必须非常谨慎地决定。触发点也必须以战略方式放置。开发人员可能不需要所有事件和行为数据。过多的跟踪甚至可能对应用程序有害，因为会使用更多数据并在游戏中进行更多处理。

开发人员应始终优先考虑事件。事件应基于游戏流程设计进行跟踪。然后应通过用户操作进行验证。

从货币化的角度来看，跟踪用户何时遇到付费墙或哪个部分被访问更多应始终是优先考虑的。在最受欢迎的部分放置简单的广告可能会增加应用的收入。

### 最佳利用

Google Analytics 工具的最佳利用方式与任何其他 Android 应用程序分析工具并无二致。这个工具是跟踪用户活动的最佳方式，通过数据，开发人员可以轻松预测用户对游戏的动机或意图。

## Google IAB

在现代游戏世界中，有许多货币化应用程序的方法。应用内计费是最受欢迎的方法之一。Google Play 服务配备了 Google 应用内计费工具。该工具直接与 Google Play 商店相关联。

通过这个工具，开发者可以在游戏内设计一些可购买的内容。对用户来说，从 Android 应用程序的内置商店购买非常容易。

### Google IAB 模型

让我们快速看一下 Google IAB 中的三种可购买选项。我们稍后将详细查看它们：

+   消耗品

+   不可消耗的物品

+   订阅

#### 消耗品

用户可以从商店多次购买此物品。Google 不跟踪这类物品。这类物品最常见的例子是游戏虚拟货币。许多游戏都围绕虚拟货币设计，大多数情况下，这个因素是游戏货币化的支柱。

#### 不可消耗的物品

它们基本上是用户的一次性购买。Google 始终跟踪用户通过 Google IAB 为任何应用程序所做的这些购买。即使用户卸载应用程序并重新安装，也可以将不可消耗的购买恢复到用户的账户中。

该类别下最常见的物品是游戏模式。在许多游戏中，有一些开放模式和一些可以购买。该系统还与试用和购买货币化方面合作。

#### 订阅

订阅基本上是一种基于时间的货币化模型。这主要用于典型的基于服务的应用程序，如音乐频道、电视频道、图书馆频道等。然而，很少有游戏使用订阅来实现货币化。

### 集成 Google IAB

Google Play 服务配备了 IAB API。开发者需要在 Google Play 商店上注册应用程序以获得实时访问权限。该系统使用称为 SKU 的项目 ID。每个 SKU 代表 Play 商店中的一个项目。开发者可能不会为特定游戏使用在 Google Play 账户中创建的所有 SKU。

### Google IAB 的优势和劣势

我们已经注意到，Google IAB 提供了一个在应用程序内实施直接数字购买系统的平台。这为开发者和消费者节省了大量的工作和时间。让我们快速看一下 Google IAB 的优势：

+   Google IAB 提供了一个直接的平台，可以在应用程序内购买应用程序组件或服务

+   Google IAB 简化了应用程序的货币化方面

+   Google IAB 为消费者提供了多种付款选项，方便快捷

+   Google IAB 存储和管理不可消耗物品的购买

+   Google IAB 具有无忧实施和出色的客户支持

+   易于退款流程完全由 Google IAB 管理

到目前为止，Google IAB 已经证明是开发者和消费者或用户的一个优秀系统。然而，Google IAB 仍然在一些领域落后。现在，让我们看看 Google IAB 需要改进的领域：

+   Google IAB 只通过 Google Play 服务提供计费服务

+   Google IAB 仍然不支持运营商计费

+   并非每个用户都愿意向 Google 提供信用卡信息

尽管存在这些问题，Google IAB 仍然是 Android 开发者最受欢迎的计费平台。Google 已经开始在 Google IAB 中包括运营商计费服务，这可能是最重要的功能。

## Google 排行榜

排行榜是游戏和类似竞技应用程序的平台，每个用户都可以在其他用户中跟踪自己的进度。排行榜已经证明是许多游戏的推动力。Google Play 服务配备了 Android 应用程序的内置排行榜系统。

### 意义

在游戏中集成排行榜总是一个加分项，因为它帮助用户即使在游戏不是多人游戏时也能相互竞争。人类心理是试图变得比其他人更优越。利用这个功能，可以比平常有更多的用户参与。然而，排行榜上的竞争标准必须谨慎选择。

排行榜驱动游戏的一个很好的例子是糖果传奇。用户非常活跃，玩这个简单的游戏以领先他们在排行榜上的朋友。

### 集成谷歌排行榜

没有单独的谷歌排行榜包。这可以通过集成谷歌游戏服务本身来包含。然而，排行榜必须在谷歌游戏账户中设置才能使用。

开发人员可以选择任何参数或计算来存储排行榜数据。谷歌排行榜支持来自单个游戏的多个排行榜的数据。大多数开发人员有效地使用这个功能来显示不同的领导者列表，取决于时间段、地区或其他一些定制参数。

### 各种排行榜

谷歌排行榜的主要变体有两种类型：

+   社交排行榜

+   公共排行榜

#### 社交排行榜

社交排行榜只列出与玩家圈子相连的玩家。对于这个功能，玩家必须登录他们各自的谷歌账户。这对于那些在同一个应用程序中玩并选择分享他们的活动的玩家有限制。

#### 公共排行榜

公共排行榜存储了选择公开发布分数的玩家的数据。否则，即使他们的分数比公共排行榜上的现有玩家更好，这些数据也不会被谷歌排行榜显示。

### 存储和显示排行榜的选项

排行榜存储可以分为两种类型，根据升序和降序。就谷歌排行榜而言，它们被称为：

+   越大越好

+   越小越好

分数始终是一个数字值，再次分为三种格式：

+   数字值格式

+   时间格式

+   货币格式

在数字值的情况下，开发人员可以指定小数点的位置。在时间格式的情况下，开发人员需要以毫秒传递分数，它将自动解释为*hh:mm:ss*格式。在货币格式的情况下，开发人员需要事先指定货币及其单位值。排行榜只接受单位值，并将其转换为指定的单位格式。

排行榜可以有独特的图标来显示或指示独特的排行榜。

## 推送通知

推送通知服务可以通过**谷歌云消息**（**GCM**）服务实现。让我们快速看一下云消息架构。

主要有四个组件用于使用 GCM 实现 Android 的推送通知：

+   数据库

+   服务器

+   目标设备

+   GCM 服务

### 数据库

数据库存储了客户或目标设备与 GCM 服务的注册详细信息。因此，每个设备只需要注册一次。相同的详细信息用于向注册的目标设备发送推送通知。

### 服务器

开发人员需要建立一个服务器来实现和控制推送通知。

### 目标设备

目标或客户设备是从 GCM 推送消息的平台。每个目标设备都有一个通过 GCM 的唯一注册 ID。没有注册，目标设备无法接收任何通知。

### GCM 服务

GCM 服务负责注册设备并向它们推送消息。服务器向 GCM 服务请求一组注册 ID 和定制消息。GCM 只负责将给定内容推送到指定设备：

![GCM 服务](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/andr-gm-dev-hb/img/B05069_13_01.jpg)

#### 使用 GCM 的推送通知系统的工作流程

现在，让我们讨论推送通知的工作流程。在前面的图表中，推送通知系统根据指示的索引（例如，**a**，**b**，**c**，等等）工作：

1.  **a**：客户端或目标设备请求 GCM 注册应用程序 ID 和发送者 ID。

1.  **b**：GCM 在成功注册后将注册 ID 发送回发送者。

1.  **c**：设备将注册 ID 发送到开发人员的服务器。

1.  **d**：服务器将注册 ID 存储到数据库中。

1.  **e**：开发人员启动具有自定义内容的推送通知的过程。

1.  **f**：服务器从数据库中获取注册 ID 列表。

1.  **g**：数据库提供所有注册 ID。

1.  **h**：服务器使用开发人员指定的内容和注册 ID 请求 GCM。

1.  **i**：GCM 根据其注册 ID 将相同的内容推送到相应的目标设备。

### 集成推送通知

集成推送通知分为三个步骤：

1.  应用集成

1.  GCM 设置

1.  服务器设置

#### 应用集成

开发人员需要为应用程序设置一个 GCM 客户端，这是 GCM 通信的媒介。以下是关于 GCM 通信服务的客户端开发的简要介绍。

它需要一组清单权限：

```kt
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.GET_ACCOUNTS" />
<uses-permission android:name="android.permission.WAKE_LOCK" />
<uses-permission android:name="com.google.android.c2dm.permission.RECEIVE" />
<permission android:name="com.example.gcm.permission.C2D_MESSAGE"
        android:protectionLevel="signature" />
<uses-permission android:name="com.example.gcm.permission.C2D_MESSAGE" />
```

清单还需要声明 GCM 接收器和 GCM 服务：

```kt
<receiver android:name="com.google.android.gms.gcm.GcmReceiver"
            android:exported="true" android:permission="com.google.android.c2dm.permission.SEND" >
<intent-filter>
<action android:name="com.google.android.c2dm.intent.REGISTRAION" />
<action android:name="com.google.android.c2dm.intent.RECEIVE" />
<category android:name="com.example.gcm" />
      </intent-filter>
</receiver>
<service android:name=".GcmService" android:exported="false">
      <intent-filter>
<action android:name="com.google.android.c2dm.intent.RECEIVE" />
      </intent-filter>
</service>
```

让我们看一下使用 GCM 注册应用程序的注册过程。注册可以通过许多方式进行，取决于开发风格。我们将在主要的 Android 活动中遵循最简单的流程，并存储应用程序的一次性注册 ID。

以下是所需的声明：

```kt
private final Context testContext = this;
private final String SENDER_ID = "<Application ID from Google developer console>";
private final String SHARED_PREF = "com.test.gcmclient_preferences";
private final String GCM_TOKEN = "testgcmtoken";
```

注册代码应放在`onCreate()`中：

```kt
SharedPreferences appPrefs = testContext.getSharedPreferences(SHARED_PREF, Context.MODE_PRIVATE);
String token = appPrefs.getString(GCM_TOKEN, "");
if (token.isEmpty()) 
{
  try 
  {
    InstanceID instanceID =  InstanceID.getInstance(testContext);
    token = instanceID.getToken(SENDER_ID,  GoogleCloudMessaging.INSTANCE_ID_SCOPE, null);
    if (token != null && !token.isEmpty()) 
    {
      SharedPreferences.Editor prefsEditor = appPrefs.edit();
      prefsEditor.putString(GCM_TOKEN, token);
      prefsEditor.apply();
    }
  }
  catch (Exception e) 
  {
    e.printStackTrace();
  }
}
```

现在，让我们定义`GCMService.java`来处理 GCM 消息：

```kt
public class GcmService extends GcmListenerService 
{
  @Override
  public void onMessageReceived(String from, Bundle data) 
  {
    JSONObject jsonObject = new JSONObject();
    Set<String> keys = data.keySet();
    for (String key : keys) 
    {
      try 
      {
        jsonObject.put(key, data.get(key));
      } 
      catch (JSONException e) 
      {
        e.printStackTrace();
      }
    }
    try 
    {
      sendNotification("Received: " + jsonObject.toString(5));
    } 
    catch (JSONException e) 
    {
      e.printStackTrace();
    }
  }

  @Override
  public void onDeletedMessages() 
  {
    Log.d("Message is deleted …");
  }

  @Override
  public void onMessageSent(String msgId) 
  {
    Log.d("Message is sent …" + msgId);
  }

  @Override
  public void onSendError(String msgId, String error) 
  {
    Log.d("Sending Error … Msg" + msgId);
    Log.d("Error …" + error);
  }
  private void sendNotification(final String msg) 
  {
    Log.d("Sending Msg …" + msg);
  }
}
```

#### GCM 设置

Google Play 服务带有 GCM 系统。必须从 Google API 控制台启用 GCM。每个注册的应用程序都有自己独特的应用程序 ID，这是配置推送通知系统所需的。

以下是启用 Android 项目的 GCM 的步骤：

1.  在 Google Cloud 平台上创建一个项目。

1.  使用 Google API 生成 API 密钥。

1.  为 Android 创建服务器密钥。

1.  为应用程序启用 GCM。

#### 服务器设置

通知服务器开发可以通过任何云连接服务器技术实现。开发人员需要通过满足以下标准来设置应用程序服务器：

+   应用服务器应该能够与应用程序进行通信

+   应用服务器应该能够向 GCM 连接服务器发送格式正确的请求

+   应用服务器应该能够处理应用程序请求并使用指数退避重新发送它们

+   应用服务器应该能够将 API 密钥和客户端注册令牌存储在安全的数据库中

### 推送通知的重要性

推送通知是现代游戏开发中不可避免的一部分。推送通知用于以下原因：

+   用户留存

+   用户控制

+   了解用户行为

+   替代通信渠道

#### 用户留存

推送通知为用户提供游戏的最新更新和信息。有许多情况下，用户下载游戏然后忘记了它。有时，用户中途离开游戏。推送通知帮助这些用户重新对游戏产生兴趣。这个过程提高了用户的留存率。

#### 用户控制

通过设备设置和通知中心，开发人员可以控制用户将看到的内容，并相应地引导用户。

#### 了解用户行为

使用用户控件，开发人员可以跟踪用户在通知上的行为。根据用户的行为，开发人员可以了解用户喜欢和不喜欢什么。

#### 替代通信渠道

与最终用户进行沟通的方式有很多种。大多数情况下，用户并不经常与开发者进行沟通。因此，单向通信渠道被证明是有效的。推送通知系统完美地适应了这一角色。这是传递有关游戏的最新消息、更新、优惠和功能的最佳媒介。在某些设计模型中，它可以用于向用户传递游戏状态信息。

# 多人游戏实施

曾经多人游戏局限于传统的个人电脑和游戏机。现代游戏产业广泛使用社交网络。这自动为多人游戏开辟了机会。

改进的硬件系统和现代连接的持续网络支持增强了多人游戏的世界。多人游戏主要可以分为两类：

+   实时多人游戏

+   回合制多人游戏

## 实时多人游戏

实时多人游戏就像一起进行体育比赛，每个玩家同时对游戏或其他玩家的任何行动做出反应。例如，足球比赛由 22 名球员进行，每个球员都会根据情况同时行动。如果我们从数字游戏的角度想象同样的情景，那就是实时多人游戏。

在多人游戏的一般结构中，应该有一个服务器，游戏运行其中并进行所有逻辑和计算。服务器在需要时与数据库交互，用户没有任何控制权。

客户端或终端设备是与用户交互的唯一媒介。然而，在许多情况下，客户端端会使用一些额外的层来执行一些操作，而无需服务器验证，以保持实时多人游戏的即时性。

让我们来看看实时多人游戏系统的一般架构：

![实时多人游戏](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/andr-gm-dev-hb/img/B05069_13_02.jpg)

实施实时多人游戏的最佳实践是在每个终端应用层引入同步层。这一层充当终端设备应用和服务器之间的媒介。

## 回合制多人游戏

回合制多人游戏是一种系统，只有一个玩家有机会一次玩游戏。例如，在国际象棋游戏中，当一个玩家轮到时，另一个玩家保持空闲。

一般来说，回合制多人游戏系统也是由服务器控制的。服务器可以是客户端之一。然而，执行层的工作如下图所示。许多时候，数据库也是架构的可选部分。服务器负责在特定终端设备上激活 UI 控制，并且只监听该设备。让我们来看看架构图：

![回合制多人游戏](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/andr-gm-dev-hb/img/B05069_13_03.jpg)

在安卓游戏中可能存在更多类型的多人游戏模型。到目前为止，我们只讨论了在互联网上实施的模型。在安卓中也可以进行本地多人游戏。我们可以将这些游戏分类为以下几类：

+   单屏实时多人游戏

+   传递和玩回合制多人游戏

+   本地网络多人游戏

## 单屏实时多人游戏

这种多人游戏依赖于硬件特性、其他配置和可行性。设备必须支持同时多个输入，以支持实时多人游戏。对于安卓触摸设备，建议开发者针对大屏设备，以提供更多的控制空间，同时支持多个玩家。

## 传递和玩回合制多人游戏

这是一种单屏幕回合制多人游戏模型。在这种模型中，所有参与者应该手动管理游戏顺序，以与游戏轮次同步。

在这里，一个玩家在玩完自己的回合后将同一设备交给下一个玩家。然后，下一个玩家根据游戏的当前状态做出反应。在这种模型中，游戏状态直到每个回合完成之前都不会改变。

在单屏多人游戏模型中，不需要网络连接，数据库是一个可选组件，可以存储在设备内存中。

## 本地网络多人游戏

实时和回合制多人游戏模型都可以使用本地网络连接来实现。在这种情况下，参与的设备之一必须充当服务器，并使用蓝牙、Wi-Fi 或红外连接控制本地网络连接上的游戏玩法。

# 分析工具

我们已经讨论了 Google Analytics。除了 Google 之外，还有其他几种分析服务。我们将从一个一般的角度讨论分析。

分析工具对游戏来说是不可避免的。它们帮助开发者更好地了解用户，直接影响游戏质量、用户留存和货币化。

## 分析工具的要求

多年来，开发者一直在以各种形式收集和分析用户数据。我们经常遇到关于许多产品的表格和分析调查。这些数据帮助开发者或制造商修改或改进产品。

让我们通过以下几点来看一下分析数据的种类及其重要性：

+   用户行为

+   游戏崩溃报告

+   游戏事件触发器

+   游戏会话时间

+   游戏频率

+   游戏平衡

+   用户留存

+   防盗版

### 用户行为

分析工具可以跟踪每个用户的每一个动作。这些数据可以进一步分析，并猜测用户在游戏中的行为。这种行为验证了应用程序或游戏的元设计。

### 游戏崩溃报告

几乎所有的分析工具都可以报告每次崩溃事件及其原因和位置。然而，游戏代码的编码包无法完全揭示位置，其中类和其成员以无意义的符号编码。

这有助于开发者识别玩游戏的设备以及崩溃的确切问题。

### 游戏事件触发器

开发者可以从游戏本身设置触发器来跟踪游戏的任何或每一个方面。这些可以是游戏内的任何事件。游戏开发者通常使用这种触发系统来启动游戏、结束游戏以及一些战略事件，比如 IAP、广告显示、模式选择（如果有的话）等。

### 游戏会话时间

分析工具通过触发应用程序进入前台或应用程序启动，以及应用程序进入后台或应用程序退出之间的两个事件来跟踪游戏时间。通过计算两者之间的时间，分析工具通知开发者用户在单个会话中在应用程序内的总时间。

### 游戏频率

这基本上是每个用户启动游戏的平均次数。因此，开发者可以通过数据增加或改进会话。开发者可以对给定时间的频率进行分类，比如每日频率、每周频率或每月频率。

### 游戏平衡

开发者可以收集用户得分和游戏时间的数据来检测每个玩家的难度。然后，开发者可以相应地平衡游戏。然而，每个玩家的能力和技能都不同。因此，开发者必须设定一些标准来全球平衡游戏。

### 用户留存

用户留存是开发者从游戏中产生收入最重要的方面之一。这意味着用户重复玩游戏的次数。用户留存也可以是基于时间的，比如每天、每周和每月。

### 防盗版

在安卓游戏中，可能存在高级或免费游戏模型。在这种模型中，用户用真实货币购买游戏或游戏内的一些组件。盗版对于许多黑客或追踪者来说是一种旧的做法。他们可以侵入支付系统或解码安全层，以免费提供付费游戏或付费组件。盗版对于开发者来说是一个在产生收入方面的主要问题。

分析工具可以检查游戏并提供用户详细信息以验证购买，从而增加额外的安全层以防止游戏盗版。

## 分析工具的货币化方面

分析工具在前面提到的所有点上都很有用。所有功能都直接或间接地与游戏收入相关。一些功能帮助开发者改进游戏质量，其余功能可以直接增加游戏收入，或者可以帮助开发者通过分析数据规划更多收入。

根据分析数据，开发者可以执行以下操作：

+   识别游戏的热门地区

+   识别用户的喜好和厌恶

+   验证和改进元游戏

+   跟踪付费用户

+   跟踪和计算广告显示

### 识别游戏的热门地区

识别游戏最受欢迎的地区有助于开发者通过广告或一些付费内容在某个地区规划更多收入。特别是对于免费或免费游戏，极其必要找到用户经常访问的游戏部分。

### 识别用户的喜好和厌恶

游戏可能有几个部分。用户可能喜欢其中一些，不喜欢其他部分。除非开发者发布游戏或对大量用户进行游戏测试，很难预测用户的喜好和厌恶。

通过分析数据，开发者可以轻松指出用户喜欢或不喜欢的部分。开发者可以改变策略或计划更好的游戏更新。

### 验证和改进元游戏

游戏通常有两个开发领域：游戏玩法和元游戏。元游戏设计是通过预测用户对模型的接受来完成的。只有分析工具可以在游戏发布后验证这一预测。

### 跟踪付费用户

开发者可以通过分析工具跟踪哪些用户遇到了付费墙，以及谁实际上为游戏付费。这些数据直接影响游戏收入。

### 跟踪和计算广告显示

开发者实际上可以跟踪广告调用和广告显示的次数。因此，更容易预测广告收入，开发者甚至可以计划更好地填充广告。

## 一些有用的分析工具

我们已经在 Google Play 服务下讨论了 Google 分析工具。市场上有许多与 Google Analytics 一样优秀的分析工具，可以作为替代的好选择。在使用分析工具方面，开发者没有限制。大多数工具都是免费且易于使用，开发者甚至可以集成多个工具以实现不同的目的。

让我们快速看一下这些工具：

+   **Flurry** ([`dev.flurry.com`](https://dev.flurry.com))

+   **GameAnalytics** ([`www.gameanalytics.com/`](http://www.gameanalytics.com/))

+   **Crashlytics** ([`fabric.io/kits/android/crashlytics`](https://fabric.io/kits/android/crashlytics))

+   **AppsFlyer** ([`www.appsflyer.com/`](https://www.appsflyer.com/))

+   **Apsalar** ([`support.apsalar.com/`](http://support.apsalar.com/))

+   **Mixpanel** ([`mixpanel.com/android-analytics/`](https://mixpanel.com/android-analytics/))

+   **Localytics** ([`docs.localytics.com/index.html`](https://docs.localytics.com/index.html))

+   **Appcelerator** ([`www.appcelerator.com/mobile-app-development-products/`](http://www.appcelerator.com/mobile-app-development-products/))

### Flurry

最受欢迎的游戏分析工具之一是 Flurry。Flurry 几乎具备用于分析目的的每一个功能。这款轻量级的 SDK 易于安装，开发者可以立即开始获取数据。

### GameAnalytics

GameAnalytics 是一款免费且功能强大的游戏开发者分析工具。它可以帮助您了解玩家行为，并通过动态仪表板上的分析数据构建更好的游戏。

### Crashlytics

Crashlytics 是最强大和高效的错误报告工具。它可以拦截任何错误和异常，并提供尽可能详细的信息。Crashlytics 对开发者来说是轻量级且易于使用的。

### AppsFlyer

AppsFlyer 是一个单一的实时仪表板，是一个带有分析功能的全能营销工具。它基本上使用 AppsFlyer 的**NativeTrackTM**来为游戏提供分析支持。

### Apsalar

Apsalar 主要用于广告归因。它可以很好地查看游戏营销的投资回报率。它还有助于找出哪些营销活动有效，哪些需要避免。他们还提供了一些出色的营销工具，比如**SmartTags**，可以为开发者提供更详细的营销分析。

### Mixpanel

Mixpanel 的好处主要是针对非技术人员，他们可以轻松创建自定义查询，而不需要了解 SQL。强大的界面允许开发人员对用户进行分段，并查看哪些部分对游戏效果最好。

### Localytics

Localytics 提供了大多数数据分析功能。该平台提供实时分析、再营销数据、归因等。Localytics 的消息功能与其他一般的分析工具不同。

### Appcelerator

Appcelerator 是一款用于移动应用测试、部署和分析的企业套件。该工具的基本功能是一个交互式的基于平板电脑的移动应用，可以在多个平台上使用，并立即提供对五个关键移动指标的洞察：留存、参与、采用、质量和转化。

# Android 应用内购买集成

应用内购买是一种功能，通过该功能可以使用多种支付网关从应用内购买应用的组件。这是 Android 游戏的主要货币化方面之一。

## 什么是应用内购买？

在现代游戏行业中，免费游戏正在蓬勃发展。这意味着用户可以免费玩游戏，但他们必须为某些组件或游戏进度优势付费。这种模式已被证明是成功的，因为它在数字游戏的免费和高级概念方面都得到了支持。

应用内购买完美地实现了这一目的。我们已经讨论了 Google 应用内结算服务，这只是通过 Google 进行应用内购买的手段。但还有其他支持相同功能的服务。

一般来说，游戏应该提供应用内购买项目，让用户选择购买以下类型的内容：

+   解锁游戏中的某些功能

+   购买某些物品以获得比其他玩家更大的优势

+   解锁游戏内的一些模式

+   增加游戏的易玩性

+   移除烦人的广告

有许多类型的用户对同一游戏有不同的要求和不同的技能。应用内购买为他们所有人提供了按照自己的便利玩游戏的机会，同时开发者也能赚一些钱。

## 应用内购买选项

您了解到 Google IAB 并不是 Android 应用内购买的唯一选择。还有一些其他具有几乎相同功能的选择。根据支付方式，有不同的服务类型。用户可能不会选择一种支付方式，但如果提供了几种选择，那么购买的机会肯定会增加。

为用户提供尽可能多的支付选项始终是一个好习惯。出于以下原因，需要多种购买选项：

+   并非所有用户都可能有信用卡

+   并非所有用户都可能有借记卡

+   并非所有用户都可能激活网上银行

+   并非所有用户都有足够的通话时间余额

+   并非所有用户都喜欢直接使用真实货币

开发人员应该提供尽可能多的选项来解决这些问题，让用户使用真实现金进行游戏。目前，可用的计费服务支持多种支付方式，但我们可以将这些服务分类为两个主要部分：

+   商店计费服务

+   运营计费服务

### 商店计费服务

商店计费服务是基于用户下载游戏的商店。游戏应该连接到一个提供了 API 的商店才能访问这个功能。我们已经讨论过，Google IAB 是一种商店计费服务，包括多种支付方式，包括信用卡、借记卡、选择性运营计费等。

然而，Google IAB 并不是唯一可用的商店计费服务。除了 Google 之外，最值得一提的商店计费是亚马逊计费服务，它提供了几乎与 Google 相同的功能。

#### 亚马逊计费服务

亚马逊计费服务的工作方式与 Google IAB 完全相同。但是，API 和集成与 Google IAB 略有不同。

开发人员需要包括`com.amazon.device.iap`包来集成亚马逊 IAP。这个过程主要有三个组成部分：

+   `ResponseReceiver`

+   `PurchasingService`

+   `PurchasingListener`

##### 响应接收器

亚马逊 IAP 是一个异步过程。它作为一个后台服务运行，需要实现一个响应接收器。开发人员需要在清单文件中声明接收器。

##### PurchasingService

`PurchasingService`类用于检索有关用户的各种信息，执行购买，并通知亚马逊购买服务有关购买完成的信息。

##### PurchasingListener

`PurchasingListener`接口用于处理来自亚马逊服务器的异步回调。应用的 UI 线程处理所有回调，因此开发人员应该在 UI 线程上检查运行的进程。

从功能和集成的角度看，亚马逊 IAP 与 Google 类似。还有其他商店可能支持自己的计费服务。还有另一种选择，就是实现开发者自己的支付门户。然而，大多数安卓游戏开发者更倾向于使用主流的计费服务。

### 运营计费服务

一些游戏开发者使用运营计费服务进行货币化。运营计费意味着用户通过其手机余额向开发者支付应用内产品。这个手机余额由连接提供商管理。

目前，Google IAB 已开始在商店计费中支持运营计费。

## 应用内购买的类型

开发人员主要可以设计他们的 IAP 产品为三种类型。这些产品的类型取决于游戏设计和游戏类型。这些类型是：

+   可消耗物品

+   非消耗品

+   订阅

### 可消耗物品

这些物品是用于在应用内消耗的。在 Google IAB 的情况下，这些产品被称为非托管产品。

计费服务提供商不会跟踪用户对这些物品的消耗。大多数情况下，游戏内货币、增强道具、额外生命等是这类产品的主要类型。用户可以多次购买同一物品。

可消耗物品必须在计费服务器上定义，以便让计费服务理解。

### 非消耗品

非消耗品是指使用后不会过期的物品。计费服务器会跟踪这些购买。

当用户购买这种类型的物品并卸载应用后，重新安装应用时，这些购买可以被检索到。这意味着用户只需要在应用的整个生命周期内购买这个产品一次。

### 订阅

这是购买应用内某些功能的时间或可用性。在游戏中，订阅的用途非常有限。然而，这是一个为有限的时间或使用提供某些功能或服务的好选择。

在持续时间内，用户可能不会购买相同的物品，但是有一个可再生的功能，允许用户在服务期限到期后再次订阅相同的东西。

# 安卓游戏内广告

游戏内广告对于免费和付费游戏的货币化来说是最重要的因素。开发者利用他们的游戏平台展示广告以产生收入。

它是如何运作的：

1.  广告商向各种广告代理提交广告。

1.  每个广告都有一个特定的价值和时间限制，分别称为广告活动成本和广告活动时间。

1.  开发者与这些代理订阅。

1.  开发者集成代理广告平台以包括和展示广告。

1.  开发者设定广告类型、流派和级别的参数。

1.  当应用程序向代理服务器发出广告请求时，它会寻找符合开发者预定义标准的可用或正在运行的广告活动。

1.  在成功匹配后，服务器会将广告元素发送到客户端应用程序。

1.  应用程序加载广告。

1.  应用程序根据请求展示广告。

1.  服务器会记录成功展示广告的次数，并根据广告活动成本计算收入。

1.  开发者在满足代理的一定标准后收到收入。

## 广告要求

完全免费的游戏除了广告或赞助之外没有任何收入来源。我们只会在这里看广告。让我们了解游戏内广告的要求。

我们都在努力谋生。安卓是一个开源平台，大部分用户都是免费用户。这意味着开发者只剩下一个选择。与其他货币化方面相比，广告是一个可以依赖的好平台。

作为一个行业，广告已经存在很久，并且在市场上证明了它的可持续性。游戏内推广只是展示广告的另一种方式。这样一来，对于开发者和广告商来说总是双赢的局面。

## 广告货币化术语

现在，我们将讨论典型的游戏广告平台。开发者需要熟悉一些术语，以适应游戏内广告：

+   eCPM

+   CPC/CPA

+   CPI

+   RPM

+   填充率

### eCPM

**eCPM**代表**有效每千次展示成本**，它是通过广告横幅或广告活动产生的广告收入计算得出的结果，除以该横幅或广告活动的广告展示次数，以 1,000 为单位表示，最后用字母*M*表示。

### CPC/CPA

**CPC**代表**每次点击成本**，这意味着开发者会在用户点击展示的广告时赚取一定金额。**CPA**代表**每次行动成本**，与 CPC 类似。

### CPI

**CPI**代表**每次展示成本**，这意味着开发者会在应用程序内成功展示任何广告时赚取一定金额。一般来说，这些收入低于 CPC。

### RPM

**RPM**代表**每千次展示收入**。它表示从一千次插页广告中产生的总收入。RPM 包括所有类型的收入模式。RPM 由以下公式计算：

*RPM = (总收入) / (广告展示次数 / 1000)*

### 填充率

**填充率**是服务器成功展示广告的百分比。我们已经知道应用程序向广告服务器请求广告。这被称为“请求”。如果服务器成功地根据请求展示广告，那么广告被称为“展示”。所以我们有了我们的填充率，如下：

*填充率 = (展示次数/请求次数)*100%*

## 广告类型

有几种广告样式可以用于安卓游戏：

+   横幅广告

+   插页广告

+   视频广告

+   游戏内动态广告

### 横幅广告

横幅广告通常是具有持续显示功能的广告，用户无法关闭或隐藏。然而，CPI 的广告活动价值很低，但 CPC 是可以接受的。许多开发者现在避免使用横幅广告，因为它占据了游戏屏幕的大部分空间。横幅广告以给定的矩形形状显示在可见显示的边缘。

可能的横幅显示位置如下：

+   左上角

+   顶部中心

+   右上角

+   底部左侧

+   底部中心

+   右下角

根据当前情况的尺寸变化如下表所示：

| 横幅类型 | 目标 | 像素尺寸 |
| --- | --- | --- |
| 标准横幅 | 手机和平板电脑 | 320 x 50 |
| 大横幅 | 手机和平板电脑 | 320 x 100 |
| IAB 全尺寸横幅 | 平板电脑 | 468 x 60 |
| IAB 排行榜 | 平板电脑 | 728 x 90 |
| 智能横幅 | 手机和平板电脑 | 屏幕宽度 x 32 屏幕宽度 x 50 屏幕宽度 x 90 |

### 插页广告

插页广告是基于各种广告活动的全屏可点击图像广告。通常，插页广告有一个定义的关闭按钮，供用户关闭广告并返回游戏。

当插页广告显示时，广告视图会置于前景，将主游戏视图推到后台。因此，每次游戏线程触发中断时都会显示广告。

这种类型的广告在游戏中被广泛使用，因为可以产生可观的收入。游戏货币化设计在插页广告中起着重要作用。每个广告位置都必须基于分析数据进行战略性安排。

#### 整合最佳实践

整合插页广告应遵循一些逻辑的广告显示周期：

![整合最佳实践](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/andr-gm-dev-hb/img/B05069_13_04.jpg)

遵循这个周期总是一个好的做法。广告应在显示之前加载并处于就绪状态。关闭广告后，下一个广告应立即加载以避免加载延迟。

### 视频广告

视频广告是最新的收入生成程序之一。这种类型的广告具有最高费率。然而，视频广告的可用性相对较少，比图像插页广告少。有两种类型的广告：

+   全长广告

+   短长度广告

#### 全长广告

全长广告通常较长。这种类型的广告通常是可跳过的，提供了一定时间后跳过的选项。

#### 短长度广告

短长度广告相对较小，没有跳过选项。

### 游戏内动态广告

这个概念提供了在预定义位置和大小内显示任何可用广告横幅的选项。无论实际广告尺寸如何，该机制都会将广告调整为应用程序中给定的尺寸。

# 货币化技术

货币化基本上是从任何应用程序中生成收入的系统或策略。开发者需要根据游戏需求决定他们的游戏货币化模式。我们可以将这些模式分类为四类：

+   高级模式

+   免费模式

+   免费模式

+   试玩购买模式

## 高级模式

这是典型的先付费后玩模式。用户需要在下载游戏之前付费。通常，这些游戏没有应用内购买或游戏内广告。这只是用户购买游戏玩法的一次性费用，通常所有用户都有相同的游戏进度机会。

## 免费模式

这种模式提供免费游戏，但可能包括游戏内广告以产生收入。用户可以免费玩完整的游戏，但对于任何操作都没有额外特权。

## 免费模式

这种模式提供免费游戏，游戏可以完全免费玩，不需要花费任何真实货币。然而，这种模式提供应用内购买，以提供额外内容或游戏进度的便利。

## 试玩购买模式

这个模型已经存在多年了。然而，很少有开发者喜欢使用这个模型。开发者创建了相同游戏的不同特性的独立版本。

免费版本通常具有有限的内容或有限的使用。这个版本可能包含广告，也可能不包含广告。游戏的完整版本通常遵循典型的高级游戏模型。有时，开发者在免费版本的游戏中使用应用内购买来解锁完整版本，这是一种聪明的做法，因为它消除了创建和管理两个不同应用程序的麻烦。

# 规划游戏收入

就我们讨论的范围而言，我们对游戏收入的产生有了一个公平的了解。游戏开发者不能一直开发游戏而不产生收入或没有强大的财务支持。现在让我们讨论游戏规划，以便让开发者继续开发游戏。

## 收入与利润

大多数新的游戏开发者不知道收入和利润是两回事。

收入是游戏直接从用户那里产生的总金额。制作游戏可能会花费开发者一些钱，而每个第三方媒介可能会收取一定比例的收入或某些服务的费用。在支付所有必要的款项和分成后，剩下的金额被称为利润。因此，高收入并不意味着高利润。

然而，没有产生收入，就不可能有任何利润。因此，开发者必须规划收入以产生利润。

## 收入来源

现在，我们知道产生收入是必要的。为了产生收入，开发者必须了解可能的收入来源。我们将在这里讨论主要的来源：

+   广告收入

+   应用内购买收入

+   其他来源

### 广告收入

特别是对于免费和免费游戏，广告是主要的收入来源之一。有很多广告代理通过广告服务器提供广告。不同的广告活动可能有不同的价值。

还有另一个平台叫做广告调解。这个平台提供来自不同代理的广告。有时，这个平台有助于找到可用广告中的最高价格。这个特殊功能被称为实时竞价。

### 应用内购买收入

这是主要用于免费游戏模型的一种产生收入的方式。开发者免费提供游戏，但某些内容和功能被锁在游戏内。一旦用户习惯了游戏并愿意花额外的钱来加强游戏的控制力，他们就会使用应用内购买。

通过应用内购买规划收入完全取决于游戏设计和市场行为。一些游戏模型需要内容，一些需要功能，而一些则需要两者兼具。

应用内购买可以通过几种计费和购买服务进行，我们已经讨论过。然而，选择特定的服务可能会影响收入的产生。因此，开发者在与计费服务提供商签约之前应始终研究市场趋势。

### 其他收入来源

除了广告和应用内购买之外，还有其他收入来源。Offerwall 和优惠券系统是另外两个选择。开发者可能选择品牌和赞助来为游戏赚更多的钱。然而，从一般的角度来看，这些并不是收入来源的手段。

随着行业的现代化，可能会出现新的收入来源，以帮助开发者成长并制作更好的游戏。

## 区域收入计划的变化

有几种类型的用户。大多数情况下，游戏行业市场因地区、年龄组和性别而异。如果开发者计划增加收入，那么他们必须在收入计划中考虑这些因素。

然而，并不总是可能同时或在一个单一计划中使用所有这些因素。目前，行业中的开发者大多根据地区的基础变化收入计划。市场已经确定，用户行为在很大程度上取决于地区。

例如，亚洲用户的行为可能与非洲或美洲用户不同，他们的消费能力也不同。因此，开发者应该根据用户的消费能力和消费行为来规划游戏收入。在一些地区，用户不愿意用真钱支付。在这种情况下，开发者必须采取不同的方法来产生收入。

### 用户群体变化

正如我们已经说过的，用户群体因地区而异。例如，赛车是世界各地平均玩得最多的游戏类型之一。然而，产生收入并不相同。在许多地区，人们更看重时间而不是金钱，而在其他地区可能相反。因此，如果赛车游戏内的购买元素可以帮助用户节省一些时间来进行游戏进度，这在所有地区可能都不起作用。有些人喜欢花更多时间来实现进度，而不愿意付费。开发者必须有一个计划，通过某种方式将游戏时间转化为收入。

### 用户行为变化

世界各地的典型用户行为数据显示出很大的变化。其中一个主要的变化是游戏类型。例如，板球在一些国家或地区是非常著名和热门的游戏类型，那些地方的人们对这项运动有专业、心理或感情上的联系。在美洲地区，这项运动并不受到太多欣赏。同样的行为，在亚洲人中棒球也不那么受欢迎。开发者应该始终分析最大可能用户的用户行为数据，以规划从游戏中获得最大收入。

# 用户获取技术

如果一个游戏没有用户，那就和废品一样。这并不意味着游戏质量或设计不好。在安卓游戏市场上，已经发布了超过 500 万款游戏。每天都有数百款游戏发布，这加剧了竞争。

在这个庞大的群体中，一个游戏可能会消失，不管它的质量如何，都是因为没有或者有很差的营销策略。一个游戏只有在拥有大量用户和良好的留存率时才能成功。

让我们通过以下主题来看一下用户获取技术：

+   游戏推广渠道

+   游戏博客和论坛讨论

+   付费用户获取

+   其他技术

## 游戏推广渠道

有几种方法可以在市场上推广游戏。有一些游戏推广渠道在各种媒介上做广告。特定的游戏类型频道推广相同类型的游戏。让我们看看其中的一些媒介：

+   YouTube 频道

+   安卓论坛

+   体育论坛

+   Facebook 推广

+   Twitter 和其他社交平台

### YouTube 频道

有几个 YouTube 频道对安卓游戏进行评测和推广。许多用户关注特定频道以寻找更好的游戏。开发者可以通过这些频道来推广他们的游戏，让用户了解游戏。

从这些频道得到的良好的游戏评价可以为开发者带来大量用户。然而，这些频道可能会向开发者收费来评测他们的游戏。从这些频道可能会找到成千上万的用户。

### 安卓论坛

有数百个安卓论坛可供选择，有成千上万的活跃参与者在讨论游戏、应用、开发风格和标准等。这些论坛也是推广安卓游戏的好平台。然而，开发者应该具体到话题，游戏应该有被讨论的潜力。通过这些渠道可以获得几百名用户。

如果开发者使用了任何安卓特有的特性，并通过技术实现了一些新的东西，这些论坛是一个很好的途径，可以接触到对技术热衷并渴望新实现的用户。

### 体育论坛

有许多针对特定运动的论坛。这种方法主要适用于体育类游戏。开发者应该与论坛的其他成员讨论同一运动的游戏。例如，如果开发者制作了一款板球游戏，那么游戏应该通过板球论坛进行发布和推广。

这种方法有一个额外的优势。由于论坛是针对同一运动的，开发者可能会找到一些对该运动有专业知识的人，他们可以分享对游戏的宝贵意见，这可能会使游戏变得更好。

### Facebook 推广

Facebook 目前是最大的社交平台，拥有数十亿用户。开发者通常使用这个平台来推广游戏。社交网络可以为游戏找到大量用户。

每款游戏都应该有一个由开发者妥善维护的页面。这个页面是用户和开发者之间的沟通媒介之一。这样的页面可以用来讨论游戏的特点和元素，以便新用户在开始玩游戏之前就对游戏有一个很好的了解。

### Twitter 和其他社交平台

Twitter 和其他社交平台也对游戏推广和增加用户群体有用。及时发布关于游戏更新和特点的推文可以帮助增加用户数量。

社交平台不一定是数字或网络平台。它可以是任何东西，比如现实生活中的社交活动。许多开发者组织活动来展示他们的游戏，或者参加各种活动和比赛以获得认可。对于一款好游戏的良好认可可以帮助获得更多用户。

## 游戏博客和论坛讨论

游戏博客和为开发的游戏创建论坛可以帮助获取用户。然而，这种技术在游戏发展出一个体面的用户群体之后才会起作用，这样就会有大量的人参与讨论。

开发者可以为游戏创建一个游戏博客，用户可以在博客上分享他们对游戏的意见、批评或建议。这可以使游戏变得出名，这总是有助于获得用户。

## 付费用户获取

有许多营销机构为游戏找到用户。通常，这些机构会向开发者收取用户获取费用。如果开发者有能力花费真金白银来获取用户，那么这可能是最好的解决方案。

用户获取费用可能会因地区而异。开发者需要根据游戏类型和种类进行更多研究；获得的用户可以通过更多收入回报开发者。有时，错误的推广选择和错误获取的用户群可能会导致游戏失败。

## 其他技术

除了上述技术，还有几种方法可以获得用户。开发者可以提出自己的游戏推广想法。其中一些如下：

+   许多时候，开发者会单独接触用户来推广游戏

+   许多时候，游戏是通过朋友和家人口头宣传的

+   许多时候，开发者会为游戏进行宣传活动

+   开发者可以寻求一个好的发行商来帮助获取更多用户

+   有时，名人被用来推广游戏

没有固定的游戏推广和获取用户的路径。保持所有选项开放并以获得最大可能的结果为目标是一种良好的习惯。

# 用户留存技术

建立良好的用户群体可能不足以产生足够的收入以获得游戏利润。因此出现了“用户留存”这个术语。这意味着反复玩游戏的用户数量。

用户可能下载游戏，玩几次后可能再也不回来。在另一种情况下，用户可能一次又一次地回到游戏中。用户留存是根据周或月的使用时间参数计算的。这意味着在给定时间段内有多少用户回到游戏中。

免费和免费游戏的收入大部分取决于用户留存，因为开发者通过几种收入生成计划将用户在游戏中花费的时间转化为收入。这就是为什么用户留存对于游戏业务至关重要。

除了核心元游戏之外，还有许多技巧可以提高用户留存率。让我们通过以下几点讨论主要技巧：

+   每日奖励

+   排行榜和成就

+   积分墙集成

+   推送通知

+   频繁更新

## 每日奖励

每日奖励是游戏开发者中最受欢迎的用户留存技术。在这个系统中，用户每天回到游戏都会得到额外的东西。连续玩几天会奖励用户更多的物品和元素。

这个系统激励用户不断回到游戏中。因此，开发者可以获得更多的游戏时间来将其转化为收入。

## 排行榜和成就

排行榜和成就被广泛用于留存用户。两者都给用户竞争和进步的动力。为了在游戏中取得进步，用户必须回到游戏并在游戏中花费时间。

## 积分墙集成

开发者使用一些真实世界的优惠来留住用户。诸如优惠券和折扣之类的真实优惠总是吸引用户。这激励他们经常来到积分墙。积分墙不仅有助于留住用户，还有助于从各种优惠活动中产生更多收入。

## 推送通知

推送通知可以通知用户有关游戏的最新信息和更新。即使用户没有玩游戏，推送通知也可以帮助他们对游戏产生兴趣，这可能会让用户重新开始玩游戏。

有时，用户下载游戏后就忘了。在这种情况下，推送通知会提醒用户玩游戏。它还会告诉他们游戏内的进度。

## 频繁更新

开发者应该经常更新游戏，以跟上榜单并引起用户的注意。这间接吸引更多用户并帮助留住现有用户。

每个游戏商店都会通知现有用户有关游戏或应用的最新更新信息，以便用户可以更新他们的游戏并继续玩。

# 推广安卓游戏

成功的游戏意味着利润和名声。一个游戏可以通过良好的货币化设计和营销而获利。然而，要成名并不容易。一个游戏如果在各种地方被特色展示，就会变得出名。

游戏可以通过以下特质和标准来进行特色展示：

+   创意和独特性

+   用户评论和评分

+   下载次数

+   收入金额

## 创意和独特性

游戏行业中有许多游戏评论家和评论者。有许多文章、博客、杂志和网站都在关注、评论和谈论游戏。游戏的创意和独特性是这些媒体的最大因素。游戏的质量取决于游戏美术、游戏设计和可玩性。良好的艺术风格、良好的设计和可玩性可以使游戏被游戏商店、杂志或博客特色展示。通过这种方式，开发者可以使游戏出名，这可能会带来更多的用户和收入。

## 用户评论和评分

发布游戏后，游戏的命运取决于用户。如果游戏收到不好的评论和差评，新用户就无法被吸引到游戏中来。因此，游戏将无法被特色展示并获得动力。开发者应始终关注游戏评分和用户评论。开发者应积极回应用户遇到的问题，并感谢好评和好评。通常情况下，人们会注意到游戏在发布初期表现不佳。然而，对用户评论持积极态度，他们在后期表现良好。

## 下载次数

下载量是另一个游戏特色的标准。一旦下载量增加，游戏被商店自身推荐的可能性就更大。然而，评分也是这种推荐的因素。开发者应该集中精力尽快增加下载量，以便被推荐或进入榜单。

## 收入金额

安卓游戏可以根据收入生成量在最赚钱榜单上进行特色展示。进入最赚钱榜单意味着用户正在为游戏付费，或者游戏正在产生大量收入。进入最赚钱榜单总是增加游戏的可见度，间接地增加下载量和收入。然而，为了保持在榜单上，开发者应该根据用户需求不断更新游戏，并且重点关注用户留存。

# 发布安卓游戏

到目前为止，你已经学会了如何接触用户，以及如何从游戏中获得收入。然而，这些都是游戏在市场上发布后的步骤。开发者可以通过两种方式发布游戏：

+   自我出版

+   通过出版商发布

让我们快速看一下游戏开发的这一部分。

## 自我出版

当用户以自己的名义和标语发布时，这被称为自我出版。在这种情况下，开发者保留游戏 100%的股权，并拥有游戏的知识产权。自我出版游戏完全由开发者控制。开发者对游戏、游戏评分和评论、游戏收入和用户满意度负有全部责任。

## 通过出版商发布

通常，开发者在发布游戏后没有足够的带宽来承担全部的游戏责任。在这种情况下，开发者可以接触已建立的出版商来发布游戏。有时，出版商有他们自己的条款和条件，以及对游戏的要求才能发布游戏。开发者需要遵守这些条件，以减少责任并获得更好的营销。

# 总结

在本章中，你了解了整个游戏开发周期。开发者应该有能力为游戏做出正确的决定，以获得成功。众所周知，成功并不容易。本章展示了游戏成功所需关注的所有因素。

制作一个好游戏是不够的；制作一个独特的游戏也不够；制作好的图形也不够；拥有良好的设计也不够。游戏开发者必须在自己无法完成的情况下寻求其他第三方服务的帮助。使用社交平台也是必须的。

最后，选择正确的出版地点并针对游戏的正确受众可以带来成功。在安卓特定的游戏领域，已经有建立的出版社、商店和其他第三方服务提供商。开发者需要在游戏制作完成后仔细组合它们。否则，一个好游戏很可能会在数百万款安卓游戏中迷失。
