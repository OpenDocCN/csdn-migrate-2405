# CentOS7 Linux 服务器秘籍（一）

> 原文：[`zh.annas-archive.org/md5/85DEE4E32CF6CFC6347B684FDF685546`](https://zh.annas-archive.org/md5/85DEE4E32CF6CFC6347B684FDF685546)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 前言

本书是备受好评的《CentOS Linux 服务器食谱》的第二版。随着 2014 年年中 CentOS 7 的推出，这个著名的操作系统迎来了一系列重大变化和新特性。例如，新的安装程序、系统管理服务套件、防火墙守护进程、增强的 Linux 容器支持以及新的标准文件系统。由于操作系统的新进展，《CentOS 6 Linux 服务器食谱》中很大一部分的食谱变得过时甚至无法使用，因此更新本书的原始内容至关重要。但本书不仅仅是第一版内容的复习：还新增了两章，以跟上最新的开源技术并提供更好的安全性：操作系统级虚拟化和 SELinux。最后，为了使本书成为更全面的服务器管理书籍，还增加了一章关于服务器监控的内容。

构建服务器可能会带来挑战。在最好的情况下也常常是困难的，在最坏的情况下则是令人沮丧的。它们可能代表最大的问题，也可能给你带来极大的自豪和成就感。尽管“服务器”这个词可以描述很多事物，但本书的目的是揭开企业级计算系统的神秘面纱，旨在帮助你构建你选择的专业服务器解决方案。CentOS 是一个基于社区的企业级操作系统。它是免费提供的，并且作为 Red Hat Enterprise Linux（RHEL）的完全兼容衍生版本，它是全球组织、公司、专业人士和家庭用户打算运行服务器的首选操作系统。它被广泛认为是一个非常强大和灵活的 Linux 发行版，无论你打算运行 Web 服务器、文件服务器、FTP 服务器、域服务器还是多角色解决方案，本书的目的都是提供一系列即用型解决方案，展示你如何快速使用 CentOS 操作系统构建一个功能全面的服务器系统。因此，可以说这本书不仅仅是对另一个基于服务器的操作系统的又一次介绍。这是一本关于企业级操作系统的食谱，提供了一种逐步使其工作的方法。因此，无论你是新手还是经验丰富的用户，每个人都能在这本书中找到有用的内容，因为这本书将成为你完成任务的实用指南，也是所有 CentOS 事物的起点。

# 本书内容概述

第一章，*安装 CentOS*，是一系列介绍您安装服务器任务的配方，更新，并通过添加额外工具来增强最小安装。它旨在让您开始，并提供一个参考，向您展示实现所需安装的多种方式。

第二章，*配置系统*，旨在在成功安装后提供帮助，并为您提供一系列配方，使您能够实现所需的服务器初始配置。从向您展示如何处理文本文件，然后更改语言和时间日期设置，您不仅将学习如何配置网络设置，还将学习如何解析完全限定域名以及如何使用内核模块。

第三章，*管理系统*，提供了构建块，使您能够掌握您的服务器并控制您的环境。在这里，您将通过传播大量信息来启动您作为服务器管理员的角色，这些信息将引导您完成开发全面考虑和专业服务器解决方案所需的多种步骤。

第四章，*使用 YUM 管理软件包*，旨在向您介绍在 CentOS 7 上使用软件包的工作。从升级系统到查找、安装、卸载以及通过添加额外的仓库来增强系统，本章的目的是解释开源命令行包管理工具，即 Yellowdog Updater Modified（YUM）以及 RPM 包管理器。

第五章，*管理文件系统*，专注于与服务器文件系统的工作。从创建模拟磁盘设备以测试概念到高级格式化和分区命令，您将学习如何使用逻辑卷管理器，维护文件系统以及使用磁盘配额。

第六章，*提供安全性*，讨论了实施一系列解决方案的必要性，这些解决方案将提供您运行成功服务器解决方案所需级别的保护。从保护您的 ssh 和 FTP 服务，到了解新的 firewalld 管理器和创建证书，您将看到构建一个不仅考虑减少外部攻击风险，而且为您的用户提供额外保护的服务器是多么容易。

第七章，*构建网络*，解释了在您的网络计算机中实现各种形式的资源共享所需的步骤。从 IP 地址和打印设备到各种形式的文件共享协议，无论您是打算支持家庭网络还是完整的商业环境，本章在任何服务器中都扮演着至关重要的角色。

第八章，*使用 FTP*，专注于 VSFTP 的角色，并提供了一系列的食谱，将为您提供所需的指导，以在 CentOS 7 服务器上安装、配置和管理您想要提供的文件传输协议（FTP）。

第九章，*使用域名*，考虑了在 CentOS 7 服务器上实施域名、域名解析和 DNS 查询所需的步骤。域名系统在任何服务器中都扮演着至关重要的角色，无论您是打算支持家庭网络还是完整的商业环境，本章的目的是提供一系列的解决方案，将为您提供一个未来证明的解决方案的开始。

第十章，*使用数据库*，提供了一系列的食谱，旨在解释在 CentOS 7 服务器上部署 MySQL 和 PostgreSQL 所需的必要步骤。

第十一章，*提供邮件服务*，向您介绍如何为您的 CentOS 7 服务器启用域范围内的邮件传输代理。从构建本地 POP3/SMTP 服务器到配置 Fetchmail，本章的目的是为您的所有未来基于电子邮件的需求提供基础。

第十二章，*提供 Web 服务*，深入研究了著名的 Apache 服务器技术的角色，无论您是打算运行开发服务器还是实时生产服务器，本章都为您提供了必要的步骤，以提供您成为基于 Web 的发布解决方案大师所需的功能。

第十三章，*操作系统级虚拟化*，向您介绍使用最先进的开源平台 Docker 的 Linux 容器世界，并指导您构建、运行和共享您的第一个 Docker 镜像。

第十四章，*使用 SELinux*，有助于理解和解开 CentOS 7 中最不为人知的话题之一——安全增强型 Linux 的神秘面纱。

第十五章，*监控 IT 基础设施*，介绍并展示了如何设置 Nagios Core，这是监控整个 IT 基础设施的行业标准。

# 本书所需

本书的要求相对简单，首先是需要下载 CentOS 操作系统。该软件是免费的，但你需要一台能够充当服务器的计算机，一些免费的安装介质（空白 CD-R/DVD-R 或 USB 设备），互联网连接，一些空闲时间，以及享受乐趣的愿望。

话虽如此，许多读者都会意识到，你不需要一台备用计算机来利用这本书，因为始终可以选择在虚拟化软件上安装 CentOS。这种方法非常常见，在这些页面中包含的食谱仍然适用的情况下，你应该知道本书不考虑使用虚拟化软件。因此，任何关于使用该软件的支持请求都应直接向相应的供应商提出。

# 本书适合谁

这是一本关于构建服务器解决方案的实用指南，而不是关于 CentOS 本身。本书将向你展示如何让 CentOS 运行起来。它是一本为初学者到中级 Linux 用户编写的书，他们打算将 CentOS 作为下一个服务器的基础。但是，如果你对整个操作系统还不熟悉，那么不用担心；本书还将为你提供构建完整服务器解决方案所需的逐步方法，并附带许多行业技巧。

# 章节

在本书中，你会发现一些频繁出现的标题（准备就绪，如何做，它是如何工作的，还有更多）。

为了给出如何完成食谱的明确指示，我们使用以下章节：

## 准备就绪

本节告诉你食谱中可以期待的内容，并描述如何设置任何软件或任何预先设置，这些是食谱所必需的。

## 如何做…

本节包含遵循食谱所需的步骤。

## 它是如何工作的…

本节通常包含对上一节中发生的事情的详细解释。

## 还有更多…

本节包含有关食谱的额外信息，旨在使读者对食谱有更深入的了解。

# 约定

在本书中，你会发现许多文本样式，用于区分不同类型的信息。以下是这些样式的一些示例及其含义的解释。

文本中的代码词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 句柄如下所示：“为了本食谱的目的，假设所有下载将存储在 Windows 上的个人`C:\Users\<username>\Downloads`文件夹中，或者如果使用 OS X 系统，则存储在`/Users/<username>/Downloads`文件夹中。”

代码块的设置如下：

```
<?xml version="1.0" encoding="utf-8"?>
<service>
  <description>enable FTPS ports</description>
  <port protocol="tcp" port="40000-40100"/>
  <port protocol="tcp" port="21"/>
  <module name="nf_conntrack_ftp"/>
</service>
```

任何命令行输入或输出如下所示：

```
sudo diskutil unmountDisk /dev/disk3
sudo dd if=./CentOS-7-x86_64-Minimal-XXXX.iso of=/dev/disk3 bs=1M

```

**新术语**和**重要词汇**以粗体显示。您在屏幕上看到的单词，例如在菜单或对话框中，如下所示：“单击**下一步**按钮将您移动到下一个屏幕。”

### 注意

警告或重要注意事项以这样的框显示。

### 提示

提示和技巧如下所示。


# 第一章：安装 CentOS

在本章中，我们将涵盖：

+   在 Windows 或 OS X 上下载 CentOS 并确认校验和

+   在 Windows 或 OS X 上创建 USB 安装介质

+   使用图形安装程序执行 CentOS 安装

+   通过 HTTP 进行网络安装

+   使用 kickstart 文件安装 CentOS

+   重新安装引导加载程序

+   在救援模式下排除系统故障

+   开始使用并自定义引导加载程序

+   更新安装并使用额外的管理和发展工具增强最小安装

# 引言

本章是一系列涵盖安装 CentOS 7 操作系统基本实践的操作的集合。本章的目的是向您展示您可以多快地让 CentOS 运行起来，同时让您能够使用一些“行业技巧”来定制您的安装。

# 在 Windows 或 OS X 上下载 CentOS 并确认校验和

在本操作中，我们将学习如何使用典型的 Windows 或 OS X 桌面计算机下载并确认一个或多个 CentOS 7 磁盘映像的校验和。CentOS 通过 HTTP、FTP 或 rsync 协议从全球各地的一系列镜像站点或通过 BitTorrent 网络以各种格式提供。对于从互联网下载非常重要的文件，例如操作系统映像，验证这些文件的校验和被认为是最佳实践，以确保任何生成的媒体在安装时都能按预期运行和执行。这也确保了文件是真实的，并且来自原始来源。

## 准备

要完成此操作，假设您正在使用具有完全管理权限的典型 Windows（Windows 7、Windows Vista 或类似）或 OS X 计算机。您需要互联网连接以下载所需的安装文件，并且需要访问具有适当软件的标准 DVD/CD 刻录机，以便从映像文件创建相关的安装磁盘。对于此操作，假设所有下载将存储在 Windows 上的个人`C:\Users\<username>\Downloads`文件夹中，或者如果使用 OS X 系统，则存储在`/Users/<username>/Downloads`文件夹中。

## 如何操作...

无论您下载哪种类型的安装文件，以下技术都可以应用于 CentOS 项目提供的所有映像文件：

1.  让我们首先在网络浏览器中访问[`www.centos.org`](http://www.centos.org)，导航到**立即获取 CentOS**按钮链接。然后点击文本中的**当前镜像列表**链接。

1.  镜像站点被分类，因此从链接列表中选择一个地理位置接近您当前位置的镜像。例如，如果您在伦敦（英国），您可以选择来自**欧盟**和**英国**的镜像。现在通过选择 HTTP 或 FTP 链接来选择一个镜像站点。

1.  做出选择后，现在将看到所有可用 CentOS 版本的目录列表。要继续，只需单击读取`7`的相应文件夹。接下来，您将看到一个额外的目录列表，如`atomic`、`centosplus`、`cloud`等。我们选择`isos`目录继续。

1.  CentOS 7 目前仅支持 64 位架构，因此浏览到唯一可用的标记为`x86_64`的目录，这是一个包含 64 位版本的容器。

1.  现在将为您提供一系列可供下载的文件。首先下载有效的校验和结果副本，标识为`md5sum.txt`。

1.  如果您是 CentOS 新手或打算遵循本书中找到的配方，那么最小安装是理想的。这包含尽可能少的软件包以拥有一个功能系统，因此选择以下内容（`XXXX`是此版本的月份标记）：

    ```
    CentOS-7-x86_64-Minimal-XXXX.iso

    ```

1.  仅在基于 Windows 的系统上（在 Mac 上，此工具已在系统中可用），在浏览器中访问[`mirror.centos.org/centos/dostools/`](http://mirror.centos.org/centos/dostools/)并下载程序`md5sum.exe`。

1.  现在在 Windows 上，打开命令提示符（通常位于**开始** | **所有程序** | **附件** | **命令提示符**）并输入以下命令到打开的窗口中（在所有行的末尾按下*回车*键）：

    ```
    cd downloads
    dir

    ```

1.  在 OS X 上，打开程序**Finder** | **Applications** | **Utilities** | **Terminal**，然后输入以下命令（在所有行的末尾按下*回车*键）：

    ```
    cd ~/Downloads
    ls

    ```

1.  现在您应该看到下载文件夹中的所有文件（包括所有下载的 CentOS 安装图像文件、md5sum.txt 文件以及在 Windows 上的 md5sum.exe 程序）。

1.  根据显示的文件名，修改以下命令以检查您下载的 ISO 图像文件的校验和。在 Windows 上，输入以下命令（根据需要更改`XXXX`月份标记）：

    ```
    md5sum.exe CentOS-7-x86_64-Minimal-XXXX.iso

    ```

1.  在 OS X 上，请使用以下命令：

    ```
    md5 CentOS-7-x86_64-Minimal-XXXX.iso

    ```

1.  按下*回车*键继续，然后等待命令提示符响应。响应被称为 MD5 总和，结果可能看起来像以下内容：

    ```
    d07ab3e615c66a8b2e9a50f4852e6a77  CentOS-7-x86_64-Minimal-1503-01.iso

    ```

1.  现在查看总和，并与`md5sum.txt`文件中与您的特定图像文件相关的列表进行比较（在文本编辑器中打开）。如果两个数字匹配，那么您可以确信您确实下载了一个有效的 CentOS 图像文件。如果不是，您的下载文件可能已损坏，因此请重新启动此过程，再次下载图像文件。

1.  完成后，只需使用您首选的桌面软件将您的图像文件刻录到空白 CD-ROM 或 DVD-ROM 上，或者从中创建 USB 安装介质，我们将在本章的下一个配方中向您展示。

## 它是如何工作的…

那么我们从这次经历中学到了什么？

下载 CentOS 安装镜像只是构建完美服务器的第一步。尽管这个过程非常简单，但许多人忘记了确认校验和的必要性。在本书中，我们将使用最小安装镜像，但您应该知道还有其他安装选项可供您选择，例如 NetInstall、DVD、Everything 和各种 LiveCDs。

# 在 Windows 或 OS X 上创建 USB 安装介质

在本操作中，我们将学习如何在 Windows 或 OS X 上创建 USB 安装介质。如今，越来越多的服务器系统、台式机和笔记本电脑在发货时不带任何光驱。使用 USB 设备安装新操作系统，例如 CentOS Linux，对于它们来说变得至关重要，因为没有其他安装选项可用，因为没有其他方式可以启动安装介质。此外，使用 USB 介质安装 CentOS 可以比使用 CD/DVD 方法快得多。

## 准备工作

在我们开始之前，假设您已经按照前面的操作步骤，下载了最小化的 CentOS 镜像并确认了相关镜像文件的校验和。同时，假设所有下载内容（包括下载的 ISO 文件）都存储在 Windows 上的`C:\Users\<username>\Downloads`文件夹中，或者在使用 OS X 系统时，存储在`/Users/<username>/Downloads`文件夹中。接下来，您需要一个能够被操作系统识别的空闲 USB 设备，该设备有足够的总空间，并且是空的或者其上的数据可以丢弃。准备作为 CentOS 7 最小版本安装介质的 USB 设备所需的总空间大约为 700 兆字节。如果您使用的是 Windows 计算机，您需要一个有效的互联网连接来下载额外的软件。在 OS X 上，您需要一个管理员用户账户。

## 如何操作...

开始此操作前，启动您的 Windows 或 OS X 操作系统，然后连接一个足够容量的空闲 USB 设备，并等待它被 Windows 下的**文件管理器**或 OS X 下的**Finder**识别。

1.  在基于 Windows 的系统上，我们需要下载一个额外的软件叫做`dd`。访问您最喜欢的浏览器中的[`www.chrysocome.net/dd`](http://www.chrysocome.net/dd)。现在下载那里最新的`dd-XX.zip`文件，其中`XX`是最新的稳定版本号。例如，`dd-0.5.zip`。

1.  在 Windows 上，使用**文件管理器**导航到您的`Downloads`文件夹。在这里，您将找到`dd-05.zip`文件。右键点击它并选择**全部提取**，然后提取`dd.exe`文件，不要创建任何子目录。

1.  在 Windows 上，打开命令提示符（通常位于**开始** | **所有程序** | **附件** | **命令提示符**）并输入以下命令：

    ```
    cd downloads
    dd.exe --list

    ```

1.  在 OS X 上，打开**Finder** | **应用程序** | **实用工具** | **终端**程序，然后输入以下命令：

    ```
    cd ~/Downloads
    diskutil list

    ```

1.  在 Windows 系统中，要找到你想要用作安装介质的正确 USB 设备的名称，请查看命令输出中的`removable media`部分。在此之下，你应该会找到一条以`Mounting on`开头的行，后面跟着一个驱动器字母，例如，`\.\e:`。这个用晦涩方式书写的驱动器字母是下一步中最重要的部分，所以请记下来。

1.  在 OS X 系统中，设备路径可以在前一个命令的输出中找到，格式为`/dev/disk<number>`，其中`number`是磁盘的唯一标识符。磁盘编号从零（`0`）开始。磁盘`0`很可能是 OS X 恢复磁盘，而磁盘`1`很可能是你的主 OS X 安装。要识别你的 USB 设备，尝试比较`NAME`、`TYPE`和`SIZE`列与你的 USB 闪存盘的规格。如果你已经确定了设备名称，请记下来，例如，`/dev/disk3`。

1.  在 Windows 系统中，输入以下命令，假设你选作安装介质的 USB 设备在 Windows 中的设备名称为`\\.\e:`（根据需要更改此设置，并小心输入——这可能会造成巨大的数据丢失）。同时，在下一个命令中将`XXXX`替换为正确的`iso`文件版本号：

    ```
    dd.exe if=CentOS-7-x86_64-Minimal-XXXX.iso of=\\.\e: bs=1M

    ```

1.  在 OS X 系统中，你需要两个命令，这两个命令会要求输入管理员密码（将`XXXX`和`disk3`替换为正确的版本号和正确的 USB 设备路径）：

    ```
    sudo diskutil unmountDisk /dev/disk3
    sudo dd if=./CentOS-7-x86_64-Minimal-XXXX.iso of=/dev/disk3 bs=1m

    ```

1.  在`dd`程序完成后，会有一些输出统计信息，显示复制过程耗时以及传输了多少数据。在 OS X 系统中，忽略任何关于磁盘不可读的警告信息。

1.  恭喜！你现在已经创建了你的第一个 CentOS 7 USB 安装介质。现在你可以在 Windows 或 OS X 系统中安全地移除 USB 驱动器，并物理拔出设备，将其用作在目标机器上安装 CentOS 7 的启动设备。

## 它是如何工作的...

那么，我们从这次经历中学到了什么？

本教程的目的是向你介绍使用`dd`命令行程序在 USB 设备上创建 CentOS 安装 ISO 文件的精确副本的概念。`dd`程序是一个基于 Unix 的工具，可用于将位从源复制到目标文件。这意味着源被逐位读取并写入目标，不考虑内容或文件分配；它只是涉及读取和写入纯原始数据。它期望两个基于文件名的参数：输入文件（`if`）和输出文件（`of`）。我们将使用 CentOS 镜像文件作为我们的输入文件名，将其精确地`1:1`克隆到 USB 设备上，该设备可通过其设备文件作为我们的输出文件参数访问。`bs`参数定义了块大小，即一次要复制的数据量。请小心，这是一个绝对的专业工具，在复制数据时会覆盖目标上的任何现有数据，而无需进一步确认或任何安全检查。因此，至少要双重检查目标 USB 设备的驱动器字母，切勿混淆它们！例如，如果你在`D:`上安装了第二个硬盘，在`E:`上安装了 USB 设备（在 OS X 上，分别为`/dev/disk2`和`/dev/disk3`），并且你混淆了驱动器字母`E:`和`D:`（或`/dev/disk3`和`/dev/disk2`），你的第二个硬盘将被擦除，几乎没有恢复任何丢失数据的机会。所以请小心处理！如果你对正确的输出文件设备有疑问，切勿启动`dd`程序！

总之，可以公平地说，对于创建 CentOS 7 的 USB 安装媒体，存在比`dd`命令更为便捷的解决方案，例如 Fedora Live USB Creator。但本教程的目的不仅在于制作一个即用的 CentOS USB 安装器，还在于让你熟悉`dd`命令。这是一个常见的 Linux 命令，每位 CentOS 系统管理员都应该知道如何使用。它可以用于广泛的日常任务，例如安全擦除硬盘、网络速度基准测试或创建随机二进制文件。

# 使用图形安装程序执行 CentOS 安装

在本教程中，我们将学习如何使用 CentOS 7 中引入的新图形安装程序界面执行典型的 CentOS 安装。在很多方面，这被认为是安装系统的推荐方法，因为它不仅允许你创建所需的硬盘分区，还允许你在很多方面自定义安装（例如，键盘布局、软件包选择、安装类型等）。然后，你的安装将构成一个服务器的基础，在这个服务器上，你可以构建、开发和运行任何类型的服务，你将来可能希望提供这些服务。

## 准备就绪

在我们开始之前，假设您已经按照之前的步骤操作，其中您被展示了如何下载 CentOS 镜像，确认相关镜像文件的校验和，并创建相关的安装光盘或 USB 介质。您的系统必须是 64 位（x86_64）架构，至少需要 406MB RAM 来加载图形安装程序（如果安装图形窗口管理器如 Gnome，则建议 1GB 或更多），并且至少有 10GB 的可用硬盘空间。

## 如何操作...

要开始这个步骤，插入您的安装介质（CD/DVD 或 USB 设备），重新启动计算机，并在启动时按下选择启动设备的正确键。然后从列表中选择插入的设备（对于许多计算机，这可以通过*F11*或*F12*访问，但在您的系统上可能不同。请参考您的主板手册）。

1.  在欢迎屏幕上，**测试此媒体并安装 CentOS 7**选项已被预选，我们将使用此选项。准备好后，按*回车*键继续。

1.  加载一些初始文件后，安装程序开始测试安装介质。单个测试应在 30 秒到五分钟之间，并会报告您的安装介质上是否有任何错误。当这个过程完成后，系统最终将加载图形安装程序。

1.  CentOS 安装程序现在将显示图形安装欢迎屏幕。从这一点开始，您可以使用键盘和鼠标（后者强烈推荐），但如果您打算使用数字键盘，请记得在键盘上启用数字锁定。

1.  在左侧，您会看到主要的语言类别，在右侧，安装程序的子语言。您还可以使用左下角的文本框搜索语言。对语言设置的所有更改将立即生效，因此，当您准备好后，选择**继续**按钮以继续。

1.  现在我们到达了主要的安装菜单，称为**安装摘要**。

1.  这里显示的大多数选项已经有一些预设值，无需更改即可使用，而那些没有默认值且需要您注意的选项则标有红色感叹号，例如**系统**类别下的**安装目的地**。因此，让我们使用鼠标点击它。

1.  点击**安装位置**按钮后，你将看到一个图形列表，列出了当前连接到你计算机的所有硬盘设备，你可以用它们来安装操作系统。你可以通过点击正确的硬盘图标来选择你的目标硬盘。然后它会在上面打上勾。如果你不确定正确的硬盘，尝试通过比较菜单中显示的品牌和总大小来识别它。在安装可以进行之前，你必须选择一个硬盘。请小心并明智地选择你的目标硬盘，因为安装过程中它将擦除任何现有数据。准备就绪后，点击**完成**按钮。

1.  如果你的选定硬盘已经包含数据，那么在点击**完成**时，你可能会看到一个可以被描述为警告/错误消息的信息。该消息可能显示：**你没有足够的可用空间来安装 CentOS**。别担心！这是预期中的，消息只是要求你重新初始化你的硬盘，因为 CentOS 只能安装在空白的硬盘上。在大多数情况下，特别是如果你在硬盘上有多个分区，只需点击**回收空间**，这将显示一个新窗口，其中列出了该驱动器上的所有分区。在这里，只需点击**删除所有**，然后再次点击**回收空间**，以丢弃该硬盘上的任何数据，这将完成硬盘初始化的任务，并允许你继续下一步。完成后，点击**完成**按钮。

1.  回到**安装摘要**屏幕，**安装位置**项上的感叹号现在应该消失了。

1.  在**系统**类别下，我们可以选择性地点击**网络与主机名**。在接下来的页面中，左侧你可以选择你希望连接到互联网的主要网络适配器，并通过点击它来选中。对于选中的设备，点击右侧的开关以启用并自动连接，使用开关的**开启**位置。最后，在关闭此子菜单之前，将其文本字段中的主机名更改为适当的名称。点击**完成**。

1.  现在回到**安装摘要**屏幕，所有重要设置都已经完成或获得了预设值，所有感叹号都消失了。如果你对这些设置满意，点击**开始安装**按钮，或者根据需要更改设置。

1.  在下一个屏幕上，你需要为 root 用户创建并确认一个 root 密码，同时新系统在后台进行安装。选择一个不少于六个字符的安全密码。

1.  在此屏幕上，你还可以创建一个标准用户账户，这是非常推荐的。如果你创建了一个新用户，请不要勾选**使该用户成为管理员**。准备就绪后，点击**完成**（如果你输入了一个弱密码，你需要通过点击两次来确认）。

1.  CentOS 现在将在后台对硬盘进行分区和格式化，并解决任何依赖关系，安装程序将开始向硬盘写入数据。这可能需要一些时间，但进度条将指示安装状态。完成后，安装程序将通知您整个过程已完成，并且安装成功。准备好后，点击**重启**按钮。现在从驱动器中取出安装介质。

1.  恭喜！您已成功在计算机上安装了 CentOS 7。

## 它是如何工作的…

在本教程中，您已经了解了如何安装 CentOS 7 操作系统。在介绍了图形安装过程的典型方法之后，您现在可以对服务器进行额外的配置更改和软件包安装，以满足您打算让服务器承担的角色。这个图形安装程序旨在非常直观和灵活，使得安装过程非常简单，因为它将引导用户完成一些强制性任务，这些任务必须在开始安装主系统之前完成。

# 通过 HTTP 进行网络安装

在本教程中，我们将学习如何通过 HTTP（使用 URL 方法）启动网络安装过程，以便安装 CentOS 7。这是一个使用一个小型映像文件来启动计算机，并允许用户通过网络连接选择并安装他想要的软件包和服务的过程，而不安装其他任何东西，从而提供了极大的灵活性。

## 准备就绪

在我们开始之前，假设您已经知道如何下载和校验 CentOS 7 安装映像，以及如何从中创建相关的安装介质。对于本教程，我们需要下载并创建网络安装映像的安装介质（下载最新的 CentOS-7-x86_64-NetInstall-XXXX.iso 文件），而不是本章中另一个教程中显示的最小 ISO。此外，假设您至少已经通过一次图形安装过程，确切知道如何从安装介质启动并使用安装程序。

## 如何操作…

要开始本教程，请插入您准备好的网络安装介质，从它启动计算机，并等待欢迎屏幕出现：

1.  在欢迎屏幕上，**测试此介质并安装 CentOS 7**选项已被预选，我们将使用此选项。准备好后，按*回车*键继续。

1.  测试完成后，图形安装程序将加载并显示典型的图形安装摘要屏幕。

    ### 注意

    在这里，安装程序应该像在正常图形安装教程中一样进行配置，除了对**网络和主机名**以及**安装源**菜单项进行以下强制性更改（由红色感叹号指示）。

1.  在我们能够通过网络安装 CentOS 之前，我们必须确保我们有可用的网络连接。因此，您应该首先点击 **网络和主机名** 菜单项，并将您的网络适配器激活到连接状态。有关更多详细信息，请参阅正常安装食谱。

1.  接下来，点击 **安装源** 进入设置。由于我们将通过 HTTP（也称为 URL 方法）进行安装，因此您应该在 **您想使用哪种安装源？** 部分中保留默认的 **网络** 选项。

1.  现在在标准的 `http://` 文本框中输入以下 URL，我们将使用它来下载所有必需的安装包：[`mirror.centos.org/centos/7/os/x86_64/`](http://%20http://mirror.centos.org/centos/7/os/x86_64/)。

1.  或者，您也可以使用个人仓库，这需要您提前创建（请参阅 第四章，*使用 YUM 管理软件包*）

1.  准备就绪后，点击 **完成** 开始初始化过程。

1.  成功后，安装程序将开始检索适当的 `install.img` 文件。这可能需要几分钟才能完成，但一旦解决，进度条将指示所有下载活动。当此过程成功完成后，**安装源** 处的感叹号将消失，但会出现另一个感叹号，告诉用户缺少 **软件选择**。点击它并选择适合您需求的选项。对于本食谱的目的，只需在 **基本环境** 下选择 **最小安装**，然后点击 **完成**。

1.  如果 **您想使用哪种安装源？** 保持灰色且无法更改，则您的网络适配器存在连接问题。如果出现这种情况，请返回配置 **网络和主机名** 并更改网络设置，直到达到连接状态。

1.  CentOS 7 现在将以常规方式安装操作系统，并在安装过程完成后向您表示祝贺。由于所有软件包都必须从互联网上获取，因此它可能比从物理安装介质安装要慢。

## 工作原理...

本食谱的目的是向您介绍 CentOS 网络安装过程的概念，以展示这种方法可以多么简单。通过完成本食谱，您不仅通过将初始下载限制为仅安装过程所需的文件来节省时间，而且还能够利用完整的图形安装方法，而无需完整的 DVD 套件。

# 使用 kickstart 文件安装 CentOS 7

虽然使用图形安装程序手动安装 CentOS 7 在一台服务器上是可以的，但在多台系统上这样做可能会很繁琐。Kickstart 文件可以自动化服务器系统的安装过程，这里我们将展示如何实现这一点。它们是简单的基于文本的配置文件，提供了关于目标系统应如何设置和安装的详细和精确的指令（例如，安装哪种键盘布局或额外的软件包）。

## 准备就绪

为了成功完成此方法，您需要访问一个已安装的 CentOS 7 系统以获取我们要使用的 kickstart 配置文件并用于自动化安装。在这个预安装的 CentOS 服务器上，您还需要一个有效的互联网连接来下载额外的软件。

接下来，我们需要下载并创建 DVD 或 Everything 映像的安装介质（下载最新的`CentOS-7-x86_64-DVD-XXXX.iso`或`CentOS-7-x86_64-Everything-XXXX.iso`文件），而不是本章中另一方法中显示的最小 iso 文件。然后，您需要另一个在 Linux 系统上可读写的 USB 设备（格式化为 FAT16、FAT32、EXT2、EXT3、EXT4 或 XFS 文件系统）。

## 如何操作...

为了使此方法生效，我们首先需要物理访问另一个已完成 CentOS 7 安装的 kickstart 文件，我们将使用它作为新 CentOS 7 安装的模板。

1.  在现有的 CentOS 7 系统上以 root 身份登录，并通过输入以下命令并按*回车*键执行来确保 kickstart 配置文件存在（这将显示文件的详细信息）：

    ```
    ls -l /root/anaconda-ks.cfg

    ```

1.  接下来，物理上插入一个 USB 设备，然后输入以下命令，这将为您提供当前连接到计算机的所有硬盘设备的列表：

    ```
    fdisk -l

    ```

1.  尝试通过比较其大小、分区以及识别的文件系统与您的 USB 设备的规格来确定设备名称。设备名称将是`/dev/sdX`的形式，其中`X`是一个字母字符，如`b`、`c`、`d`、`e`等。如果您无法使用`fdisk`命令找到正确的设备名称，请尝试以下技巧：运行`fdisk -l`两次 - 首先在未插入 USB 设备的情况下，然后在插入 USB 设备的情况下，比较第二次输出如何变化 - 它比第一次输出多一个设备名称：您感兴趣的设备名称！

1.  如果您在列表中找到了正确的设备名称，请创建一个目录以将其挂载到当前文件系统：

    ```
    mkdir /mnt/kickstart-usb

    ```

1.  接下来，实际上将 USB 设备挂载到此文件夹，假设您选择的 USB 分区位于`/dev/sdc1`（根据需要更改此设置）：

    ```
    mount /dev/sdc1 /mnt/kickstart-usb

    ```

1.  现在，我们将在 USB 设备上创建 kickstart 文件的工作副本以进行定制：

    ```
    cp /root/anaconda-ks.cfg /mnt/kickstart-usb

    ```

1.  然后，使用您喜欢的文本编辑器打开 USB 设备上的复制 kickstart 文件（这里我们将使用编辑器 nano，如果您还没有安装它，请输入`yum install nano`）：

    ```
    nano /mnt/kickstart-usb/anaconda-ks.cfg

    ```

1.  现在，我们将修改文件以在新目标系统上安装 CentOS。在 nano 中，使用上下箭头键转到以（`<your_hostname>`将是您在安装过程中给出的主机名，例如`minimal.home`）开头的行：

    ```
    network  --hostname=<your_hostname>

    ```

1.  现在，编辑`<your_hostname>`字符串，为其赋予一个新的唯一主机名。例如，在任何现有名称的末尾添加一个`-2`，如下所示：

    ```
    network  --hostname=minimal-2.home

    ```

1.  接下来，使用上下箭头键将光标向下移动，直到它停在写着`%packages.`的行上。在其下方附加以下行（您可以进一步自定义此设置，并提供您希望自动安装的其他软件包）：

    ```
    mariadb-server
    httpd
    rsync
    net-tools

    ```

1.  现在保存并关闭文件，在 nano 编辑器中，使用*Ctrl*+*o*键组合（这意味着，按住键盘上的*Ctrl*键，然后按*o*键，不要松开*Ctrl*键）来写入更改。然后按*Return*确认文件名，并按*Ctrl*+*x*退出编辑器。

1.  接下来，安装以下 CentOS 软件包：

    ```
    yum install system-config-kickstart

    ```

1.  现在，我们使用`ksvalidator`程序验证 kickstart 文件的语法，该程序包含在我们刚刚安装的软件包中：

    ```
    ksvalidator /mnt/kickstart-usb/anaconda-ks.cfg

    ```

1.  如果`config`文件没有错误，现在使用以下命令卸载 USB 闪存驱动器：

    ```
    cd
    umount /mnt/kickstart-usb

    ```

1.  当您再次获得新的命令提示符时，从系统中物理拔出包含 kickstart 文件的 USB 设备，以便在目标机器上使用。

1.  现在，您需要物理访问您想要安装 CentOS 的目标机器，使用刚刚创建的 kickstart 文件。断开任何其他不需要在安装过程中使用的外部文件存储设备。

1.  开启计算机并插入准备好的 CentOS 安装介质（必须是 CentOS DVD 或 Everything 安装盘镜像，准备在 CD/DVD 光盘或 USB 设备安装器上）。同时，将包含在先前步骤中创建的 kickstart 文件的 USB 闪存驱动器连接到计算机（如果使用 USB 驱动器安装 CentOS，则总共需要两个空闲的 USB 端口来完成此操作）。

1.  接下来，启动服务器并在初始启动屏幕期间按下与引导您刚刚连接的 CentOS 安装介质相关的正确键。

1.  在 CentOS 安装程序开始加载后，将显示常见的标准 CentOS 7 安装欢迎屏幕，并且**测试此媒体并安装 CentOS 7**选项将由光标预先选中。

1.  接下来，在键盘上按一次*Esc*键，切换到`boot: prompt`。

1.  现在我们准备好开始 kickstart 安装了。为此，您需要知道 USB 设备上 kickstart 文件所在的确切分区名称。输入以下命令，假设您的分区位于`/dev/sdc1`（根据需要更改此设置），然后按*Return*键开始 kickstart 安装过程：

    ```
    linux ks=hd:sdc1:/anaconda-ks.cfg

    ```

    ### 注意

    如果你无法找到 USB 闪存盘的正确设备和分区名称，你需要在救援模式下启动目标系统（参考*在救援模式下排除系统故障*的解决方案），通过比较其大小、分区以及识别的文件系统与你的闪存盘规格来确定正确的设备名称和分区号。

1.  现在，新系统将自动使用提供的 kickstart 文件中的指令进行安装。你可以查看安装输出消息，因为它会向用户显示详细的安装进度。

1.  如果系统安装完成，重启系统并登录到你的新机器，以验证新系统是否按照我们使用 kickstart 文件描述的方式进行了设置。

## 它是如何工作的...

在这个解决方案中，你已经看到，每个运行 CentOS 7 安装的服务器都在其根目录中保留了 kickstart 文件，该文件包含了系统安装过程中设置的详细信息。kickstart 文件可以用来自动化多个具有相同配置的系统的安装。这可以节省大量时间，因为安装过程中不需要用户交互。此外，如果目标机器的 RAM 不符合图形化安装的最低要求，但需要文本模式安装器不提供的其他功能（如自定义分区），我们也可以使用这种方法。kickstart 配置文件是简单的纯文本文件，可以手动从头创建。由于使用 kickstart 语法构建系统有相当多的不同命令，我们使用了一个现有的文件作为模板，并对其进行了定制以满足我们的需求，而不是完全从头开始。我们没有使用最小化安装镜像来驱动我们的 kickstart 安装，因为我们安装了一些额外的软件包，这些软件包不包含在最小化 ISO 文件中，例如 Apache Web 服务器。

# 开始和自定义引导加载程序

当你打开计算机时，引导加载程序是第一个启动的程序，负责加载并将控制权转移到下层的操作系统。如今，几乎任何现代 Linux 发行版都使用**GRand Unified Bootloader 版本 2**（**GRUB2**）来启动系统。它在配置上非常灵活，并支持许多不同的操作系统。在这个解决方案中，我们将展示如何通过禁用菜单显示的等待时间来定制 GRUB2 引导加载程序，从而提高系统启动时间。

## 准备工作

要完成这个解决方案，你需要访问一个已经安装了 CentOS 7 操作系统（最小化安装或其他类型的 CentOS 7 安装都可以）的系统，并具有 root 权限。此外，你还需要具备使用文本编辑器（如 nano）修改配置文件的基本经验。

## 如何操作...

我们通过使用我们选择的文本编辑器打开主 GRUB2 配置文件并对其进行修改，开始这个食谱。

1.  首先以 root 身份登录到你的系统，并为 GRUB2 配置文件创建一个备份副本，以备需要时回滚。按下*返回*键完成：

    ```
    cp /etc/default/grub /etc/default/grub.BAK

    ```

1.  使用以下命令打开我们要编辑的主 GRUB2 配置文件，并按下*返回*键（这里我们将使用编辑器 nano，如果你还没有安装它，请输入`yum install nano`）：

    ```
    nano /etc/default/grub

    ```

1.  在光标所在的第一行按下*返回*键插入新行，然后插入以下行：

    ```
    GRUB_HIDDEN_TIMEOUT=0

    ```

1.  在以下行的开头添加一个`#`符号，如下所示：

    ```
    GRUB_TIMEOUT=0

    ```

1.  现在在 nano 中使用*Ctrl*+*o*保存文件（并按*返回*确认保存的文件名）。使用*Ctrl*+*x*退出编辑器，然后运行以下命令：

    ```
    dmesg | grep -Fq "EFI v"

    ```

1.  如果前面的命令没有产生任何输出，运行以下命令：

    ```
    grub2-mkconfig -o /boot/grub2/grub.cfg

    ```

1.  否则，如果有输出，运行：

    ```
    grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg

    ```

1.  如果`grub2-mkconfig`成功，它将打印`Done.`。现在使用以下命令重新启动你的系统：

    ```
    reboot

    ```

1.  在重启过程中，你会发现 GRUB2 引导菜单不再出现，系统将更快地启动。

## 它是如何工作的...

完成这个食谱后，我们现在知道如何自定义 GRUB2 引导加载程序。在这个非常简单的食谱中，我们只向你展示了引导加载程序的一些基本修改，但它可以做更多！它支持广泛的文件系统，并且可以启动几乎任何兼容的操作系统。如果你计划在同一台机器上运行多个操作系统，这也是特别有用的。要了解更多关于 GRUB2 配置文件语法的信息，请输入`info grub2` | `less`命令，并转到`6.1 简单配置处理`部分（阅读第二章，*系统配置*中的食谱*使用 less 浏览文本文件*，了解如何浏览此文档）。

# 在救援模式下排除系统故障

我们都会犯错，这对新手 Linux 系统管理员尤其如此。Linux 的学习曲线可能很陡峭，迟早会在你的职业生涯中遇到 CentOS 安装由于各种原因无法启动的情况，包括硬件问题或人为错误，如配置错误。如果这种情况发生在你身上，那么你可以使用 CentOS 救援模式来启动一个无法启动的系统，并尝试撤消你的错误或找出问题的根源。在本食谱中，我们将向你展示三个常见的情况，何时使用此选项：

+   访问文件系统以恢复重要数据或撤消对配置文件的更改，如果 CentOS 无法启动

+   更改 root 密码，如果你忘记了它

+   重新安装引导加载程序，这可能在同一硬盘上安装另一个操作系统时损坏 CentOS

## 准备就绪

要完成此操作，您需要一个标准的 CentOS 7 操作系统安装媒体（CD/DVD 或 USB 设备）。为了从系统中恢复数据，您需要将某种外部存储设备连接到系统，例如外部硬盘或一个正常工作的网络连接到另一台计算机，以便将所有珍贵数据复制到不同位置。

## 如何操作...

要开始此操作，您应该从 CentOS 安装 CD/DVD 或 USB 设备启动服务器，并等待直到第一个欢迎屏幕出现，光标等待在**测试此媒体并安装 CentOS 7**菜单选项上。

### 进入救援模式

1.  从主菜单中，使用向下箭头键选择**故障排除**，然后按*回车*键继续。

1.  在**故障排除**屏幕上，使用向下箭头键高亮显示**救援 CentOS 系统**。准备就绪后，按*回车*键继续。

1.  经过一些加载时间后，我们进入救援屏幕，其中包括各种确认子屏幕。要开始此部分，使用左右箭头键选择**继续**，然后按*回车*键继续。

1.  在第一个子屏幕上，选择**确定**并按*回车*键继续。

1.  同样，在接下来的子屏幕中，选择**确定**并按*回车*键继续。

1.  在下一个屏幕上，选择**启动**shell，并使用*Tab*键，高亮显示**确定**，然后按*回车*键继续。

1.  完成上述步骤后，将启动一个 shell 会话。您将在显示屏底部注意到这一点。shell 会话的当前状态将显示如下：

    ```
    bash-4.2#_

    ```

1.  在提示符下，输入以下指令以更改根文件系统，然后在按*回车*键完成您的请求之前：

    ```
    chroot /mnt/sysimage

    ```

1.  恭喜！您已进入救援模式。在任何时候退出，只需输入以下命令，然后按*回车*键以完成您的请求（现在不要这样做，因为这将重启系统）：

    ```
    reboot

    ```

1.  在基本救援模式达到后，我们根据问题的类型有以下选项。

### 访问文件系统

如果您现在处于救援模式并需要从文件系统备份重要文件，您需要一个数据传输的目的地位置。为了将我们想要从服务器恢复的数据传输到另一台计算机，请将外部 USB 设备物理连接到它。您也可以使用网络存储进行恢复。例如，您可以导入 NFS 服务器共享并将数据复制到它。请参阅第七章，*构建网络*中的*使用 NFS*操作。

1.  在救援模式命令行中，输入以下命令，该命令将显示系统上所有当前连接的分区，然后按*回车*键完成您的请求：

    ```
    fdisk -l

    ```

1.  现在，您需要找出连接设备的正确设备名称和分区号；比较各个设备的总大小或文件系统输出与您的 USB 设备的规格可以帮助您完成此过程。您还可以尝试以下技巧：运行`fdisk -l`命令两次，第一次插入 USB 设备，然后再次拔出 USB 设备，并比较两个命令的输出。应该会有一个设备名称不同，这就是您正在寻找的！

1.  如果在列表中找到了正确的设备名称，请创建一个目录以将 USB 设备挂载到文件系统：

    ```
    mkdir /mnt/hdd-recovery

    ```

1.  接下来，将磁盘分区挂载到此文件夹。这里我们假设感兴趣的 USB 设备的设备名称为`sdd1`（如果您的系统不同，请更改）：

    ```
    mount /dev/sdd1 /mnt/hdd-recovery

    ```

1.  救援系统自动将原始系统的硬盘的根分区挂载在特定文件夹下（位于`/mnt/sysimage`下），如果需要访问它，例如更改导致启动问题的配置文件或进行完整或部分备份。例如，如果需要备份 Apache Web 服务器配置文件，请使用：

    ```
    cp -r /mnt/sysimage/etc/http /mnt/hdd-recovery

    ```

1.  如果需要访问当前挂载的根分区以外的分区上的数据，请使用`fdisk -l`来识别感兴趣的分区。然后创建一个目录，将分区挂载到该目录，并切换到该目录以访问数据，就像挂载 USB 设备时所做的那样。

1.  要完成备份文件，请输入：

    ```
    reboot

    ```

### 访问文件系统

1.  如果在救援模式下更改 root 密码，只需使用以下命令并提供新密码：

    ```
    passwd

    ```

1.  要完成更改密码，请输入：

    ```
    reboot

    ```

### 重新安装 CentOS 引导加载程序

1.  现在，我们将使用`fdisk`命令来查找所有当前分区的名称。为此，请输入以下指令，然后按*回车*键以完成请求：

    ```
    fdisk –l

    ```

1.  现在运行以下命令：

    ```
    dmesg | grep -Fq "EFI v"

    ```

1.  如果前面的命令没有产生任何输出，请在`fdisk`列表的引导列中查找`*`符号以找到正确的起始分区，并假设您的引导磁盘位于`/dev/sda1`（根据需要更改此设置），请输入以下内容：

    ```
    grub2-install /dev/sda

    ```

1.  否则，如果有输出，请运行以下命令：

    ```
    yum reinstall grub2-efi shim

    ```

1.  如果没有错误报告，控制台应响应如下：

    ```
    # this device map was generated by anaconda
    (hd0) /dev/sda

    ```

1.  最后一步的控制台输出确认 GRUB 已成功恢复。

1.  要重新启动计算机，请输入：

    ```
    reboot

    ```

## 它是如何工作的...

救援模式环境提供的工具可以解决各种广泛的问题。这些问题通常涉及启动问题，但也可能来自其他类型，例如忘记 root 密码。救援模式可以救急，掌握它是一项非常重要的技能。因此，我们认为应该将这样的操作指南放在手边。

### 提示

请记住，在处理引导加载程序命令时要小心，因为不当使用可能会导致操作系统无法启动。

# 更新安装并增强最小化安装，添加额外的管理和开发工具

在本食谱中，我们将学习如何通过添加额外的工具来增强最小化安装，这些工具将为你提供各种管理和开发选项，反过来，在你的服务器生命周期中证明是至关重要的，并且对于本书中的一些食谱来说是必不可少的。最小化安装可能是最有效的服务器安装方式，但即便如此，最小化安装确实需要一些额外的功能，以使其成为一个更具吸引力的模型。

## 准备就绪

要完成这个食谱，你需要一个具有 root 权限的 CentOS 7 操作系统的最小化安装，并且需要连接到互联网，以便下载额外的包。

## 如何做到这一点...

我们将从这个食谱开始更新系统。

1.  要更新系统，请以 root 身份登录并输入：

    ```
    yum -y update

    ```

1.  CentOS 现在将搜索相关的更新，如果可用，它们将被安装。完成后，根据更新了什么（即内核和新安全功能等），你可以决定重新启动计算机。要这样做，请输入：

    ```
    reboot

    ```

1.  你的服务器现在将重新启动并返回到登录屏幕。我们现在将完成这个食谱，并通过一系列包组来增强我们当前的安装，这些包组在未来将证明非常有用。要这样做，请以 root 身份登录并输入：

    ```
    yum -y groupinstall "Base" "Development Libraries" "Development Tools"
    yum -y install policycoreutils-python

    ```

## 它是如何工作的...

本食谱的目的是增强 CentOS 7 操作系统的最小化安装，通过这样做，你不仅介绍了自己给**Yellowdog Updater Modified**（**YUM**）包管理器（我们将在本书后面再次回到这一点），而且你现在拥有了一个能够运行大量应用程序的系统，开箱即用。

那么我们从这次经历中学到了什么？

我们首先通过更新系统来开始这个配置过程，以确保系统是最新的。在这个阶段，通常重启系统是个好主意。虽然我们不期望经常这样做，但在安装操作系统后首次更新时是必要的，因为很可能有重大的更新可用。这样做的原因通常是基于希望利用新的内核或更新的安全补丁。在下一阶段，配置过程展示了如何添加一系列可能在将来证明非常有用的软件包组。为了节省时间，我们将安装三个主要软件包组的指令打包在一起：`Base`、`Development Libraries` 和 `Development Tools`。仅此一项操作就安装了超过 200 个单独的软件包，从而使您的服务器能够编译代码并运行大量即装即用的应用程序，这些应用程序可能在服务器的整个生命周期内都需要。要查看某个组中所有软件包的列表，例如 `Base` 组，可以运行 `yum groupinfo Base` 命令。我们还安装了 `policycoreutils-python` 软件包，它提供了管理 Linux 安全增强访问控制的工具和程序，我们将在本书的各个章节中频繁使用这些工具。


# 第二章：配置系统

在本章中，我们将涵盖以下主题：

+   使用 less 浏览文本文件

+   介绍 Vim

+   使用正确的语言

+   使用 NTP 和 chrony 套件同步系统时钟

+   设置主机名并解析网络

+   成为超级用户

+   建立静态网络连接

+   自定义系统横幅和消息

+   初始化内核

# 介绍

本章是一系列涵盖建立服务器基本需求的基本实践的集合。对于许多人来说，构建服务器可能常常看起来是一项艰巨的任务，因此本章的目的是为您提供一种即时方法来实现所需的目标。

# 使用 less 浏览文本文件

在本书中，您将经常使用使用 less 程序或类似导航的程序和工具来查看和阅读文件内容或显示输出。起初，控制可能会显得有些不直观。在本节中，我们将向您展示如何使用 less 控制来浏览文件的基本知识。

## 准备工作

要完成本节内容，您需要一个具有 root 权限的 CentOS 7 操作系统的有效安装。

## 如何操作...

1.  首先，以 root 身份登录并输入以下命令以打开使用 less 进行导航的程序：

    ```
    man man

    ```

1.  要导航，请按*上*和*下*键以逐行滚动，按*空格键*以向下滚动一页，按*b*键以向上滚动一页。您可以使用正斜杠键*/*在文本中搜索，然后输入搜索词，按*Return*键进行搜索。按*n*键跳转到下一个搜索结果。按*q*键退出。

## 工作原理...

在这里，在这篇简短的节中，我们向您展示了 less 导航的基本知识，这对于阅读 man 页面至关重要，并且在本书中被许多其他程序用于显示文本。我们只向您展示了基本命令，还有很多需要学习。请阅读 less 手册以了解更多关于`man less`命令的信息。

# 介绍 Vim

在本节中，我们将简要介绍文本编辑器 Vim，它是本书中使用的标准文本编辑器。您也可以使用您喜欢的任何其他文本编辑器，例如 nano 或 emacs。

## 准备工作

要完成本节内容，您需要一个具有 root 权限的 CentOS 7 操作系统的有效安装。

## 如何操作...

我们将从安装`vim-enhanced`包开始本节，因为它包含一个您可以用来学习使用 Vim 的教程：

1.  首先，以 root 身份登录并安装以下包：

    ```
    yum install vim-enhanced

    ```

1.  之后，输入以下命令以启动 Vim 教程：

    ```
    vimtutor

    ```

1.  这将打开 Vim 教程，在 Vim 编辑器中。要导航，请按*上*和*下*键以逐行滚动。要退出教程，请按*Esc*键，然后输入`:q!`，接着按*Return*键退出。

1.  现在，你应该阅读文件并学习课程，以获得对 Vim 的基本理解，学习如何编辑你的文本文件。

## 它是如何工作的...

本配方中显示的教程应该被视为学习 Linux 最强大和有效的文本编辑器之一的基础知识的起点。Vim 的学习曲线非常陡峭，但如果你花大约半小时的时间来学习 vimtutor 指南，你应该能够毫无问题地完成所有常见的文本编辑任务，例如打开、编辑和保存文本文件。

# 说正确的语言

在本配方中，我们将向你展示如何为整个系统和单个用户更改 CentOS 7 安装的语言设置。更改这个的需求很少，但可能是重要的，例如，如果我们不小心在安装过程中选择了错误的语言。

## 准备工作

要完成这个配方，你需要一个具有 root 权限的 CentOS 7 操作系统的工作安装，以及你选择的基于控制台的文本编辑器。你应该已经阅读了*使用 less 导航文本文件*配方，因为本配方中的一些命令将使用 less 来打印输出。

## 如何做到这一点...

如果你想更改 CentOS 7 系统的系统范围语言设置，你需要调整两个类别的设置。我们首先更改系统区域设置信息，然后更改键盘设置：

1.  首先，以 root 用户身份登录并输入以下命令，以显示控制台、图形窗口管理器（X11 布局）的当前区域设置，以及当前键盘布局：

    ```
    localectl status

    ```

1.  接下来，要更改这些设置，我们首先需要了解系统上所有可用的区域设置和键盘设置（两个命令都使用`less`导航）：

    ```
    localectl list-locales
    localectl list-keymaps

    ```

1.  如果你在我们的示例中从上面的输出中选择了正确的区域设置，`de_DE.utf8`和`keymap de-mac`（根据你自己的适当需求进行更改），你可以使用以下命令更改你的区域设置和键盘设置：

    ```
    localectl set-locale LANG=de_DE.utf8
    localectl set-keymap de-mac

    ```

1.  现在，使用相同的命令再次验证你的更改的持久性：

    ```
    localectl status

    ```

## 它是如何工作的...

正如我们所见，`localectl`命令是一个非常方便的工具，可以管理 CentOS 7 系统中所有重要的语言设置。

那么我们从这次经历中学到了什么？

我们首先以 root 用户身份登录到命令行。然后，我们使用`status`参数运行`localectl`命令，这为我们提供了系统当前语言设置的概览。该命令的输出向我们展示了 CentOS 7 系统中的语言属性可以分为区域设置（系统区域设置）和键盘映射（VC 键盘映射和所有 X11 布局属性）设置。

Linux 上的区域设置用于设置系统的语言以及其他特定于语言的属性。这可以包括来自错误消息、日志输出、用户界面以及如果您使用的是 Gnome 等窗口管理器，甚至是 **图形用户界面**（**GUI**）的文本。区域设置还可以定义特定于区域的格式，例如纸张尺寸、数字及其自然排序、货币信息等。它们还定义字符编码，如果您选择了一种具有无法在标准 ASCII 编码中找到的字符的语言，这可能很重要。

另一方面，键盘映射设置定义了键盘上每个键的确切布局。

接下来，要更改这些设置，我们首先使用 `localectl` 命令和 `list-locales` 参数来检索系统上所有区域设置的完整列表，以及 `list-keymaps` 来显示系统上所有键盘设置的列表。从 `list-locales` 参数输出的区域设置使用非常紧凑的注释来定义语言：

```
Language[_Region][.Encoding][@Modificator]

```

只有 `Language` 部分是强制性的，其余部分都是可选的。语言和地区的示例包括：`en_US` 表示英语和美国地区或美式英语，`es_CU` 表示西班牙语和古巴地区或古巴西班牙语。

编码对于特殊字符（如德语变音符号或法语重音符号）很重要。这些特殊字符的内存表示可以根据所使用的编码类型以不同的方式解释。通常应使用 UTF-8，因为它能够对每种语言中的几乎任何字符进行编码。

修饰符用于更改由区域设置定义的设置。例如，`sr_RS.utf8@latin` 用于您希望为塞尔维亚的塞尔维亚语提供拉丁语设置，而通常使用西里尔语定义。这将更改为西方设置，例如排序、货币信息等。

要更改实际的区域设置，我们使用了 `set-locale LANG=de_DE.utf8` 参数。在这里，编码被选择来正确显示德语变音符号。请注意，我们使用了 `LANG` 选项来为所有可用的区域设置选项设置相同的区域设置值（例如，`de_DE.utf8`）。如果您不想为所有可用选项设置相同的区域设置值，您可以使用更精细的控制来控制单个区域设置选项。请参考使用手册页的区域设置描述，`man 7 locale`（在最小安装上；您需要在使用 `yum install man-pages` 命令之前安装所有 Linux 文档手册页）。您可以使用类似的语法设置这些附加选项，例如，要设置时间区域设置，请使用：

```
localectl set-locale LC_TIME="de_DE.utf8"

```

接下来，我们使用`list-keymaps`参数显示所有可用的键盘映射代码。正如我们从运行`localectl status`中看到的，键盘映射可以分为非图形（VC 键盘映射）和图形（X11 布局）设置，这允许在使用 Gnome 等窗口管理器时以及在控制台中灵活配置不同的键盘布局。运行带有参数`set-keymap de-mac`的`localectl`命令，将当前键盘映射设置为德国苹果 Macintosh 键盘模型。此命令将给定的键盘类型应用于正常的 VC 和 X11 键盘映射。如果希望 X11 与控制台的映射不同，请使用`localectl --no-convert set-x11-keymap cz-querty`，其中我们使用`cz-querty`作为键盘映射代码到捷克 querty 键盘模型（根据需要更改此设置）。

## 还有更多…

有时，单个系统用户需要与系统区域设置（只能由 root 用户设置）不同的语言设置，根据他们的区域键盘差异以及与系统交互时使用他们首选的人类语言。只要没有被本地环境变量覆盖，系统范围的区域设置就会由每个用户继承。

### 注意

更改系统范围的区域设置并不一定会影响用户已为自己定义的其他区域设置。

要打印任何系统用户的当前区域设置环境变量，我们可以使用命令`locale`。要设置具有适当变量名称的单个环境变量；例如，要将时间区域设置为美国时间，我们将使用以下行：

```
export LC_TIME="en_US.UTF-8"

```

但是，我们很可能希望将所有区域设置更改为相同的值；这可以通过设置`LANG`来实现。例如，要将所有区域设置更改为美式英语，请使用以下行：

```
export LANG="en_US.UTF-8"

```

要测试区域设置更改的效果，我们现在可以生成一个错误消息，该消息将显示在由`locale`命令设置的语言中。以下是将区域设置从英语更改为德语的不同语言输出：

```
export LANG="en_US.UTF-8"
ls !

```

以下输出将被打印：

```
ls: cannot access !: No such file or directory

```

现在，更改为德语区域设置：

```
export LANG="de_DE.UTF-8"
ls !

```

以下输出将被打印：

```
ls: Zugriff auf ! nicht möglich: Datei oder Verzeichnis nicht gefunden

```

在活动控制台中使用`export`命令设置区域设置不会在关闭窗口或打开新终端会话后继续存在。如果希望使这些更改永久生效，可以在主目录中的名为`.bashrc`的文件中设置任何区域设置环境变量，例如`LANG`变量，该文件将在每次打开 shell 时读取。在我们的示例中，要将区域设置永久更改为`de_DE.UTF-8`（根据需要更改此设置），请使用以下行：

```
echo "export LANG='de_DE.UTF-8'" >> ~/.bashrc

```

# 使用 NTP 和 chrony 套件同步系统时钟

在本食谱中，我们将学习如何使用**网络时间协议**（**NTP**）和 chrony 套件将系统时钟与外部时间服务器同步。从需要为文档、电子邮件和日志文件打时间戳，到安全运行和调试网络，或者仅仅与共享设备和服务交互，您的服务器上的所有操作都依赖于保持一个准确的系统时钟，本食谱的目的就是向您展示如何实现这一点。

## 准备工作

要完成本食谱，您需要一个具有 root 权限的 CentOS 7 操作系统的工作安装，您选择的基于控制台的文本编辑器，以及连接到互联网以便下载额外软件包的能力。

## 如何操作...

在本食谱中，我们将使用`chrony`服务来管理我们的时间同步。由于 chrony 在 CentOS 最小化安装中默认未安装，我们将从安装它开始：

1.  首先，以 root 身份登录并安装`chrony`服务，然后启动它并验证它是否正在运行：

    ```
    yum install -y chrony
    systemctl start chronyd
    systemctl status chronyd

    ```

1.  此外，如果我们想让 chrony 永久运行，我们需要在服务器启动时启用它：

    ```
    systemctl enable chronyd

    ```

1.  接下来，我们需要检查系统是否已经使用 NTP 通过网络同步我们的系统时钟：

    ```
    timedatectl  | grep "NTP synchronized"

    ```

1.  如果上一步的输出显示`NTP 同步`为`否`，我们需要使用以下命令启用它：

    ```
    timedatectl set-ntp yes

    ```

1.  如果您再次运行第 3 步中的命令，您应该会看到它现在正在同步 NTP。

1.  chrony 的默认安装将使用一个可以访问原子钟的公共服务器，但为了优化服务，我们需要对使用哪些时间服务器进行一些简单的更改。为此，使用您喜欢的文本编辑器打开主要的 chrony 配置文件，如下所示：

    ```
    vi /etc/chrony.conf

    ```

1.  在文件中，向下滚动并查找包含以下内容的行：

    ```
    server 0.centos.pool.ntp.org iburst
    server 1.centos.pool.ntp.org iburst
    server 2.centos.pool.ntp.org iburst
    server 3.centos.pool.ntp.org iburst

    ```

1.  用首选本地时间服务器的列表替换显示的值：

    ```
    server 0.uk.pool.ntp.org iburst
    server 1.uk.pool.ntp.org iburst
    server 2.uk.pool.ntp.org iburst
    server 3.uk.pool.ntp.org iburst

    ```

    ### 注意

    访问[`www.pool.ntp.org/`](http://www.pool.ntp.org/)以获取一份地理位置接近您当前位置的本地服务器列表。请记住，使用三个或更多服务器往往有助于提高 NTP 服务的准确性。

1.  完成后，保存并关闭文件，然后使用`sytstemctl`命令同步您的服务器：

    ```
    systemctl restart chronyd

    ```

1.  要检查`config`文件中的修改是否成功，您可以使用以下命令：

    ```
    systemctl status chronyd

    ```

1.  要检查 chrony 是否正在处理您的系统时间同步，请使用以下命令：

    ```
    chronyc tracking

    ```

1.  要检查 chrony 用于同步的网络源，请使用以下命令：

    ```
    chronyc sources

    ```

## 工作原理...

我们的 CentOS 7 操作系统在每次启动时都会根据硬件时钟设置时间，这是一个位于计算机主板上的小型电池驱动时钟。通常，这个时钟不够准确或者设置不正确，因此最好从互联网上的可靠来源（使用真正的原子时间）获取系统时间。chrony 守护进程`chronyd`通过使用 NTP 协议与远程服务器进行通信的过程来设置和维护系统时间。

那么，我们从这次经历中学到了什么？

作为第一步，我们安装了`chrony`服务，因为它在 CentOS 7 最小安装中默认不可用。之后，我们使用`timedatectl set-ntp yes`命令启用了系统时间与 NTP 的同步。

之后，我们打开了主要的 chrony 配置文件`/etc/chrony.conf`，并展示了如何更改使用的外部时间服务器。如果您的服务器位于企业防火墙后面并且拥有自己的 NTP 服务器基础设施，这尤其有用。

重新启动服务后，我们学习了如何使用`chronyc`命令检查和监视我们的新配置。这是一个有用的命令行工具（c 代表客户端），用于与 chrony 守护进程（本地或远程）交互和控制。我们使用`tracking`参数与`chronyc`一起使用，这向我们展示了与特定服务器的当前 NTP 同步过程的详细信息。如果您需要进一步帮助关于输出中显示的属性，请参考`chronyc`命令的`man`页面（`man chronyc`）。

我们还使用`sources`参数与`chronyc`程序一起使用，这向我们展示了使用的 NTP 时间服务器的概述。

您还可以使用较旧的`date`命令来验证正确的时间同步。重要的是要意识到同步服务器的过程可能不是即时的，并且可能需要一段时间才能完成。然而，您现在可以放心地知道，您现在知道如何安装、管理和使用 NTP 协议同步时间。

## 还有更多...

在本食谱中，我们使用`chrony`服务和 NTP 协议设置系统时间。通常，系统时间设置为**协调世界时**（**UTC**）或世界时间，这意味着它是全球统一使用的一种标准时间。从它开始，我们需要使用时区来计算我们的本地时间。要找到正确的时间区域，请使用以下命令（阅读*使用 less 浏览文本文件*食谱以处理输出）：

```
timedatectl list-timezones

```

如果您找到了正确的时间区域，请记下来并在下一个命令中使用它；例如，如果您位于德国并且靠近柏林市，请使用以下命令：

```
timedatectl set-timezone Europe/Berlin

```

再次使用`timedatectl`检查您的本地时间是否正确：

```
timedatectl | grep "Local time"

```

最后，如果它是正确的，您可以同步硬件时钟与系统时间以使其更精确：

```
hwclock --systohc

```

# 设置主机名和解决网络问题

设置主机名的过程通常与安装过程相关联。如果您需要更改它或您服务器的**域名系统**（**DNS**）解析器，本指南将向您展示如何操作。

## 准备

要完成本指南，您需要具备具有 root 权限的 CentOS 7 操作系统的有效安装，以及您选择的基于控制台的文本编辑器。

## 如何操作...

要开始本指南，我们将首先以 root 身份访问系统并打开以下文件，以便为您的当前服务器命名或重命名主机名：

1.  以 root 身份登录并输入以下命令以查看当前主机名：

    ```
    hostnamectl status

    ```

1.  现在，将主机名值更改为您的首选名称。例如，如果您想将服务器称为`jimi`，您将输入（适当更改）：

    ```
    hostnamectl set-hostname jimi

    ```

    ### 注意

    静态主机名区分大小写，并且限制为使用互联网友好的字母数字字符串。总长度不应超过 63 个字符，但尽量保持更短。

1.  接下来，我们需要服务器的 IP 地址。输入以下命令以查找它（您需要在输出中识别正确的网络接口）：

    ```
    ip addr list

    ```

1.  之后，我们将设置**完全限定域名**（**FQDN**），为此，我们需要打开并编辑主机文件：

    ```
    vi /etc/hosts

    ```

1.  在这里，您应该添加一条符合您需求的新行。例如，如果您的服务器主机名称为 jimi（IP 地址为`192.168.1.100`，域名为`henry.com`），您需要追加的最终行将如下所示：

    ```
    192.168.1.100        jimi.henry.com jimi

    ```

    ### 注意

    对于仅在本地网络上找到的服务器，建议使用非基于互联网的顶级地址。例如，您可以使用`.local`或`.lan`，甚至是`.home`，通过使用这些引用，您将避免与典型的`.com`、`.co.uk`或`.net`域名混淆。

1.  接下来，我们将打开`resolv.conf`文件，该文件负责配置系统将使用的静态 DNS 服务器地址：

    ```
    vi /etc/resolv.conf

    ```

1.  用以下内容替换文件内容：

    ```
    # use google for dns
    nameserver 8.8.8.8
    nameserver 8.8.4.4

    ```

1.  完成后，保存并关闭文件，然后重新启动服务器以使更改立即生效。为此，请返回控制台并输入：

    ```
    reboot

    ```

1.  成功重启后，您可以通过输入以下命令并等待响应来检查您的新主机名和 FQDN：

    ```
    hostname --fqdn

    ```

1.  要测试我们是否可以使用静态 DNS 服务器地址将域名解析为 IP 地址，请使用以下命令：

    ```
    ping -c 10 google.com

    ```

## 它是如何工作的...

主机名是为网络上的机器创建的唯一标签。它限制为基于字母数字的字符，并且可以通过使用`hostnamectl`命令来更改服务器的主机名。DNS 服务器用于将域名翻译成 IP 地址。有多个公共 DNS 服务器可用；在后面的指南中，我们将构建我们自己的 DNS 服务。

那么，我们从这次经历中学到了什么？

在本食谱的第一阶段，我们使用`hostnamectl`命令更改了服务器当前使用的主机名。该命令可以设置三种不同类型的主机名。使用带有`set-hostname`参数的命令将为所有三个主机名设置相同的名称：高级的`pretty`主机名，可能包含各种特殊字符（例如，`Lennart's Laptop`），静态主机名，用于在启动时初始化内核主机名（例如`lennarts-laptop`），以及瞬态主机名，它是从网络配置中接收的默认主机名。

接下来，我们设置了服务器的 FQDN。FQDN 是主机名加上其后的域名。当你运行私有 DNS 或允许外部访问你的服务器时，域名变得重要。除了使用 DNS 服务器设置 FQDN 外，还可以通过更新位于`/etc/hosts`的 hosts 文件来实现。

该文件由 CentOS 用于将主机名映射到 IP 地址，并且在新安装的、未配置的服务器上经常发现它是错误的。因此，我们首先必须使用`ip addr list`找出服务器的 IP 地址。

一个 FQDN 应该由一个简短的主机名和域名组成。根据本食谱中所示的示例，我们为名为`henry`的服务器设置了 FQDN，其 IP 地址为`192.168.1.100`，域名为`henry.com`。

保存此文件可以说完成了这个过程。然而，由于内核在启动过程中记录了主机名，因此别无选择，只能重启服务器才能使用更改后的设置。

接下来，我们打开了系统的`resolv.conf`文件，该文件保存了系统 DNS 服务器的 IP 地址。如果服务器没有使用或没有 DNS 记录，系统将无法在任何程序中使用域名作为网络目的地。在我们的示例中，我们输入了公共 Google DNS 服务器的 IP 地址，但你可以使用任何你想要或必须使用的 DNS 服务器（在企业环境中，在防火墙后面，你通常必须使用内部 DNS 服务器基础设施）。在成功重启后，我们使用`hostname`命令确认了你的新设置，该命令可以根据给定的参数打印出主机名或 FQDN。

因此，综上所述，可以说这个食谱不仅向你展示了如何重命名服务器和解决网络问题，还向你展示了主机名和域名之间的区别：

正如我们所学，服务器不仅可以通过更短、更易记、更快捷的单字节主机名来识别，还由三个用句点分隔的值组成（例如 jimi.henry.com）。这些值之间的关系可能在一开始显得奇怪，尤其是对于许多人来说，它们似乎是一个单一的值。但是，通过完成这个配方，您已经发现域名与主机名是不同的，因为域名是由解析器子系统确定的，只有将它们组合在一起，您的服务器才会产生整个系统的完全限定域名（FQDN）。

## 还有更多...

主机文件包含一系列 IP 地址及其对应的域名。如果您的网络中存在未在现有 DNS 记录中列出的 IP 地址的计算机，为了加快网络速度，通常建议您将这些计算机添加到此文件中。

此操作可在任何操作系统上实现，但在 CentOS 上，只需使用您喜欢的文本编辑器打开主机文件，如下所示：

```
vi /etc/hosts

```

现在，滚动到文件底部，通过将此处显示的域名和 IP 地址替换为更适合您自己需求的值，添加以下值：

```
192.168.1.100    www.example1.lan
192.168.1.101    www.example2.lan
```

您甚至可以使用外部地址，例如：

```
83.166.169.228  www.packtpub.com
```

这种方法为您提供了创建域名与 IP 地址映射的机会，无需使用 DNS。它可以应用于任何工作站或服务器。列表大小不受限制，您甚至可以使用这种方法通过将所有请求重定向到已知网站的不同 IP 地址来阻止对某些网站的访问。例如，如果`www.website.com`的真实地址是`192.168.1.200`，而您想限制对其的访问，只需在您希望阻止访问的计算机上对主机文件进行以下更改：

```
127.0.0.1    www.website.com
```

这并非万无一失，但在这种情况下，任何尝试访问`www.website.com`的系统都会自动被重定向到`127.0.0.1`，即本地网络地址，从而阻止访问。

完成操作后，请记得以常规方式保存并关闭文件，然后继续享受更快速、更安全的域名解析带来的好处，无论是在任何可用的网络上。

# 建立静态网络连接

在本配方中，我们将学习如何为新创建或现有的 CentOS 服务器配置静态 IP 地址。

虽然动态分配的 IP 地址或 DHCP 保留可能适用于大多数台式机和笔记本电脑用户，但如果您正在设置服务器，通常需要静态 IP 地址。从网页到电子邮件，从数据库到文件共享，静态 IP 地址将成为您的服务器提供一系列应用程序和服务的永久位置。本配方的目的是向您展示实现这一目标是多么容易。

## 准备就绪

要完成此操作，您需要一个具有 root 权限和您选择的基于控制台的文本编辑器的 CentOS 7 操作系统的工作安装。

## 如何操作...

为了本操作的目的，您将能够在目录`/etc/sysconfig/network-scripts/`中找到所有相关文件。首先，您需要找出要设置为静态的网络接口的正确名称。如果您需要将多个网络接口设置为静态，请为每个设备重复此操作。

1.  要执行此操作，以 root 身份登录并键入以下命令以获取系统所有网络接口的列表：

    ```
    ip addr list

    ```

1.  如果您只安装了一个网络卡，那么很容易找到其名称；只需选择未命名为`lo`（这是环回设备）的那个。如果您有多个，查看不同设备的 IP 地址可以帮助您选择正确的设备。在我们的示例中，设备名为`enp0s3`。

1.  接下来，备份网络接口配置文件（根据需要更改`enp0s3`部分，如果您的网络接口名称不同）：

    ```
    cp /etc/sysconfig/network-scripts/ifcfg-enp0s3/etc/sysconfig/network-scripts/ifcfg-enp0s3.BAK

    ```

1.  当您准备好继续时，在您最喜欢的文本编辑器中打开以下文件，如下所示：

    ```
    vi /etc/sysconfig/network-scripts/ifcfg-enp0s3

    ```

1.  现在，向下浏览文件并应用以下更改：

    ```
    NM_CONTROLLED="no"
    BOOTPROTO=none
    DEFROUTE=yes
    PEERDNS=no
    PEERROUTES=yes
    IPV4_FAILURE_FATAL=yes

    ```

1.  现在，通过根据需要自定义`XXX.XXX.XXX.XXX`的值来添加您的 IP 信息：

    ```
    IPADDR=XXX.XXX.XXX.XXX
    NETMASK= XXX.XXX.XXX.XXX
    BROADCAST= XXX.XXX.XXX.XXX

    ```

1.  我们现在必须添加一个默认网关。通常，这应该是您的路由器的地址。要执行此操作，只需在文件底部添加新行，如下所示，并根据需要自定义值：

    ```
    GATEWAY=XXX.XXX.XXX.XXX

    ```

1.  准备好后，保存并关闭文件，然后为要设置为静态的任何剩余以太网设备重复此步骤。执行此操作时，请记住为每个设备分配不同的 IP 地址。

1.  完成后，保存并关闭此文件，然后重新启动您的网络服务：

    ```
    systemctl restart network

    ```

## 它是如何工作的...

在本操作中，您已经看到了将服务器的 IP 地址从外部 DHCP 提供商获得的动态值更改为由您分配的静态值的过程。此 IP 地址现在将形成一个独特的网络位置，您将能够从中提供各种服务和应用程序。这是一个永久性的修改，是的，您可以说这个过程本身相对简单。

那么，我们从这次经历中学到了什么？

通过识别您选择的网络接口名称并创建原始以太网配置文件的备份来开始本教程，然后我们打开了位于`/etc/sysconfig/network-scripts/ifcfg-XXX`（其中`XXX`是您的接口名称，例如`enp0s3`）的配置文件。由于不再需要网络管理器的服务，我们通过将值设置为`no`来禁用`NM_CONTROLLED`。接下来，由于我们正在转向静态 IP 地址，`BOOTPROTO`已被设置为`none`，因为我们不再使用 DHCP。为了完成我们的配置更改，我们接着添加了特定的网络值，并设置了 IP 地址、子网掩码、广播和默认网关地址。

为了帮助创建静态 IP 地址，默认网关是一个非常重要的设置，因为它允许服务器通过路由器与更广阔的世界通信。

完成后，我们被要求保存并关闭文件，然后为任何剩余的以太网设备重复此步骤。完成这些操作后，我们被要求重新启动网络服务，以完成本教程并使我们的更改立即生效。

# 成为超级用户

在本教程中，我们将学习如何授予指定的用户或组执行各种具有提升权限的命令的能力。

在 CentOS Linux 系统中，许多文件、文件夹或命令只能由名为`root`的用户访问或执行，该用户可以控制 Linux 系统上的所有内容。每个系统拥有一个 root 用户可能满足您的需求，但对于那些希望获得更高灵活性、可靠的审计跟踪以及能够向选定的可信用户提供有限的管理权限的人来说，您来对地方了。本教程的目的是向您展示如何激活和配置**sudo**（**超级用户执行**）命令。

## 准备工作

为了完成本教程，您需要一个具有 root 权限的 CentOS 7 最小安装操作系统。假设您的服务器维护一个或多个用户（除了 root 之外），他们有资格获得这种权限提升。如果在安装过程中没有创建系统用户账户，请首先应用本教程，*管理用户及其组*，在第三章，*管理系统*。

## 如何操作...

为了开始本教程，我们将首先使用非特权用户测试`sudo`命令。

1.  首先，使用非 root 用户账户登录到您的系统，然后输入以下命令以验证`sudo`未启用（在提示时使用您的用户账户密码）：

    ```
    sudo ls /var/log/audit

    ```

1.  这将打印出以下错误输出，其中`<username>`是您当前登录的用户：

    ```
    <username> is not in the sudoers file.  This incident will be reported.

    ```

1.  现在，使用以下命令注销系统用户：

    ```
    logout

    ```

1.  接下来，以 root 身份登录并使用以下命令为非 root 用户赋予 sudo 权限（适当更改`<username>`）：

    ```
    usermod -G wheel <username>

    ```

1.  现在，你可以通过再次注销 root 并重新登录步骤 1 中的用户来测试`sudo`是否工作，然后再次尝试：

    ```
    sudo ls /var/log/audit

    ```

1.  祝贺你，现在你已经将一个普通用户设置为拥有 sudo 权限，可以查看和执行限制给 root 用户的文件和目录。

## 它是如何工作的...

与某些 Linux 发行版不同，CentOS 默认不提供 sudo。相反，你通常只被允许以 root 用户身份访问系统的受限部分。这提供了一定程度的安全性，但对于多用户服务器来说，除非你简单地为这些人提供完整的管理员 root 访问权限，否则几乎没有灵活性。这并不明智，因此本食谱的目的是向你展示如何为一个或多个用户提供执行具有提升权限的命令的权利。

那么，我们从这次经历中学到了什么？

我们首先以一个没有 root 权限或 sudo 权限的普通用户账户登录系统。使用这个用户，我们尝试列出一个通常只有 root 用户才能看到的目录，因此我们在其上应用了`sudo`命令。但失败了，给出了我们不在 sudoers 列表中的错误。

`sudo`命令为指定的用户或组提供了执行命令的能力，就像他们是 root 用户一样。所有操作都会被记录（在一个名为`/var/log/secure`的文件中），因此将会有所有命令和参数使用的痕迹。

我们随后以真正的 root 用户身份登录，并为希望获得 sudo 权限的系统用户添加了一个名为 wheel 的组。这个组被用作特殊的管理组，其所有成员都会自动获得 sudo 权限。

从现在开始，指定的用户可以使用 sudo 来执行任何具有提升权限的命令。为此，用户需要在任何命令前输入`sudo`这个词，例如，他们可以运行以下命令：

```
sudo yum update

```

系统会要求他们确认自己的用户密码（不是 root 密码！），在成功验证后，程序将以 root 用户身份执行。

最后，我们可以说在 CentOS Linux 系统上有三种成为 root 的方式：

首先，以真正的 root 用户身份登录系统。其次，你可以使用命令`su – root`，同时任何普通系统用户登录，输入 root 用户的密码以永久切换到 root shell 提示符。第三，你可以给一个普通用户 sudo 权限，以便他们可以使用自己的密码执行单个命令，就像他们是 root 用户一样，同时保持自己的登录状态。

### 注意

**sudo**（**超级用户执行**）不应与**su**（**替代用户**）命令混淆，后者允许你永久切换到另一个用户，而不是像 root 用户那样只执行单个命令。

`sudo`命令为拥有大量用户的服务器提供了极大的灵活性，其中一名管理员不足以管理整个系统。

# 自定义系统横幅和消息

在本食谱中，我们将学习如何在用户通过 SSH 或控制台成功登录到我们的 CentOS 7 系统，或在图形窗口管理器中打开新的终端窗口时显示欢迎消息。这通常用于向用户显示信息性消息，或出于法律原因。

## 准备就绪

要完成此食谱，你需要具有 root 权限的 CentOS 7 操作系统的最小安装和所选的基于控制台的文本编辑器。

## 如何操作...

1.  首先，使用你的 root 用户账户登录到你的系统，并使用你喜欢的文本编辑器创建以下新文件：

    ```
    vi /etc/motd

    ```

1.  接下来，我们将在此新文件中放入以下内容：

    ```
    ###############################################
    # This computer system is for authorized users only.
    # All activity is logged and regularly checked.
    # Individuals using this system without authority or
    # in excess of their authority are subject to
    # having all their services revoked...
    ###############################################

    ```

1.  保存并关闭此文件。

1.  恭喜，现在你已经为通过 ssh 或控制台成功登录系统的用户设置了横幅消息。

## 它是如何工作的...

出于法律原因，强烈建议计算机在允许用户登录之前显示横幅；律师建议，只有在犯罪者知道他打算获得未经授权的访问时，才能犯下未经授权访问的罪行。登录横幅是实现这一点的最佳方式。除了这个原因，你还可以向用户提供有用的系统信息。

那么，我们从这次经历中学到了什么？

我们从这个食谱开始，打开文件`/etc/motd`，代表每日消息；用户在控制台或 ssh 登录后将显示此内容。接下来，我们在该文件中放入标准的法律免责声明并保存文件。

## 还有更多...

正如我们所见，`/etc/motd`文件在用户成功登录系统后显示静态文本。如果你想在首次建立 ssh 连接时也显示一条消息，可以使用 ssh 横幅。默认情况下，ssh 守护进程配置文件中的横幅行为是禁用的，这意味着如果用户建立 ssh 连接，将不会显示任何消息。要启用此功能，请以 root 身份登录到服务器，使用你喜欢的文本编辑器打开`/etc/ssh/sshd_config`文件，并在文件末尾添加以下内容：

```
Banner /etc/ssh-banner

```

然后，创建并打开一个名为`/etc/ssh-banner`的新文件，并输入一个新的自定义 ssh 问候消息。

最后，使用以下命令重新启动你的 ssh 守护进程：

```
systemctl restart sshd.service

```

下次有人建立到你的服务器的 ssh 连接时，将打印出这条新消息。

`motd`文件只能打印静态消息和一些系统信息细节，但如果用户成功登录，则无法在其中生成真正的动态消息或使用 bash 命令。

此外，`motd`在非登录 shell 中不起作用，例如当你在图形窗口管理器中打开一个新的终端时。为了实现这一点，我们可以在`/etc/profile.d`目录中创建一个自定义脚本。如果用户登录到系统，该目录中的所有脚本都会自动执行。首先，我们删除`/etc/motd`文件中的任何内容，因为我们不想显示两个欢迎横幅。然后，我们打开新文件`/etc/profile.d/motd.sh`，使用文本编辑器创建一个自定义消息，例如以下内容，我们可以在其中使用 bash 命令并编写小脚本（使用反引号在该文件中运行 bash shell 命令）：

```
#!/bin/bash
echo -e "
##################################
#
# Welcome to `hostname`, you are logged in as `whoami`
# This system is running `cat /etc/redhat-release`
# kernel is `uname -r`
# Uptime is 
`uptime | sed 's/.*up ([^,]*), .*/1/'`
# Mem total `cat /proc/meminfo | grep MemTotal | awk {'print $2'}` kB
###################################"

```

# 初始化内核

Linux 内核是一个构成操作系统核心的程序。它可以直接访问底层硬件，并使用户能够通过 shell 与之交互。

在本食谱中，我们将学习如何通过使用动态加载的内核模块来初始化内核。内核模块是设备驱动程序文件（或文件系统驱动程序文件），它们为特定的硬件部件添加支持，以便我们可以访问它们。

作为系统管理员，你不会经常与内核模块打交道，但如果你遇到设备驱动问题或不支持的硬件，对它们有一个基本的了解可能是有益的。

## 准备就绪

要完成本食谱，你需要具备具有 root 权限的 CentOS 7 操作系统的最小安装。

## 如何做到这一点...

1.  首先，使用 root 用户账户登录到你的系统，并输入以下命令以显示当前加载的所有 Linux 内核模块的状态：

    ```
    lsmod

    ```

1.  在输出中，你将看到所有加载的设备驱动程序（模块）；让我们看看`cdrom`和`floppy`模块是否已被加载：

    ```
    lsmod | grep "cdrom\|floppy"

    ```

1.  在大多数服务器上，将会有以下输出：

    ```
    cdrom                  42556  1 sr_mod
    floppy                 69417  0

    ```

1.  现在，我们想要展示关于`sr_mod` cdrom 模块的详细信息：

    ```
    modinfo sr_mod

    ```

1.  接下来，从内核中卸载这两个模块（只有当模块和硬件已经在你的系统上被找到并加载时，你才能这样做；否则跳过此步骤）：

    ```
    modprobe -r -v sr_mod floppy

    ```

1.  检查模块是否已被卸载（输出现在应该是空的）：

    ```
    lsmod | grep "cdrom\|floppy"

    ```

1.  现在，要显示系统上所有可用的内核模块列表，请使用以下目录，你可以在其中浏览：

    ```
    ls /lib/modules/$(uname -r)/kernel

    ```

1.  让我们从子目录`/lib/modules/$(uname -r)/kernel/drivers/`中选择一个名为`bluetooth`的模块，并验证它尚未加载（输出应该是空的）：

    ```
    lsmod | grep btusb

    ```

1.  获取有关模块的更多信息：

    ```
    modinfo btusb

    ```

1.  最后，加载这个蓝牙 USB 模块：

    ```
    modprobe btusb

    ```

1.  再次验证它现在是否已加载：

    ```
    lsmod | grep "btusb"

    ```

## 它是如何工作的...

内核模块是系统硬件与内核和操作系统通信所需的驱动程序（此外，加载和启用文件系统也需要它们）。它们是动态加载的，这意味着只有驱动程序或模块在运行时加载，这反映了你自己的特定硬件。

那么，我们从这次经历中学到了什么？

我们开始使用`lsmod`命令查看系统中当前加载的所有内核模块。输出显示三列：模块名称、模块加载时占用的 RAM 量，以及使用该模块的进程数和使用它的其他模块的依赖项列表。接下来，我们检查内核是否已经加载了`cdrom`和`floppy`模块。在输出中，我们看到`cdrom`模块依赖于`sr_mod`模块。因此，接下来我们使用`modinfo`命令获取有关它的详细信息。在这里，我们了解到`sr_mod`是 SCSI `cdrom`驱动程序。

由于我们只在首次安装基础系统时需要软盘和 cdrom 驱动程序，我们现在可以禁用这些内核模块，为我们节省一些内存。我们使用`modprobe -r`命令卸载模块及其依赖项，并再次使用`lsmod`检查这是否成功。

接下来，我们浏览了标准内核模块目录（例如，`/lib/modules/$(uname -r)/kernel/drivers`）。`uname`子字符串命令打印出当前内核版本，以确保在系统上安装了多个内核版本后，我们总是列出当前内核模块。

这个内核模块目录使用子目录将系统上所有可用的模块结构化和分类。我们导航到`drivers/bluetooth`并选择了`btusb`模块。对`btusb`模块执行`modinfo`，我们发现它是通用蓝牙 USB 驱动程序。最后，我们决定我们需要这个模块，所以我们再次使用`modprobe`命令加载它。

## 还有更多...

重要的是要说明，使用`modprobe`命令加载和卸载内核模块不是持久的；这意味着如果你重新启动系统，所有对内核模块的更改都将消失。要在启动时加载内核模块，创建一个新的可执行脚本文件，`/etc/sysconfig/modules/<filename>.modules`，其中`<filename>`是你选择的名称。在那里，你放入`modprobe`执行命令，就像在正常命令行上一样。以下是启动时额外加载蓝牙驱动程序的示例，例如`/etc/sysconfig/modules/btusb.modules`：

```
#!/bin/sh
if [ ! -c /dev/input/uinput ] ; then
exec /sbin/modprobe btusb >/dev/null 2>&1
fi

```

最后，你需要通过以下行使你的新模块文件可执行：

```
chmod +x /etc/sysconfig/modules/btusb.modules

```

重启后，使用`lsmod`命令重新检查新模块的设置。

例如，要在启动时移除内核模块`sr_mod`，我们需要使用`rdblacklist`内核启动选项将模块名称列入黑名单。我们可以通过将此选项附加到 GRUB2 配置文件`/etc/default/grub`中的`GRUB_CMDLINE_LINUX`指令末尾来设置此选项，使其看起来像：

```
GRUB_CMDLINE_LINUX="rd.lvm.lv=centos/root rd.lvm.lv=centos/swap crashkernel=auto rhgb quiet rdblacklist=sr_mod"

```

如果你需要将多个模块列入黑名单，`rdblacklist`选项可以像`rdblacklist=sr_mod rdblacklist=nouveau`这样指定多次。

接下来，使用`grub2-mkconfig`命令重新创建 GRUB2 配置（要了解更多信息，请阅读第一章中的*入门和自定义引导加载程序*配方，*安装 CentOS*）。

```
grub2-mkconfig -o /boot/grub2/grub.cfg

```

最后，我们还需要使用位于`/etc/modprobe.d/`目录下您选择的`new.conf`文件中的黑名单指令来`blacklist`模块名称。

```
echo "blacklist sr_mod" >> /etc/modprobe.d/blacklist.conf

```


# 第三章：系统管理

在本章中，我们将涵盖以下主题：

+   了解和管理后台服务

+   解决后台服务问题

+   使用 journald 跟踪系统资源

+   配置 journald 以使其持久化

+   管理用户及其组

+   使用 cron 安排任务

+   使用 rsync 同步文件并执行更多操作

+   维护备份和创建快照

+   监控重要的服务器基础设施

+   使用 Git 和 Subversion 进行控制

# 简介

本章是一系列解决方案的集合，旨在提供基于性能的服务器维护需求。从监控可用磁盘空间，到处理系统服务和管理远程文件同步，本章的目的是展示你如何快速且轻松地掌握服务器维护任务。

# 了解和管理你的后台服务

系统服务是每个 Linux 服务器最基本的概念之一。它们是持续在你的系统中运行的程序，等待外部事件来处理某些事务或一直执行。通常，在使用服务器时，系统用户不会注意到这些正在运行的服务，因为它们作为后台进程运行，因此不可见。任何 Linux 服务器上都有许多服务一直在运行。这些可以是 Web 服务器、数据库、FTP、SSH 或打印、DHCP、或 LDAP 服务器等。在本操作方法中，我们将展示如何管理和处理它们。

## 准备就绪

要完成此操作，你需要一个具有 root 权限的 CentOS 7 操作系统的安装，以及你选择的基于控制台的文本编辑器，以及连接到互联网以便下载额外的软件包。这里展示的一些命令在其输出中使用了*less*导航。请阅读第二章，*系统配置*中的*使用 less 浏览文本文件*操作方法，以学习如何浏览它们。

## 如何操作...

`systemctl`是一个程序，我们将使用它在 CentOS 7 系统中管理所有后台服务任务。在这里，我们将展示如何使用它，以 Apache Web 服务器服务为例，以便熟悉它。要全面了解 Apache，请阅读第十二章，*提供 Web 服务*：

1.  首先，我们以 root 身份登录并安装 Apache Web 服务器软件包：

    ```
    yum install httpd

    ```

1.  接下来，我们将检查 Apache 的服务状态：

    ```
    systemctl status httpd.service

    ```

1.  在后台启动 Web 服务器服务并再次打印出其状态：

    ```
    systemctl start httpd.service
    systemctl status httpd.service

    ```

1.  接下来，让我们打印出系统后台当前运行的所有服务列表；在这个列表中，你应该识别出你刚刚启动的`httpd`服务：

    ```
    systemctl -t service -a --state running

    ```

1.  现在，让我们备份 Apache 配置文件：

    ```
    cp /etc/httpd/conf/httpd.conf /etc/httpd/conf/httpd.conf.BAK

    ```

1.  现在，我们将使用 sed 对主 Apache 配置文件进行一些更改：

    ```
    sed -i 's/Options Indexes FollowSymLinks/Options -Indexes +FollowSymLinks/g' /etc/httpd/conf/httpd.conf

    ```

1.  现在，输入以下命令来停止和启动服务并应用我们的更改：

    ```
    systemctl stop httpd.service
    systemctl start httpd.service
    systemctl status httpd.service

    ```

1.  接下来，让我们启用`httpd`服务，使其在启动时自动启动：

    ```
    systemctl enable httpd.service

    ```

1.  最后一个命令将展示如何重启服务：

    ```
    systemctl restart httpd.service

    ```

## 它是如何工作的...

正如我们所见，`systemctl`实用程序可用于完全控制系统的服务。`systemctl`是`systemd`的控制程序，`systemd`是 CentOS 7 Linux 中的系统和服务的管理器。`systemctl`命令还可以用于其他各种任务，但在这里我们专注于管理服务。

那么，我们从这次经历中学到了什么？

我们从这个配方开始，以 root 身份登录并安装了 Apache Web 服务器包，因为我们想用它来展示如何使用`systemctl`程序管理服务。Apache 或`httpd.service`，正如`systemd`所称的，只是我们将使用的一个例子；在基本服务器环境中可能运行的其他重要服务可能是`sshd.service`、`mariadb.service`、`crond.service`等。之后，我们使用`systemctl status`命令参数检查了 httpd 的当前状态。输出显示了我们两个字段：**Loaded**和**Active**。**Loaded**字段告诉我们它是否当前已加载，以及它是否将在启动时自动启动；**Active**字段表示服务当前是否正在运行。接下来，我们展示了如何使用`systemctl`启动服务。服务的精确启动语法是`systemctl start <服务名称>.service`。

### 注意

通过启动一个服务，程序通过创建一个新进程并将其移动到后台，使其作为非交互式后台进程运行，从而与终端分离。这有时被称为**守护进程**。

接下来，在我们启动了 Apache Web 服务器守护进程之后，我们再次使用 systemctl 的`status`参数来展示如果我们运行它，状态是如何变化的。输出显示该服务当前已加载但在重启时被禁用。我们还看到它正在运行，以及该服务的最新日志输出和其他关于该进程的详细信息。要获取系统上所有服务的所有状态信息的概览，请使用`systemctl --type service --all`。`systemctl`服务不必一直运行。它的状态也可以是停止、降级、维护等。接下来，我们使用以下命令获取系统上所有当前正在运行的服务的列表：

```
systemctl -t service -a --state running

```

如您所见，我们在这里使用了`-t`标志来过滤仅显示类型服务单元。正如您可能猜到的，`systemctl`不仅可以处理服务单元，还可以处理许多其他单元类型。`systemd`单元是`systemd`可以使用配置文件管理的资源，它们封装了关于服务、监听套接字、保存的系统状态快照、挂载设备以及其他与系统相关的对象的信息。要获取所有可能的单元类型的列表，请键入`systemctl -t help`。这些配置单元文件位于系统中的特殊文件夹中，它们所属的类型可以从扩展名中读取；所有服务单元文件都具有文件扩展名`.service`（例如，设备单元文件具有扩展名`.device`）。系统将它们存储在两个地方。所有在安装期间由基本系统安装的`systemd`单元文件都位于`/usr/lib/systemd/system`，所有其他来自安装包（如 Apache）的服务或您自己的配置应该放到`/etc/systemd/system`。我们可以在`/usr/lib/systemd/system/httpd.service`找到我们的 Apache 服务配置文件。接下来，我们向用户展示了如何停止服务，这是启动它的反向操作，使用语法`systemctl stop <服务名称>`。最后，作为最后一步，我们使用了 systemctl 的`restart`参数，它只需一步即可处理服务的停止和启动，减少了输入。如果服务挂起且无响应，并且您需要快速重置它以使其工作，这通常很有用。在展示如何停止和重启服务之前，我们做了另一件重要的事情。当 Apache 服务正在运行时，我们使用`sed`命令更改了其主要服务配置文件，添加了一个`-Indexes`选项，该选项禁用了目录网站文件列表，这是提高 Web 服务器安全性的常见措施。由于 Apache Web 服务器已经在运行并在服务启动期间将配置加载到内存中，因此对该文件的任何更改都不会被正在运行的服务识别。

### 注意

通常情况下，为了应用任何配置文件的更改，运行的服务需要进行完整的服务重启，因为配置文件通常只在启动初始化期间加载。

现在，想象一下你的 Web 服务器可以从互联网访问，并且此刻有很多人在同时访问你的网页或应用程序。如果你正常重启 Apache，Web 服务器将有一段时间无法访问（直到服务器重启完成），因为进程实际上会结束，然后重新开始。所有当前用户如果在那时请求内容，都会收到 HTML 404 错误页面。此外，所有当前会话信息也会丢失；想象一下，你有一个在线网店，人们使用购物车或登录。所有这些信息也会消失。为了避免重要服务（如 Apache Web 服务器）的中断，这些服务中的一些具有`reload`选项（但并非每个服务都有此功能！），我们可以应用此选项而不是`restart`参数。此选项只是重新加载并应用服务的配置文件，而服务本身保持在线，执行过程中不会被打断。对于 Apache，你可以使用以下命令行：`systemctl reload httpd.service`。要获取所有具有重新加载功能的服务列表，请使用以下命令：

```
grep -l "ExecReload" /usr/lib/systemd/system/*.service /etc/systemd/system/*.service

```

因此，完成这个配方后，我们可以说我们现在知道如何使用基本的`systemctl`参数来管理服务。它是一个非常强大的程序，可以用于比仅仅启动和停止服务更多的事情。此外，在这个配方中，我们使用了不同的名称，它们都意味着相同：系统服务、后台进程或守护进程。

## 还有更多...

还有一种重要的单元类型叫做`目标`。目标也是单元文件，你的系统中已经有相当数量的目标可用。要显示它们，请使用以下命令：

```
ls -a /usr/lib/systemd/system/*.target /etc/systemd/system/*.target

```

简而言之，目标是一系列单元文件的集合，如服务或其他目标。它们可以用来创建类似于早期 CentOS 版本中的运行级别环境。运行级别定义了在系统处于何种状态时应加载哪些服务。例如，有图形状态，或救援模式状态等。要查看常见的运行级别如何对应于我们的目标，可以运行以下命令，该命令显示了它们之间的所有符号链接：

```
ls -al /lib/systemd/system | grep runlevel

```

目标可以依赖于其他目标；为了获得目标依赖关系的良好概览，我们可以运行以下命令，显示从多用户目标到所有其他目标的所有依赖关系（绿色表示活跃，红色表示不活跃）：

```
systemctl list-dependencies multi-user.target

```

你可以使用以下命令显示我们当前所在的目标：

```
systemctl get-default

```

你也可以切换到另一个目标：

```
systemctl set-default multi-user.target

```

# 故障排除后台服务

通常，系统管理员工作的大部分时间都在解决服务器出现问题时的故障。这对于系统服务尤其如此，因为它们一直在运行并处理信息。服务可能依赖于其他服务和服务器的系统，系统管理员的生活中将会遇到系统服务失败或拒绝启动的情况。在这里，在这个步骤中，我们将向你展示如果出现问题如何解决它们。

## 准备就绪

要完成这个步骤，你需要一个具有 root 权限的 CentOS 7 操作系统的工作安装，以及你选择的基于控制台的文本编辑器；你还应该完成了本章中的*了解和管理你的后台服务*步骤，在那里我们安装了 Apache 网络服务器。

## 如何做到这一点...

为了向你展示如何解决服务问题，我们将在 Apache 服务的配置文件中引入一个随机错误，然后向你展示如何解决和修复它：

1.  以 root 身份登录，并输入以下命令将内容追加到`httpd.conf`：

    ```
    echo "THIS_IS_AN_ERRORLINE" >> /etc/httpd/conf/httpd.conf

    ```

1.  接下来，重新加载`httpd`服务并显示其输出：

    ```
    systemctl reload httpd.service
    systemctl status httpd.service -l

    ```

1.  让我们撤销这个错误行：

    ```
    sed -i 's/THIS_IS_AN_ERRORLINE//g' /etc/httpd/conf/httpd.conf

    ```

1.  现在，再次重启服务：

    ```
    systemctl reload httpd.service
    systemctl status httpd.service

    ```

## 它是如何工作的...

在这个相当短的步骤中，我们向你展示了如果服务包含错误，示例服务将如何表现，以及你可以做些什么来修复它以开始。当服务出现故障时，有很多不同的场景可能会出现问题，解决这些问题可能是系统管理员工作的重要部分。

那么，我们从这次经历中学到了什么？

我们从这个步骤开始，在 Apache 主配置文件中引入了一行文本，该文本不包含任何有效的配置语法，因此`httpd`服务无法解释它。然后，我们使用`systemctl reload`参数重新加载我们服务器的配置文件。如前所述，并非所有服务都有重新加载选项，因此如果你的服务不支持这一点，请使用`restart`参数代替。由于 Apache 将尝试加载我们当前更改的配置文件，它将拒绝接受新的配置，因为我们在其中引入了错误的语法。由于我们只是重新加载配置，正在运行的 Apache 进程不会受到这个问题的影响，并将继续在线使用其原始配置。`systemctl`参数将打印出以下错误消息，给我们下一步该做什么的提示：

```
Job for httpd.service failed. Take a look at systemctl status httpd.service and journalctl -xe for details.

```

正如错误输出所建议的，`systemctl`状态参数是一个非常强大的工具，可以看到服务背后的情况，并试图找出任何失败的原因（在这里你也可以看到 Apache 仍在运行）。如果你使用`-l`标志启动`systemctl`状态，它会打印出更长的输出版本，这可以帮助你更多。

这个命令的输出向我们展示了配置重新加载失败的精确原因，因此我们可以轻松地追踪问题的根源（输出已被截断）：

```
AH00526: Syntax error on line 354 of /etc/httpd/conf/httpd.conf:
Invalid command ERRORLINE, perhaps misspelled or defined by a module, is not included in the server configuration.

```

这个输出是完整的`journald`日志信息的一部分。如果你想了解更多关于它的信息，请参考本章中的*使用 journald 跟踪系统资源*食谱。因此，通过这个输出中非常有用的信息，我们可以轻松地发现问题，并使用`sed`命令重新引入`ERRORLINE`，然后重新加载服务；这次一切都会正常工作。

因此，总的来说，我们可以说`systemctl status`命令是一个非常方便的命令，在找出服务问题时非常有帮助。大多数服务对语法错误非常敏感，有时可能只是一个错位的空格字符导致服务拒绝工作。因此，系统管理员必须始终精确工作。

# 使用 journald 跟踪系统资源

日志文件包含系统消息和来自服务、内核以及各种运行应用程序的输出。在许多情况下，它们非常有用，例如，用于解决系统问题、监控服务或其他系统资源，或者在安全事件发生后进行安全取证。在本食谱中，你将学习如何使用 journald 进行日志记录服务的基本操作。

## 准备工作

要完成这个食谱，你需要一个安装了 CentOS 7 操作系统的工作环境，具备 root 权限和一个你选择的基于控制台的文本编辑器。此外，正确设置时间和日期对于整个日志记录概念至关重要，因此请在使用本食谱之前，应用来自第二章，*配置系统*的*使用 NTP 和 chrony 套件同步系统时钟*食谱。此外，对 systemd 和单元有基本了解可能会有优势。这在本书的*了解和管理后台服务*食谱中有所涉及。Journalctl 使用*less*导航来显示输出；如果你不知道如何使用它，请阅读来自第二章，*配置系统*的*使用 less 导航文本文件*食谱。

## 如何操作...

在 CentOS 7 中，我们有两个日志记录机制可供选择，分别是`rsyslog`和`journald`日志系统，后者是新的`systemd`系统管理器的一个组件，用于查看和管理日志信息。在这里，我们将向你展示如何使用`journalctl`命令，它是`journald`守护进程的控制客户端：

1.  首先，以 root 身份登录，并输入以下命令来查看整个日志：

    ```
    journalctl

    ```

1.  接下来，我们只想显示在特定时间范围内的消息（相应地更改日期）：

    ```
    journalctl --since "2015-07-20 6:00:00" --until "2015-07-20 7:30:00"

    ```

1.  之后，我们想通过所有来自 sshd 服务的消息来过滤日志系统：

    ```
    journalctl -u sshd.service --since "yesterday"

    ```

1.  现在，我们只想显示类型为错误的消息：

    ```
    journalctl -p err -b

    ```

1.  要获取`journalctl`最详细的版本，请使用`verbose`选项：

    ```
    journalctl -p err -b -o verbose

    ```

1.  要获取日志输出的*当前*视图，请使用以下命令（这不是*less*导航——使用组合键*Ctrl*+*C*退出此视图）：

    ```
    journalctl -f

    ```

## 它是如何工作的...

在 CentOS 7 中，我们可以使用新的`journald`日志记录系统，它是`systemd`系统管理的一部分。它是一个集中式工具，将记录系统上的几乎所有内容，包括从早期启动到内核、服务以及所有程序消息的所有输出。与其他日志记录机制相比，主要优势在于您不必为每个服务或其他资源配置日志记录，因为一切都已经为通过集中式`systemd`系统控制和运行的所有应用程序设置好了。

那么，我们从这次经历中学到了什么？

我们通过运行`journalctl`命令开始了我们的旅程，该命令在不带任何参数的情况下向我们展示了完整的日志记录，包括从系统启动到最新的系统消息，按照它们出现的顺序，将新消息附加到底部（按时间顺序）。如果您的系统已经运行了一段时间，它可能包含数十万行日志数据，以这种原始形式处理非常不切实际。

此输出由`journald`守护进程持续捕获，但不写入文本文件，如`rsyslog`等其他日志系统所做的那样。相反，它使用结构化和索引的二进制文件，存储大量额外的元信息，如用户 ID、时间戳等，这使得将其转换为各种不同的输出格式变得容易。如果您想通过另一个工具进一步处理日志信息，这可能会非常方便。由于无法读取二进制文件，您将需要客户端`journalctl`来查询`journald`数据库。由于手动解析如此大量的数据几乎是不可能的，因此我们利用了 journalctl 丰富的过滤选项。首先，我们使用`--since`和`--until`参数提取特定时间范围内的所有日志消息。指定时间和日期的语法非常灵活，理解诸如`昨天`或`现在`之类的短语，但我们坚持使用简单的日期语法，`YYYY-MM-DD HH:MM:SS`。接下来，我们使用 journalctl 的`-u`参数过滤特定单元类型的日志消息。我们使用它来过滤来自 sshd 守护程序服务的消息。我们添加了另一个使用`--since`参数的过滤器，这进一步收紧了`-u`单元过滤器的结果，仅输出昨天发生的 sshd 服务结果。我们应用的下一个过滤器是使用参数字符串`-p err -b`，它按优先级或日志级别过滤日志数据库。每个日志消息都可以有一个关联的优先级，该优先级确定消息的重要性。要了解有关不同日志级别的更多信息，请参阅手册，使用命令行`man 3 syslog`（如果此手册不可用，请键入`yum install man-pages`进行安装）。我们的命令将打印出所有标记为`错误`或以上的日志消息，包括：`错误`、`严重`、`警报`或`紧急`。

接下来，我们使用了相同的命令参数，但添加了`-o verbose`，这提供了最详细的日志信息输出。最后，我们介绍了`-f`参数（用于跟随），它将为我们提供最新的日志消息的*实时*视图，并保持此连接打开，当新消息出现时，将其附加到输出的末尾。这在测试设置或启动/停止服务时查看系统反应通常很有用。

总之，可以说在 CentOS 7 上，两个日志系统并存：较旧的`rsyslog`和较新的`journald`，后者是您首选的系统故障排除工具。但请记住，在 CentOS 7 上，`journald`并不是`rsyslog`的完全替代品。`journald`中缺少一些`rsyslog`的功能，而且还有许多工具和脚本，如日志摘要工具或监控套件如 Nagios，它们仅与`rsyslog`配合使用。

系统管理员在解决系统错误或意外服务器行为时经常面临巨大挑战。通常，在应用正则表达式搜索或 Linux 命令行功夫时，通过搜索大量不同的日志文件文本来找到单一故障点并不容易。Journald 提供了一个非常方便的替代方案，通过提供一个强大且定义良好的集中查询系统，快速高效地完成日志文件分析！

# 配置 journald 以使其持久

Journald 相对于其他日志系统如`rsyslog`的优势在于，它非常高效，并且会自动记录系统上的几乎所有内容，无需进行任何配置，因为它属于`systemd`套件的一部分。主要缺点是，`journald`的所有日志信息在系统重启后都会丢失。Journald 日志可以产生大量数据，并且默认情况下所有日志信息仅保存在内存中，如果你需要访问较旧的日志信息或分析系统崩溃重启的原因，这并不实用。在本教程中，我们将向你展示如何配置`journald`以使其持久。

## 准备就绪

要完成这个教程，你需要一个具有 root 权限的 CentOS 7 操作系统的最小安装，以及你选择的基于控制台的文本编辑器。

## 如何操作...

开始这个教程，我们需要创建一个位置来保存我们的持久日志数据库：

1.  以 root 用户身份登录并创建以下目录：

    ```
    mkdir /var/log/journal

    ```

1.  接下来，将新目录添加到`journald`中，用作存储位置并修复权限：

    ```
    systemd-tmpfiles --create --prefix /var/log/journal

    ```

1.  现在，重启`journald`：

    ```
    systemctl restart systemd-journald

    ```

1.  最后，为了检查日志是否在重启后存活，重启计算机并输入以下命令：

    ```
    journalctl --boot=-1

    ```

## 工作原理...

我们通过创建新目录`/var/log/journal`开始了这个教程。默认情况下，`journald`将其日志数据库写入`/run/log/journal`，这是一个仅用于运行时信息的目录，其内容在系统重启后不会保留。之后，我们使用`systemd-tmpfiles`命令为`journald`设置新目录。最后，我们重启了`journald`服务器守护进程，以将我们的更改应用到系统。为了测试持久性是否正常工作，重启你的服务器，然后使用`journalctl –boot=-1`。这将向我们展示上次启动以来的所有日志信息。如果持久性没有正常工作，它会打印出以下错误；否则，它会正确显示上次启动之前的所有日志消息：

```
Failed to look up boot -1: Cannot assign requested address

```

在这个相当简单的教程中，我们展示了如何使`journald`在系统重启后保持持久性。如果你需要查看过去的旧日志文件，这会非常有用，有时这能帮助你找出问题，例如过去硬件故障的根源。

# 管理用户及其组

在这个操作中，我们将学习如何在 CentOS 7 上管理系统的用户和组。基本的用户和组管理技能是 CentOS 系统管理员最重要的基础之一。

## 准备就绪

要完成这个操作，您需要一个具有 root 权限的 CentOS 7 操作系统的有效安装，以及您选择的基于控制台的文本编辑器。

## 如何操作...

这个操作向您展示了如何通过学习如何添加、删除和修改用户和组来管理它们：

1.  要开始这个操作，我们以 root 身份登录，并输入以下命令以获取系统中所有已知用户的列表：`cat /etc/passwd`。

1.  现在，显示 root 用户的 ID（**UID**）和组 ID（**GID**）：

    ```
    id root

    ```

1.  接下来，我们将运行以下命令以在系统中添加一个新用户（将`your_new_username`替换为您选择的用户名）：

    ```
    useradd your_new_username

    ```

1.  然而，为了完成这个过程，您将被要求提供一个合适的密码。为此，输入以下命令（将`your_new_username`替换为您选择的用户名），然后在提示时输入一个安全的密码：

    ```
    passwd your_new_username

    ```

    ### 注意

    密码不应少于六个字符，但也不应超过十六个字符。它们应由字母数字值组成，并且出于显而易见的原因，您必须避免使用空格。不要使用字典中的单词，并避免使用已知或明显的短语。

1.  接下来，创建一个新组并给它一个特殊的名称：

    ```
    groupadd your_new_group

    ```

1.  然后，我们将新用户添加到这个新组中：

    ```
    usermod -G your_new_group your_new_username

    ```

1.  最后，让我们打印出新用户的用户 ID 和组 ID，看看发生了哪些变化：

    ```
    id your_new_username

    ```

## 它是如何工作的...

这个操作的目的是创建一个新用户和组，并展示如何将它们连接在一起。

那么，我们从这次经历中学到了什么？

首先，我们打印出`/etc/passwd`文件的内容，以显示系统中所有当前用户。这个列表不仅包含属于真实人物的普通用户账户，还包含用于控制和拥有特定应用程序或服务的账户。然后，我们使用`id`命令来显示我们现有用户 root 的唯一用户 UID 和 GID。在 Linux 中，每个用户都可以通过他们的 UID 和 GID 来识别，并且文件系统中的每个文件都有特定的权限设置，这些设置管理文件所有者、组所有者和其他用户的访问权限。对于这三个组中的每一个，您都可以使用`chmod`命令启用或禁用读、写和执行权限（使用`man chmod`了解更多信息，并查看`man chown`）。所有者和组权限对应于一个 UID 和 GID，我们可以使用`ls -l`为每个文件显示这些信息。

接下来，我们执行了`useradd`命令，要求我们为新用户提供一个合适的名称，这将使服务器能够使用一组默认值和标准建立新身份，包括用户 ID、家目录、主组（GID），并将默认 shell 设置为 bash。完成此过程只需确认一个合适的密码。要删除用户，有相反的命令`userdel`，其工作方式类似，但可以给出`-f`选项以删除家目录而不是将其留在系统上。接下来，我们使用了`groupadd`命令，顾名思义，它将创建一个新组并为它分配一个新的唯一 GID。之后，我们使用`usermod -G`命令将我们的用户添加到之前创建的新组中。如前所述，每个用户都有一个唯一的 UID 和 GID。第一个组是主组，是必需的；但是，用户可以属于多个不同的组，这些组称为辅助组。创建新文件时需要主组，因为它将设置创建它的用户的 GID 和 UID。要删除组，我们可以使用`groupdel`命令。最后，我们再次使用`id`命令查看新用户的 UID、主 GID 以及我们添加给它的新的辅助 GID 组。

现在，您只需使用几个命令即可完全控制用户和组：`useradd`、`usermod`、`userdel`、`groupadd`、`groupmod`和`groupdel`。

# 使用 cron 安排任务

在本食谱中，我们将探讨服务器自动化的作用以及通过引入您到基于时间的作业调度程序 cron 来在预定义周期内运行特定任务的便利性。Cron 允许通过使管理员能够根据任何小时、任何天或任何月确定预定义的计划来自动化任务。它是 CentOS 操作系统的标准组件，本食谱的目的是向您介绍管理重复任务的概念，以便利用这一宝贵工具并使 CentOS 为您工作。

## 准备就绪

要完成本食谱，您需要具有 root 权限的 CentOS 7 操作系统的最小安装，以及您选择的基于控制台的文本编辑器。`crontab`程序使用 Vim 进行文件编辑。如果您不知道如何使用 Vim，请查看食谱*Vim 简介*中的教程，位于第二章，*配置系统*。

## 如何操作...

本食谱的目的是创建一个脚本，该脚本将每五分钟将时间和日期以及您选择的几句话写入文本文件。这可能看起来是一个相对简单的练习，但意图是向您展示，从这种简单性出发，cron 可以用于做更多的事情，这将使与 CentOS 一起工作成为一种绝对的乐趣。

1.  要开始这个配方，请以 root 身份登录并创建您的第一个 cron 作业，方法是输入：

    ```
    crontab -e

    ```

1.  我们现在将创建一个简单的 cron 作业，该作业将日期和时间与单词 `hello world` 一起写入位于 `/root/cron-helloworld.txt` 的文件中，每五分钟一次。为此，添加以下行：

    ```
    */5 * * * * echo `date` "Hello world" >>$HOME/cron-helloworld.txt

    ```

1.  完成后，只需保存文件并退出编辑器。系统现在将响应以下消息：

    ```
    crontab: installing
     new crontab

    ```

1.  前面的消息通知您，服务器现在正在创建新的 `cron` 作业，并将自动激活它。您可以通过查看位于 `/root/cron-helloworld.txt` 的文件来查看脚本的输出（您必须等待 5 分钟），或者通过监视位于 `/var/log/cron` 的日志文件（使用 `tail -f /var/log/cron` 和 `Ctrl+C` 退出）。

## 它是如何工作的...

Cron 是一个程序的名称，它允许 CentOS 用户在指定的时间和日期自动执行命令或脚本。Cron 的设置保存在一个名为 `crontab` 的用户特定文件中，正如我们在本配方中看到的那样，可以编辑此文件以创建所需的自动化任务。

那么我们从这次经历中学到了什么？

使用的示例非常简单，但在许多方面，这是这个配方的目的。Crontab 使用一个守护进程 `crond`，它一直在后台运行，并每分钟检查一次是否有任何计划的任务需要执行。如果找到任务，则 cron 将执行它。要编辑现有的 `crontab` 文件或创建新的 `crontab`，我们使用 `crontab -e` 命令。要查看当前的 cron 作业列表，可以键入 `crontab -l`。或者，要查看另一个用户的当前作业列表，可以键入 `crontab -u username -l`。任务或作业通常称为 cron 作业，并且通过在我们的第一个脚本中避免复杂性，目的是向您展示命令构造的本质非常简单。cron 作业的形成如下所示：

```
<minute> <hour> <day of the month> <month of the year> <day of the week> <command>

```

条目由单个或制表符分隔，允许的值主要是数字（即，`0-59` 表示分钟，`0-23` 表示小时，`1-31` 表示月份中的日期，`1-12` 表示年份中的月份，`0-7` 表示星期几）。然而，这样说也是正确的，即存在更具体的运算符（`/`，`-`）和特定的 cron 快捷方式（即，`@yearly`，`@daily`，`@hourly`，`@weekly`），这些允许额外的控制。例如，`/` 运算符用于逐步指定单位，可以读作 *每*，所以在我们的配方中使用 `*/5` 将使任务每五分钟运行一次，而使用 `*/1` 将使任务每分钟运行一次。此外，您应该知道，使用此语法将使所有命令与小时对齐。因此，考虑到这一点，对于任何想要编写他们的第一个 `cron` 作业的人来说，最合适的模板或起点是开始使用一系列五个星号，然后是命令，如下所示：

```
* * * * * /absolute/path/to/script.sh

```

然后，继续配置所需的分钟、小时、日期、月份和星期值。例如，如果您希望在每个工作日（周一至周五）的晚上 8 点（20:00 小时）运行特定的 PHP 脚本，它可能看起来像这样：

```
0 20 * * 1-5 /full/path/to/your/php/script.php

```

因此，考虑到这一点，通过完成本食谱，您可以看到 cron 如何用于管理数据库备份，运行预定系统备份，通过在预定义间隔激活脚本来支持网站，或运行各种 bash 脚本等等。

## 还有更多...

要删除或禁用 cron 作业，只需从单个用户的 cron 文件中删除指令，或者在行首放置一个哈希（`#`）。单个 cron 文件可以在`/var/spool/cron/<username>`找到，使用哈希将禁用 cron 作业或允许您编写注释。要完全删除`crontab`文件，您还可以使用`crontab -r`。例如，如果您想删除主食谱中创建的 cron 作业，您可以以 root 身份登录并开始输入命令`crontab -e`。此时，您可以删除整行或将其注释掉，如下所示：

```
# */15 * * * * echo `date` "Hello world" >>$HOME/cron-helloworld.txt

```

接下来，保存文件。在文件系统中还有一些特殊的 cron 目录，用于系统范围的 cron 作业。如果您将脚本文件放入其中，它将在特定时间点自动运行。这些目录在`/etc`目录中被称为`cron.daily`、`cron.hourly`、`cron.weekly`和`cron.monthly`，它们的名称指的是它们运行的时间点。如果您不再想执行脚本，只需将其从文件夹中删除即可。查看*监控重要服务器基础设施*的示例。

# 使用 rsync 同步文件并执行更多操作

`rsync`是一个程序，可用于在各种本地和远程位置之间同步文件和目录。它可以与多种操作系统交互，通过 SSH 工作，提供增量备份，在远程机器上执行命令，并取代`cp`和`scp`命令的需求。`rsync`程序对于打算运行服务器或管理计算机网络的任何系统管理员来说都是无价之宝，因为它不仅简化了备份过程，还可以用于执行完整的备份解决方案。因此，本食谱的目的是提供一个合适的起点，以快速成为您信赖的朋友的小工具。

## 准备就绪

要完成本食谱，您需要具有 root 权限的 CentOS 7 操作系统的安装，您选择的基于控制台的文本编辑器以及连接到 Internet 以促进下载其他软件包的连接。

## 如何操作...

在本食谱的过程中，将假定您知道要同步的源文件和目录的位置，并且有一个合适的目的地：

1.  要开始本教程，请以 root 身份登录并键入以下内容安装`rsync`：

    ```
    yum install rsync

    ```

1.  现在，为我们的同步创建一个目标目录（根据需要更改文件夹名称）：

    ```
    mkdir ~/sync-target

    ```

1.  要开始同步过程，只需重复以下命令，通过修改用于`/path/to/source/files/`的值来满足您的需求：

    ```
    rsync -avz --delete /path/to/source/files/  ~/sync-target

    ```

1.  在确认前面的指令后，您的系统现在将响应一个实时报告，说明正在复制的内容。当这个过程完成后，您可以比较两个目录，看看内容是否完全相同。为此，请使用`diff`命令（如果两者相同，则不会写入输出）：

    ```
    diff -r /path/to/source/files/ ~/sync-target

    ```

## 它是如何工作的...

在本教程中，我们考虑了通过命令行使用`rsync`。当然，这只是使用这个工具的众多方式之一，但通过这种方法，我们能够探索这个非常有价值的实用程序提供的一些功能。

那么，我们从这次经历中学到了什么？

Rsync 并不是为了复杂而设计的。它是一个快速且高效的文件同步工具，旨在通过在命令行上为您提供完整的访问权限来实现多功能性。它可以用来在同一台机器上或在完全不同的系统上维护`源`目录的精确副本（或镜像），它通过一次复制所有文件，然后在下次运行时仅更新已更改的文件来实现这一点。这可以节省大量的带宽，并且应该是您在网络上复制数据时的主要工具。使用短语`--delete`很重要，因为它指示`rsync`删除目标上不存在于源中的文件，而所选标志意味着`rsync`应该使用`-a`存档模式来递归复制文件和目录，同时保持所有权限和基于时间的信息；`–v`）详细模式，以便您可以看到正在发生的事情；以及`–z`在文件传输期间压缩数据，以节省带宽并减少完成整个过程所需的时间。

如您所见，`rsync`非常灵活，并且有许多超出本教程目的的选项，但如果您想排除某些文件，您始终可以通过调用`--exclude`标志来扩展原始指令。通过这样做，您告诉`rsync`备份整个目录，但确保不包括预定义的文件和文件夹模式。例如，如果您正在将文件从服务器复制到 USB 设备，并且您不想包括大型文件（如`.iso`映像）或 ZIP 文件，那么您的命令可能与此类似：

```
rsync --delete -avz --exclude="*.zip" --exclude="*.iso"  /path/to/source/ /path/to/external/disk/

```

最后，关于详细程度的话题。详细程度非常有用，但倾向于使用字节作为其主要测量单位可能会引起混淆。因此，为了改变这一点，您可以调用带有`–h`（或人类可读）选项的`rsync`，如下所示：

```
rsync -avzh --exclude="home/path/to/file.txt" /home/ /path/to/external/disk/

```

# 维护备份和快照

在本配方中，我们将向您展示如何定期进行数据备份，这些备份将使用`crond`守护进程对系统的一些目录进行快照。这将定期运行`rsync`程序，以实现完全自动化的备份解决方案。

## 准备就绪

要完成此配方，您需要一个具有 root 权限的 CentOS 7 操作系统的有效安装，以及您选择的基于控制台的文本编辑器。如果您阅读了本章中的*使用 rsync 同步文件并执行更多操作*和*使用 cron 安排任务*配方，以获得对所用命令的更深入理解，那将是有益的。

## 如何操作...

在继续此配方之前，在您的服务器上安装`rsync`程序非常重要。

1.  首先，以 root 身份登录并创建一个目录，我们的备份将存放在那里：

    ```
    mkdir /backups

    ```

1.  现在，我们将创建以下 shell 脚本文件并打开它进行编辑：

    ```
    mkdir ~/bin;vi ~/bin/mybackup.sh

    ```

1.  输入以下内容，将环境变量`DEST`和`SOURCE`中的`/backups`替换为您希望备份的目录，以及收件人的`EMAIL`：

    ```
    #!/bin/bash
    SBJT="cron backup report for `hostname -s` from $(date +%Y%m%d:%T)"
    FROM=root@domain
    EMAIL=johndoe@internet.com
    SOURCE=/root
    DEST=/backups
    LFPATH=/tmp
    LF=$LFPATH/$(date +%Y%m%d_%T)_logfile.log
    rsync --delete --log-file=$LF -avzq $SOURCE $DEST
    (echo "$SBJT"; echo; cat $LF ) | sendmail -f $FROM -t $EMAIL

    ```

1.  使脚本可执行：

    ```
    chmod a+x /root/bin/mybackup.sh

    ```

1.  现在，使用以下命令打开`crontab`：

    ```
    crontab -e

    ```

1.  接下来，通过在文档末尾添加以下行来创建以下条目，然后保存并关闭它：

    ```
    30 20 * * * /root/bin/mybackup.sh

    ```

## 它是如何工作的...

在本配方中，我们为单个系统目录创建了一个完全自动化的备份解决方案，该解决方案将在某个时间点创建文件的快照。备份过程完成后，您将收到一封电子邮件，通知您已进行备份，并附有对所采取行动的简要回顾。

那么我们从这次经历中学到了什么？

我们通过创建一个目录来开始此配方，我们的备份将放置在那里。接下来，我们创建了实际的脚本并填充了一些命令。第 1 行将文件定义为 bash 脚本，第 2-6 行是您可以修改和自定义以满足您自己需求的变量。第 7-8 行根据日期创建日志文件的路径和名称，第 9 行调用`rsync`，它将同步所有源文件到目标目录/backups。它使用特殊的`--log-file`参数，该参数将所有输出写入给定文件。最后一行（10）将此日志文件的内容发送到电子邮件地址。

请记住，您应该根据需要自定义值（即更改使用的电子邮件地址，选择源目录，选择目标目录等）。在它能够被`cron`使用和执行之前，我们使其可执行。最后，我们将此脚本添加为 cron 作业，以便在每天的 20:30 小时运行。但是，由于这可能需要几个小时，如果您想立即测试脚本，可以使用以下命令在命令行上执行它：

```
/root/bin/mybackup.sh

```

总之，不言而喻，备份应该位于外部驱动器或单独的分区上，但是完成这个介绍后，我认为你会同意`rsync`处于理想的位置，它将使任何服务器管理员能够制定自己的政策，以维护重要数据的有效备份。

# 监控重要的服务器基础设施

在本配方中，我们将使用一个小脚本来定期监控可用文件系统的磁盘空间，如果超过某个百分比阈值，脚本将发送带有警告消息的邮件。

## 准备就绪

要完成这个配方，你需要一个具有 root 权限和所选控制台文本编辑器的 CentOS 7 操作系统的有效安装。你应该已经阅读了*使用 cron 安排任务*配方，以便对 cron 系统的原理有一个基本的了解。

## 如何做到这一点...

1.  要开始这个配方，请以 root 身份登录并创建以下文件，该文件将包含我们的监控脚本：

    ```
    vi /etc/cron.daily/monitor_disk_space.sh

    ```

1.  现在，请输入以下内容：

    ```
    #!/bin/bash
    EMAIL="root@localhost"
    THRESHOLD=70
    df -H | grep -vE '^Filesystem|tmpfs|cdrom' | awk '{ print $5 " " $6 }' | while read output;
    do
     usep=$(echo $output | awk '{ print $1}' | cut -d'%' -f1  )
     partition=$(echo $output | awk '{ print $2 }' )
     if [ $usep -ge $THRESHOLD ]; then
     (echo "Subject: Alert: Free space low on `hostname -s`, $usep % used on $partition"; echo)| 
     sendmail -t $EMAIL
     fi
    done

    ```

1.  现在，保存文件并使其可执行：

    ```
    chmod +x /etc/cron.daily/monitor_disk_space.sh

    ```

## 它是如何工作的...

我们使这个脚本可执行，并将其放入`/etc/cron.daily`目录中，这就是我们需要做的所有事情，以便通过`crond`服务每天自动运行这个脚本。

这个简单的脚本向我们展示了构建监控脚本是多么容易，这可以成为安装和配置大型监控套件（如 Nagios）的真正替代方案。您可以使用所示的脚本作为起点，添加更多需要监控的重要资源，例如 CPU 负载、可用 RAM 等。

我们使用了一个执行 Linux 命令`df`的脚本，这是一个报告文件系统磁盘空间使用情况的工具。从这个命令的输出中，脚本然后解析了`USE%`列（使用 Unix 工具`awk`和`cut`），这给了我们总磁盘使用百分比。然后，这个数字将与用户可以通过编辑脚本并更改环境变量`THRESHOLD`设置的阈值进行比较。如果提取的百分比数字高于我们的阈值，将向定义了环境变量`EMAIL`的电子邮件地址发送电子邮件（如果需要，请相应更改）。

# 使用 GIT 和 Subversion 进行控制

文档修订控制系统或版本控制系统，有时也称为版本控制系统，用于管理文档的更改。随着现代工作越来越多地将来自世界各地的人们联系起来，共同合作并共同处理各种文档（例如，软件源代码），这些系统变得越来越重要，因此管理不同人使用修订版进行的文件更改变得非常重要。在本配方中，我们将向您展示如何使用现代版本控制系统，如 GIT 和 Subversion，来管理配置文件的版本控制。

## 准备就绪

要完成本教程，你需要一个具有 root 权限的 CentOS 7 操作系统的工作安装，以及一个互联网连接，以便于下载额外的软件包。

## 如何操作...

在本教程中，我们将把完整的 Linux 主配置目录`/etc/`置于 Git 仓库的版本控制之下，以跟踪我们对配置文件所做的所有更改：

1.  首先，以 root 身份登录，安装 Git，并通过提供电子邮件地址和用户名来配置它（请将`your_username`和`your_email_address`替换为真实姓名）：

    ```
    yum install git
    git config --global user.email  "your_email_address"
    git config --global user.name "your_username"

    ```

1.  现在，让我们在`/etc`目录中创建一个新的仓库：

    ```
    cd /etc/
    git init

    ```

1.  现在，我们有了新的仓库，让我们将`/etc/`目录中的所有文件置于版本控制之下：

    ```
    git add *

    ```

1.  要提交文件到仓库，创建你的第一个版本，请输入以下内容：

    ```
    git commit -a -m "inital commit of the full /etc/ directory"

    ```

1.  现在，让我们更改一个文件：

    ```
    echo "FILE HAS CHANGED" >> yum.conf

    ```

1.  接下来，展示你的仓库中的更改：

    ```
    git status

    ```

1.  接下来，我们将提交这些更改并创建一个新的版本：

    ```
    git commit -a -m "changing yum.conf files"

    ```

1.  接下来，展示迄今为止的所有提交：

    ```
    git log --pretty=oneline --abbrev-commit

    ```

1.  这将输出我的系统上的以下提交（你的系统上的数字哈希值将不同）：

    ```
    8069c4a changing yum.conf
    5f0d50a inital commit of the full /etc directory

    ```

1.  基于前一步骤的输出，我们现在将展示两个版本号之间的所有差异（根据前一步骤的输出，在你的系统上更改数字哈希值）：

    ```
    git diff 8069c4a 5f0d50a

    ```

1.  要完成本教程，我们将撤销我们对原始文件版本的更改（初始提交）：

    ```
    git checkout 5f0d50a

    ```

## 它是如何工作的

在本教程中，我们向你展示了如何使用 Git 来管理`/etc`目录中的系统配置文件的更改。如果你正在进行测试，这可能很重要，因为你会对某些配置文件进行大量更改，并且希望跟踪这些更改。这样做的好处是，如果你以后需要撤销更改或回退到特定版本，或者比较不同文件版本，你不需要记住你采取的每一个步骤。

那么，我们从这次经历中学到了什么？

我们首先安装了 Git，并向其配置中添加了用户名和电子邮件地址，这对于后续使用至关重要。然后，我们切换到 `/etc` 目录，并在那里初始化（使用 `init` 参数）一个新的空 Git 项目，这被称为仓库，用于跟踪与之关联的所有文件。此命令将在其中添加一个隐藏的 `.git` 目录，其中包含完整的文件更改和修订信息。接下来，我们添加了该目录中的所有文件（使用通配符 `*` 运算符），包括所有子目录到下一个修订版。修订版就像文件在给定时间点的状态，由唯一的哈希 ID 标识，例如 `8069c4a`。然后，我们实际创建了一个新修订版，使用 commit 参数并提供有意义的 message 使用 `-m` 参数。在我们设置 Git 仓库并将所有文件添加到其中之后，对 `/etc` 目录中文件的每次更改都会被监视。接下来，我们在仓库中修改了主 YUM 配置文件，通过使用 echo `>>` 命令在末尾添加一个随机字符串。如果我们现在再次使用 git 的 `status` 参数，我们会在输出中看到 Git 系统已通知该文件已被更改。我们现在可以使用 git 的 `commit` 参数再次创建一个包含更改文件的新修订版，并在此处使用另一个有意义的 message 说明 `yum.conf` 已被更改。然后我们使用了 git `log` 命令。这将向我们展示所有已提交的修订版及其唯一的 `md5` 哈希字符串 ID。使用此 ID，我们可以为 git `diff` 命令提供燃料，以查看两个修订版之间的所有文件更改。要了解更多输出格式，请使用 `man git-diff-files` 并阅读其 `COMBINED DIFF FORMAT` 部分。在我们最后一步中，我们使用了 checkout 命令转到特定文件修订版；在这里，我们恢复了所有更改并返回到原始文件状态。

Git 是一个非常强大的版本管理工具，在本教程中我们只是浅尝辄止地了解了它的功能。要学习更多关于 Git 的精彩技巧，如分支、合并、拉取请求等，可以从输入 `man gittutorial` 开始，阅读 Git 教程页面。

## 不仅如此...

您还可以使用 Subversion 程序将 `/etc` 目录置于版本控制之下。Subversion 是另一种常见的文档修订控制系统，与 Git 的主要区别在于它使用中央服务器来跟踪文件更改。Git 是分布式的，这意味着在 Git 项目上工作的每个人都会在本地计算机上拥有完整的仓库。在这里，我们将向您展示使用 Subversion 代替 Git 所需的精确步骤：

1.  首先，安装 Subversion 并为我们的 `/etc` 仓库配置一个新的服务器目录：

    ```
    yum install subversion
    mkdir -p /var/local/svn/etc-repos
    svnadmin create --fs-type fsfs /var/local/svn/etc-repos

    ```

1.  现在，将 `/etc` 文件系统就地导入到我们的新仓库中：

    ```
    svn mkdir file:///var/local/svn/etc-repos/etc 
    -m "Make a directory in the repository to correspond to /etc"

    ```

1.  现在，切换到 `/etc` 目录并将所有文件添加到一个新修订版中：

    ```
    cd /etc
    svn checkout  file:///var/local/svn/etc-repos/etc ./
    svn add *

    ```

1.  现在，创建您的第一个提交：

    ```
    svn commit -m "inital commit of the full /etc/ directory"

    ```

1.  接下来，修改`yum.conf`文件：

    ```
    echo "FILE HAS CHANGED" >> yum.conf

    ```

1.  将你的更改提交到新的文件版本：

    ```
    svn commit -m "changing yum.conf files"

    ```

1.  现在，展示变更日志：

    ```
    svn log -r 1:HEAD

    ```

1.  显示我们两个提交之间的文件差异（第一个提交是`/etc`导入）：

    ```
    svn diff -r 2:3

    ```

1.  最后，恢复到我们`yum.conf`文件的第一个版本：

    ```
    svn update -r 2 yum.conf

    ```
