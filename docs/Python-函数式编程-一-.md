# Python 函数式编程（一）

> 原文：[`zh.annas-archive.org/md5/0A7865EB133E2D9D03688623C60BD998`](https://zh.annas-archive.org/md5/0A7865EB133E2D9D03688623C60BD998)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 前言

编程语言有时可以很好地适应整洁的范畴，比如命令式和函数式。命令式语言可能进一步分为过程式和包含面向对象编程特性的语言。然而，Python 语言包含了所有这三种语言范畴的特点。虽然 Python 不是纯粹的函数式编程语言，但我们可以在 Python 中进行大量的函数式编程。

最重要的是，我们可以利用许多来自其他函数式语言的设计模式和技术，并将它们应用于 Python 编程。这些借鉴的概念可以帮助我们创建简洁而优雅的程序。特别是 Python 的生成器表达式，避免了创建大型内存数据结构的需要，从而导致程序可能更快地执行，因为它们使用更少的资源。

我们无法在 Python 中轻松创建纯函数式程序。Python 缺少许多必要的功能。例如，我们没有无限递归，所有表达式的惰性求值和优化编译器。

一般来说，Python 强调严格的求值规则。这意味着语句按顺序执行，表达式从左到右求值。虽然这偏离了函数式纯度，但它允许我们在编写 Python 时执行手动优化。我们将采用混合方法来使用 Python 的函数式特性，当它们可以增加清晰度或简化代码时使用，以及使用普通的命令式特性进行优化。

函数式编程语言中有几个关键特性在 Python 中也可以使用。其中最重要的一个是函数作为一等对象的概念。在一些语言中，函数只存在于源代码结构中：它们在运行时并不作为合适的数据结构存在。在 Python 中，函数可以将函数作为参数使用，并将函数作为结果返回。

Python 提供了许多高阶函数。像`map()`、`filter()`和`functools.reduce()`这样的函数在这方面被广泛使用。像`sorted()`、`min()`和`max()`这样不太明显的函数也是高阶函数；它们有一个默认函数，因此与更常见的例子有不同的语法。

函数式程序经常利用不可变数据结构。对无状态对象的强调允许灵活的优化。Python 提供了元组和命名元组作为复杂但不可变的对象。我们可以利用这些结构来借鉴其他函数式编程语言的一些设计实践。

许多函数式语言强调递归，但利用尾调用优化（TCO）。Python 倾向于将递归限制在相对较小的堆栈帧中。在许多情况下，我们可以将递归视为生成器函数。然后我们可以简单地重写它以使用`yield from`语句，自己进行尾调用优化。

我们将从 Python 的角度来看函数式编程的核心特性。我们的目标是借鉴函数式编程语言的好思想，并将这些思想用于在 Python 中创建富有表现力和简洁的应用程序。

# 本书涵盖的内容

第一章 *介绍函数式编程*，介绍了一些特征函数式编程的技术。我们将确定一些将这些特性映射到 Python 的方法，最后，我们还将讨论一些使用这些设计模式构建 Python 应用程序时函数式编程的好处。

第二章，“引入一些函数式特性”，将深入探讨函数式编程范式的六个核心特性。我们将详细研究每个特性在 Python 中的实现。我们还将指出一些不适用于 Python 的函数式语言特性。特别是，许多函数式语言具有复杂的类型匹配规则，需要支持编译和优化。

第三章，“函数，迭代器和生成器”，将展示如何利用不可变的 Python 对象和生成器表达式，并将函数式编程概念应用到 Python 语言中。我们将研究一些内置的 Python 集合以及如何在不远离函数式编程概念的情况下利用它们。

第四章，“使用集合”，展示了如何使用许多内置的 Python 函数来操作数据集合。本节将重点介绍一些相对简单的函数，如`any()`和`all()`，它们将一组值减少为单个结果。

第五章，“高阶函数”，探讨了常用的高阶函数，如`map()`和`filter()`。本章还包括许多其他高阶函数，以及如何创建我们自己的高阶函数。

第六章，“递归和归约”，展示了如何使用递归设计算法，然后将其优化为高性能的`for`循环。我们还将研究一些其他广泛使用的归约，包括`collections.Counter()`函数。

第七章，“附加元组技术”，展示了我们可以使用不可变元组和命名元组而不是有状态对象的许多方法。不可变对象有一个更简单的接口：我们永远不必担心滥用属性并将对象设置为一些不一致或无效的状态。

第八章，“Itertools 模块”，研究了标准库模块中的一些函数。这些函数集简化了处理集合或生成器函数的程序编写。

第九章，“更多 Itertools 技术”，涵盖了 itertools 模块中的组合函数。这些函数的用处相对较少。本章包括一些例子，说明了对这些函数的不慎使用以及组合爆炸的后果。

第十章，“Functools 模块”，将展示如何使用该模块中的一些函数进行函数式编程。该模块中的一些函数更适合构建装饰器，并留待下一章。然而，其他函数提供了设计和实现函数程序的几种更多方式。

第十一章，“装饰器设计技巧”，展示了如何将装饰器视为构建复合函数的一种方式。虽然这里有相当大的灵活性，但也有一些概念上的限制：我们将探讨过于复杂的装饰器可能变得令人困惑而不是有帮助的方式。

第十二章，“多进程和线程模块”，指出了良好的函数式设计的一个重要结果：我们可以分配处理工作负载。使用不可变对象意味着我们不能因为同步不良的写操作而破坏对象。

第十三章，“条件表达式和操作员模块”，将展示一些我们可以打破 Python 严格的求值顺序的方法。在这里我们所能实现的有限制。我们还将看看操作员模块以及操作员模块如何对一些简单的处理进行轻微澄清。

第十四章，“PyMonad 库”，审查了 PyMonad 库的一些特性。这提供了一些额外的函数式编程特性。这也提供了学习更多关于单子的方法。在一些函数式语言中，单子是强制执行特定顺序的重要方式，以防止被优化为不希望的顺序。由于 Python 已经对表达式和语句有严格的顺序，单子特性更多是具有教学意义而非实际意义。

第十五章，“Web 服务的功能方法”，展示了我们如何将 Web 服务视为一个嵌套的函数集合，将请求转换为回复。我们将看到如何利用函数式编程概念来构建响应迅速、动态的网络内容。

第十六章，“优化和改进”，包括一些有关性能和优化的额外提示。我们将强调诸如记忆化之类的技术，因为它们易于实现，并且在正确的情况下可以产生显著的性能改进。

# 您需要为这本书做些什么

这本书假设您对 Python 3 和应用程序开发的一般概念有一定了解。我们不会深入研究 Python 的微妙或复杂特性；我们将避免对语言内部的考虑。

我们将假设您对函数式编程有一定了解。由于 Python 不是一种函数式编程语言，我们无法深入探讨函数式概念。我们将挑选适合 Python 的函数式编程方面，并仅利用那些看似有用的方面。

一些示例使用探索性数据分析（EDA）作为问题领域，以展示函数式编程的价值。对基本概率和统计学的一些了解将有助于理解。只有少数示例会涉及更严肃的数据科学。

您需要安装并运行 Python 3.3 或 3.4。有关 Python 的更多信息，请访问[`www.python.org/`](http://www.python.org/)。

在第十四章，“PyMonad 库”，我们将看看如何安装这个额外的库。如果您有 Python 3.4，其中包括 pip 和 Easy Install，这将非常容易。如果您有 Python 3.3，您可能已经安装了 pip 或 Easy Install，或者两者都有。一旦您有了安装程序，您就可以添加 PyMonad。访问[`pypi.python.org/pypi/PyMonad/`](https://pypi.python.org/pypi/PyMonad/)了解更多详情。

# 这本书是为谁准备的

这本书适用于希望通过借鉴函数式编程语言的技术和设计模式来创建简洁、表达力强的 Python 程序的程序员。一些算法可以用函数式风格优雅地表达；我们可以—而且应该—调整这一点，使 Python 程序更易读和易维护。

在某些情况下，对问题的功能方法也会导致极高性能的算法。Python 使得创建大型中间数据结构变得太容易，占用内存和处理器时间。通过函数式编程设计模式，我们经常可以用生成器表达式替换大型列表，这些表达式同样具有表现力，但占用的内存更少，运行速度更快。

# 约定

在这本书中，您将找到一些区分不同信息类型的文本样式。以下是一些这些样式的示例，以及它们的含义解释。

文本中的代码单词显示如下：“我们可以创建一个`Pool`对象，将任务分配给并发工作进程，并期望任务并发执行。”

代码块设置如下：

```py
GIMP Palette
Name: Crayola
Columns: 16
#
```

任何命令行输入或输出都是这样写的：

```py
def max(a, b):
 **f = {a >= b: lambda: a, b >= a: lambda: b}[True]
 **return f()

```

### 注意

警告或重要说明会出现在这样的框中。

### 提示

提示和技巧会出现在这样。


# 第一章：介绍函数式编程

函数式编程使用表达式和求值来定义计算，通常封装在函数定义中。它淡化或避免了状态变化和可变对象的复杂性。这往往会创建更简洁和表达力更强的程序。在本章中，我们将介绍一些表征函数式编程的技术。我们将确定一些将这些特性映射到**Python**的方法。最后，我们还将讨论一些使用这些设计模式构建 Python 应用程序时函数式编程的好处。

Python 具有许多函数式编程特性。它不是一个纯粹的函数式编程语言。它提供了足够多的正确类型的特性，使其具有函数式编程的好处。它还保留了从命令式编程语言中获得的所有优化能力。

我们还将研究一个问题领域，我们将在本书的许多示例中使用它。我们将尽量紧密地遵循**探索性数据分析**（**EDA**），因为它的算法通常是函数式编程的很好的例子。此外，函数式编程的好处在这个问题领域中迅速积累。

我们的目标是建立一些函数式编程的基本原则。更严肃的 Python 代码将从第二章 *介绍一些函数式特性*开始。

### 注意

在本书中，我们将专注于 Python 3 的特性。然而，一些示例也可能在 Python 2 中工作。

# 确定一个范式

很难确定编程范式的宇宙中填充了什么。对于我们的目的，我们将区分许多编程范式中的两种：**函数式编程**和**命令式编程**。这两者之间的一个重要区别是状态的概念。

在命令式语言中，比如 Python，计算的状态由各个命名空间中变量的值反映出来。变量的值建立了计算的状态；每种语句都通过添加、改变（甚至删除）变量来对状态进行明确定义的改变。一种语言是命令式的，因为每个语句都是一个命令，以某种方式改变状态。

我们的一般重点是赋值语句以及它如何改变状态。Python 还有其他语句，比如`global`或`nonlocal`，它们修改特定命名空间中变量的规则。像`def`、`class`和`import`这样的语句改变了处理上下文。其他语句，比如`try`、`except`、`if`、`elif`和`else`，作为守卫来修改一组语句如何改变计算状态。类似地，像`for`和`while`这样的语句包装了一块语句，以便这些语句可以重复地改变计算的状态。然而，所有这些不同类型的语句的重点都在于改变变量的状态。

理想情况下，每个语句都会从初始条件推进计算状态，朝着期望的最终结果。这个“推进计算”断言可能很难证明。一种方法是定义最终状态，找到一个语句来建立这个最终状态，然后推断出这个最终语句需要的前提条件。这个设计过程可以迭代，直到得出一个可接受的初始状态。

在函数式语言中，我们用函数的评估来替换状态——变量的变化值。每个函数评估都会从现有对象创建一个新对象或多个对象。由于函数式程序是函数的组合，我们可以设计易于理解的低级函数，并且我们将设计更高级的组合，这些组合也可以比复杂的语句序列更容易可视化。

函数评估更接近数学形式主义。因此，我们经常可以使用简单的代数来设计一个算法，清楚地处理边界情况和边界条件。这使我们更有信心函数能够正常工作。它还使得很容易找到正式单元测试的测试用例。

重要的是要注意，与命令式（面向对象或过程式）程序相比，函数式程序往往相对简洁、表达力强、高效。这种好处并不是自动的；它需要仔细的设计。这种设计工作通常比功能上类似的过程式编程更容易。

# 将过程式范例细分

我们可以将命令式语言细分为许多离散的类别。在本节中，我们将快速浏览过程式与面向对象的区别。重要的是要看到面向对象编程是命令式编程的一个子集。过程式和面向对象的区别并不反映函数式编程所代表的基本差异。

我们将使用代码示例来说明这些概念。对于一些人来说，这将感觉像是重复造轮子。对于其他人来说，这提供了对抽象概念的具体表达。

对于某些计算，我们可以忽略 Python 的面向对象特性，编写简单的数值算法。例如，我们可以编写类似以下内容来获取数字范围：

```py
s = 0
for n in range(1, 10):
    if n % 3 == 0 or n % 5 == 0:
        s += n
print(s)
```

我们使这个程序严格过程化，避免了对 Python 对象特性的显式使用。程序的状态由变量`s`和`n`的值定义。变量`n`取值使得 1 ≤ `n` < 10。由于`loop`涉及对`n`值的有序探索，我们可以证明当`n == 10`时它将终止。类似的代码也可以在 C 或 Java 中使用它们的原始（非对象）数据类型。

我们可以利用**Python**的**面向对象**编程（**OOP**）特性，创建一个类似的程序：

```py
m = list()
for n in range(1, 10):
    if n % 3 == 0 or n % 5 == 0:
        m.append(n)
print(sum(m))
```

这个程序产生了相同的结果，但它在进行过程中积累了一个有状态的集合对象`m`。计算的状态由变量`m`和`n`的值定义。

`m.append(n)`和`sum(m)`的语法可能会让人感到困惑。这导致一些程序员错误地坚持认为 Python 在某种程度上不是纯粹的面向对象，因为它混合了`function()`和`object.method()`的语法。请放心，Python 是纯粹的面向对象。一些语言，比如**C++**，允许使用诸如`int`、`float`和`long`之类的原始数据类型，这些类型不是对象。Python 没有这些原始类型。前缀语法的存在并不改变语言的本质。

要严谨一些，我们可以完全拥抱对象模型，子类，`list`类，并添加一个`sum`方法：

```py
class SummableList(list):
    def sum( self ):
        s= 0
        for v in self.__iter__():
            s += v
        return s
```

如果我们使用`SummableList()`类而不是`list()`方法初始化变量`m`，我们可以使用`m.sum()`方法而不是`sum(m)`方法。这种改变有助于澄清 Python 确实是完全面向对象的想法。前缀函数表示法的使用纯粹是一种语法糖。

这三个例子都依赖于变量来明确显示程序的状态。它们依赖于`assignment`语句来改变变量的值，并推进计算向完成的方向。我们可以在这些例子中插入`assert`语句来证明预期的状态变化被正确实现。

重点不在于命令式编程在某种程度上有问题。重点在于函数式编程导致了观点的改变，这在许多情况下可能非常有帮助。我们将展示相同算法的函数视图。函数式编程并不会使这个例子变得更短或更快。

## 使用功能范式

从功能的角度来看，3 和 5 的倍数之和可以分为两部分：

+   一系列数字的和

+   一系列通过简单测试条件的值，例如，是 3 和 5 的倍数

序列的和有一个简单的递归定义：

```py
def sum(seq):
    if len(seq) == 0: return 0
    return seq[0] + sum(seq[1:])
```

我们已经定义了两种情况下序列的和：**基本情况**表明长度为零的序列的和为 0，而**递归情况**表明序列的和是第一个值加上剩余序列的和。由于递归定义依赖于一个更短的序列，我们可以确定它最终会退化为基本情况。

在前面例子的最后一行上的`+`运算符和基本情况中的初始值 0 将方程式刻画为一个和。如果我们将运算符改为`*`并将初始值改为 1，它同样可以轻松地计算出一个乘积。我们将在接下来的章节中回到这个泛化的简单想法。

同样，一系列值可以有一个简单的递归定义，如下：

```py
def until(n, filter_func, v):
    if v == n: return []
    if filter_func(v): return [v] + until( n, filter_func, v+1 )
    else: return until(n, filter_func, v+1)
```

在这个函数中，我们将给定的值`v`与上限`n`进行比较。如果`v`达到上限，结果列表必须为空。这是给定递归的基本情况。

给定的`filter_func()`函数定义了另外两种情况。如果`v`的值被`filter_func()`函数传递，我们将创建一个非常小的列表，包含一个元素，并将`until()`函数的剩余值附加到这个列表。如果`v`的值被`filter_func()`函数拒绝，这个值将被忽略，结果将简单地由`until()`函数的剩余值定义。

我们可以看到`v`的值将从初始值增加，直到达到`n`，确保我们很快就会达到基本情况。

以下是我们如何使用`until()`函数来生成 3 或 5 的倍数。首先，我们将定义一个方便的`lambda`对象来过滤值：

```py
mult_3_5= lambda x: x%3==0 or x%5==0
```

（我们将使用 lambda 来强调简单函数的简洁定义。任何比一行表达式更复杂的东西都需要`def`语句。）

我们可以从命令提示符中看到这个 lambda 是如何工作的，以下是一个例子：

```py
>>> mult_3_5(3)
True
>>> mult_3_5(4)
False
>>> mult_3_5(5)
True

```

这个函数可以与`until()`函数一起使用，生成一系列值，这些值是 3 或 5 的倍数。

`until()`函数用于生成一系列值的工作如下：

```py
>>> until(10, lambda x: x%3==0 or x%5==0, 0)
[0, 3, 5, 6, 9]

```

我们可以使用我们的递归`sum()`函数来计算这些值的和。各种函数，如`sum()`，`until()`和`mult_3_5()`都被定义为简单的递归函数。这些值是在不恢复使用中间变量来存储状态的情况下计算出来的。

我们将在几个地方回到这个纯函数递归函数定义的思想。这里重要的是要注意，许多函数式编程语言编译器可以优化这些简单的递归函数。Python 无法进行相同的优化。

## 使用一个功能混合

我们将继续这个例子，使用前一个例子的大部分功能版本来计算 3 和 5 的倍数的和。我们的**混合**功能版本可能如下所示：

```py
print( sum(n for n in range(1, 10) if n%3==0 or n%5==0) )

```

我们已经使用**嵌套**的**生成器****表达式**来迭代一系列值并计算这些值的和。`range(1, 10)`方法是一个可迭代的，因此也是一种生成器表达式；它生成一系列值![Using a functional hybrid](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_01.jpg)。更复杂的表达式，`n for n in range(1, 10) if n%3==0 or n%5==0`，也是一个可迭代表达式。它产生一组值![Using a functional hybrid](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_02.jpg)。一个变量`n`绑定到每个值，更像是一种表达集合内容的方式，而不是计算状态的指示器。`sum()`函数消耗可迭代表达式，创建一个最终对象，23。

### 提示

一旦一个值绑定到变量上，绑定变量就不会改变。循环中的变量`n`本质上是`range()`函数可用值的简写。

表达式的`if`子句可以提取到一个单独的函数中，这样我们就可以轻松地将其用于其他规则。我们还可以使用一个名为`filter()`的高阶函数，而不是生成器表达式的`if`子句。我们将这个留到第五章，*高阶函数*。

当我们使用生成器表达式时，我们会发现绑定变量处于定义计算状态的模糊边缘。在这个例子中，变量`n`并不直接可比较前两个命令式例子中的变量`n`。`for`语句在本地命名空间中创建一个适当的变量。生成器表达式不会像`for`语句那样创建一个变量：

```py
>>> sum( n for n in range(1, 10) if n%3==0 or n%5==0 )
23
>>> n
Traceback (most recent call last):
 **File "<stdin>", line 1, in <module>
NameError: name 'n' is not defined

```

由于 Python 使用命名空间的方式，可能可以编写一个函数来观察生成器表达式中的`n`变量。但我们不会这样做。我们的目标是利用 Python 的函数式特性，而不是检测这些特性在底层是如何实现的。

## 看看对象的创建

在某些情况下，查看中间对象作为计算的历史可能有所帮助。重要的是计算的历史并不是固定的。当函数是可交换的或者是可结合的时，对评估顺序的更改可能导致创建不同的对象。这可能会在不改变结果的正确性的情况下带来性能改进。

考虑这个表达式：

```py
>>> 1+2+3+4
10

```

我们正在研究多种潜在的计算历史，但结果相同。因为`+`运算符是可交换和可结合的，有大量的候选历史可以导致相同的结果。

在候选序列中，有两个重要的替代方案，如下所示：

```py
>>> ((1+2)+3)+4
10
>>> 1+(2+(3+4))
10

```

在第一种情况下，我们从左到右折叠值。这是 Python 隐式工作的方式。中间对象 3 和 6 是作为这个评估的一部分创建的。

在第二种情况下，我们从右到左折叠。在这种情况下，中间对象 7 和 9 被创建。在简单的整数算术情况下，这两个结果的性能是相同的；没有优化的好处。

当我们使用类似`list` append 的东西时，当我们改变关联规则时，可能会看到一些优化改进。

这里有一个简单的例子：

```py
>>> import timeit
>>> timeit.timeit("((([]+[1])+[2])+[3])+[4]")
0.8846941249794327
>>> timeit.timeit("[]+([1]+([2]+([3]+[4])))")
1.0207440659869462

```

在这种情况下，从左到右工作有一些好处。

对于函数式设计来说，重要的是`+`运算符（或`add()`函数）可以以任何顺序使用来产生相同的结果。`+`运算符没有隐藏的副作用，限制了该运算符的使用方式。

## 乌龟的堆栈

当我们使用 Python 进行函数式编程时，我们踏上了一条不严格函数式的混合路径。Python 不是 Haskell、OCaml 或 Erlang。同样，我们的底层处理器硬件也不是函数式的；它甚至不是严格的面向对象的——CPU 通常是过程式的。

|   | *所有编程语言都依赖于抽象、库、框架和虚拟机。这些抽象反过来又可能依赖于其他抽象、库、框架和虚拟机。最恰当的比喻是：世界是由一只巨大的乌龟背负着的。这只乌龟站在另一只巨大的乌龟背上。而那只乌龟又站在另一只乌龟的背上。**这是无穷无尽的乌龟。* |   |
| --- | --- | --- |
|   | --*匿名 * |

抽象层次没有实际的终点。

更重要的是，抽象和虚拟机的存在并不会实质性地改变我们利用 Python 的函数式编程特性来设计软件的方法。

即使在函数式编程社区内，也有更纯净和不那么纯净的函数式编程语言。一些语言广泛使用`monads`来处理像文件系统输入和输出这样的有状态的事物。其他语言依赖于类似于我们使用 Python 的混合环境。我们编写的软件通常是功能性的，但有精心选择的程序性例外。

我们的函数式 Python 程序将依赖以下三个抽象层次的堆栈：

+   我们的应用程序将是函数——一直到最后都是对象

+   支持我们函数式编程的底层 Python 运行时环境是对象——一直到最后都是对象

+   支持 Python 的库是 Python 所依赖的一个对象

操作系统和硬件构成了它们自己的一堆对象。这些细节与我们要解决的问题无关。

# 函数式编程的一个经典例子

作为我们介绍的一部分，我们将看一个函数式编程的经典例子。这是基于约翰·休斯的经典论文*为什么函数式编程很重要*。这篇文章发表在一篇名为*Research Topics in Functional Programming*的论文中，由 D. Turner 编辑，1990 年由 Addison-Wesley 出版。

这是一篇关于函数式编程的论文*Research Topics in Functional Programming*的链接：

[`www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf`](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)

这篇关于函数式编程的讨论是深刻的。论文中给出了几个例子。我们只看一个：用于定位函数的根的牛顿-拉弗森算法。在这种情况下，函数是平方根。

这很重要，因为这个算法的许多版本都依赖于通过“循环”管理的显式状态。事实上，休斯的论文提供了一段强调有状态的命令式处理的**Fortran**代码片段。

这个近似的基础是从当前近似值计算下一个近似值。`next_()`函数接受`x`，一个`sqrt(n)`方法的近似值，并计算一个下一个值，该值将包围正确的根。看下面的例子：

```py
def next_(n, x):
 **return (x+n/x)/2

```

这个函数计算一系列值。每次值之间的距离减半，所以它们很快就会收敛到这样一个值，使得![A classic example of functional programming](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_04.jpg)，这意味着![A classic example of functional programming](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_05.jpg)。我们不想调用`next()`方法，因为这个名称会与内置函数冲突。我们将其称为`next_()`方法，以便我们尽可能地遵循原始的演示。

当在命令提示符中使用该函数时，它的样子是这样的：

```py
>>> n= 2
>>> f= lambda x: next_(n, x)
>>> a0= 1.0
>>> [ round(x,4) for x in (a0, f(a0), f(f(a0)), f(f(f(a0))),) ]
[1.0, 1.5, 1.4167, 1.4142]

```

我们将`f()`方法定义为一个`lambda`，它将收敛到![A classic example of functional programming](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_06.jpg)。我们从 1.0 开始作为![A classic example of functional programming](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_07.jpg)的初始值。然后我们评估了一系列递归评估：![A classic example of functional programming](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_08.jpg)，![A classic example of functional programming](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_09.jpg)等等。我们使用生成器表达式来评估这些函数，这样我们可以四舍五入每个值。这样输出更容易阅读，并且更容易与`doctest`一起使用。这个序列似乎很快就会收敛到![A classic example of functional programming](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_06.jpg)。

我们可以编写一个函数，它（原则上）会生成一个无限序列的值，这些值会收敛到正确的平方根：

```py
def repeat(f, a):
 **yield a
 **for v in repeat(f, f(a)):
 **yield v

```

这个函数将使用函数`f()`和初始值`a`生成近似值。如果我们提供之前定义的`next_()`函数，我们将得到一个近似于`n`参数的平方根的序列。

### 提示

`repeat()`函数期望`f()`函数有一个参数，然而我们的`next_()`函数有两个参数。我们可以使用一个`lambda`对象`lambda x: next_(n, x)`来创建`next_()`函数的一个部分版本，其中一个变量被绑定。

Python 生成器函数不能简单地递归，它们必须显式地迭代递归结果，逐个产生它们。尝试使用简单的`return repeat(f, f(a))`将结束迭代，返回一个生成器表达式而不是产生值的序列。

我们有两种方法可以返回所有的值，而不是返回一个生成器表达式，如下所示：

+   我们可以按照以下方式编写显式的`for`循环：

```py
for x in some_iter: yield x.
```

+   我们可以使用`yield from`语句如下：

```py
yield from some_iter.
```

递归生成器函数产生值的两种技术是等价的。我们将尝试强调`yield from`。然而，在某些情况下，带有复杂表达式的`yield`会比等价的映射或生成器表达式更清晰。

当然，我们不希望整个无限序列。当两个值非常接近时，我们将停止生成值，这样我们可以称其中一个为我们正在寻找的平方根。接近的值的常用符号是希腊字母**Epsilon**，**ε**，它可以被认为是我们将容忍的最大误差。

在 Python 中，我们需要对从无限序列中取出项的方法进行一些巧妙的处理。使用一个简单的接口函数来包装稍微复杂的递归是很好的。看一下以下代码片段：

```py
def within(ε, iterable):
 **def head_tail(ε, a, iterable):
 **b= next(iterable)
 **if abs(a-b) <= ε: return b
 **return head_tail(ε, b, iterable)
 **return head_tail(ε, next(iterable), iterable)

```

我们定义了一个内部函数`head_tail()`，它接受公差`ε`、可迭代序列中的一个项`a`和可迭代序列的其余部分`iterable`。从`iterable`中绑定到名称`b`的下一个项。如果![A classic example of functional programming](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_11.jpg)，那么这两个值足够接近，我们已经找到了平方根。否则，我们使用`b`值在`head_tail()`函数的递归调用中来检查下一对值。

我们的`within()`函数仅仅是为了正确地使用`iterable`参数中的第一个值来初始化内部的`head_tail()`函数。

一些函数式编程语言提供了一种将值放回到可迭代序列中的技术。在 Python 中，这可能是一种将值放回迭代器的`unget()`或`previous()`方法。Python 的可迭代对象并不提供这种丰富的功能。

我们可以使用`next_()`、`repeat()`和`within()`这三个函数来创建一个平方根函数，如下所示：

```py
def sqrt(a0, ε, n):
 **return within(ε, repeat(lambda x: next_(n,x), a0))

```

我们使用`repeat()`函数基于`next_(n,x)`函数生成了一个（可能是）无限的值序列。当我们的`within()`函数找到两个差值小于`ε`的值时，它将停止生成序列中的值。

当我们使用这个版本的`sqrt()`方法时，我们需要提供一个初始种子值`a0`和一个`ε`值。像`sqrt(1.0, .0001, 3)`这样的表达式将从 1.0 的近似值开始，并计算出![A classic example of functional programming](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_01_12.jpg)的值，精确到 0.0001。对于大多数应用程序，初始的`a0`值可以是 1.0。然而，它越接近实际的平方根，这种方法收敛得越快。

这种近似算法的原始示例是在 Miranda 语言中展示的。很容易看出 Miranda 和 Python 之间有一些深刻的区别。最大的区别是 Miranda 能够构造`cons`，将一个值返回到`iterable`，做一种`unget`。Miranda 和 Python 之间的这种并行性使我们相信，许多种类的函数式编程可以在 Python 中轻松完成。

# 探索性数据分析

在本书的后面，我们将以探索性数据分析领域为具体例子，详细介绍函数式编程。这个领域充满了处理复杂数据集的算法和方法；函数式编程通常是问题领域和自动化解决方案之间非常好的契合。

尽管细节因作者而异，但探索性数据分析通常包括以下几个广泛接受的阶段：

+   数据准备：这可能涉及从源应用程序中提取和转换。它可能涉及解析源数据格式并进行某些类型的数据清洗，以删除不可用或无效的数据。这是功能设计技术的一个很好的应用。

+   数据探索：这是对可用数据的描述。这通常涉及基本的统计函数。这是另一个探索函数式编程的绝佳场所。我们可以将我们的重点描述为一元和二元统计，但这听起来太艰难和复杂了。这实际上意味着我们将专注于均值、中位数、众数和其他相关的描述统计。数据探索也可能涉及数据可视化。我们将绕过这个问题，因为它并不涉及太多的函数式编程。我建议您使用像`SciPy`这样的工具包。

访问以下链接，了解 SciPY 的工作原理和用法：

[`www.packtpub.com/big-data-and-business-intelligence/learning-scipy-numerical-and-scientific-computing`](https://www.packtpub.com/big-data-and-business-intelligence/learning-scipy-numerical-and-scientific-computing) 或 [`www.packtpub.com/big-data-and-business-intelligence/learning-python-data-visualization`](https://www.packtpub.com/big-data-and-business-intelligence/learning-python-data-visualization)

+   数据建模和机器学习：这往往是规定性的，因为它涉及将模型扩展到新数据。我们将绕过这一点，因为一些模型可能在数学上变得复杂。如果我们在这些主题上花费太多时间，就无法专注于函数式编程。

+   评估和比较：当存在替代模型时，必须评估每个模型，以确定哪个更适合可用数据。这可能涉及模型输出的普通描述统计。这可以从功能设计技术中受益。

EDA 的目标通常是创建一个可以部署为决策支持应用程序的模型。在许多情况下，模型可能是一个简单的函数。简单的函数式编程方法可以将模型应用于新数据，并显示结果供人类消费。

# 总结

我们已经从编程范式的角度看了函数式范式与两种常见的命令式范式的区别。我们在本书中的目标是探索 Python 的函数式编程特性。我们注意到 Python 的一些部分不允许纯粹的函数式编程；我们将使用一些混合技术，将简洁、表达丰富的函数式编程特性与 Python 中的一些高性能优化相结合。

在下一章中，我们将详细介绍五种特定的函数式编程技术。这些技术将构成我们在 Python 中混合使用的函数式编程的基本基础。


# 第二章：介绍一些函数式特性

函数式编程的大多数特性已经是 Python 的一等部分。我们在编写函数式 Python 时的目标是尽可能地将我们的注意力从命令式（过程式或面向对象）技术转移。

我们将研究以下每个函数式编程主题：

+   一等和高阶函数，也称为纯函数。

+   不可变数据。

+   严格和非严格评估。我们也可以称之为急切 vs. 懒惰评估。

+   递归而不是显式循环状态。

+   函数式类型系统。

这应该重申第一章的一些概念。首先，纯函数式编程避免了通过变量赋值维护显式状态的复杂性。其次，Python 不是一个纯函数式语言。

我们不提供对函数式编程的严格定义。相反，我们将找到一些不容置疑重要的共同特征。我们将避开模糊的边缘。

# 一等函数

函数式编程通常简洁而富有表现力。实现这一点的一种方法是将函数作为其他函数的参数和返回值。我们将看到许多操纵函数的例子。

为了使这个工作，函数必须是运行时环境中的一等对象。在诸如 C 之类的编程语言中，函数不是运行时对象。然而，在 Python 中，函数是由`def`语句创建的对象，可以被其他 Python 函数操纵。我们也可以通过将`lambda`分配给变量来创建一个可调用对象的函数。

函数定义如何创建具有属性的对象：

```py
>>> def example(a, b, **kw):
...    return a*b
...
>>> type(example)
<class 'function'>
>>> example.__code__.co_varnames
('a', 'b', 'kw')
>>> example.__code__.co_argcount
2

```

我们创建了一个名为`example`的对象，它是`function()`类的对象。这个对象有许多属性。与函数对象关联的`__code__`对象有它自己的属性。实现细节并不重要。重要的是函数是一等对象，可以像所有其他对象一样被操纵。我们之前显示了函数对象的许多属性中的两个值。

## 纯函数

为了表达，函数在函数式编程设计中使用将不受副作用创建的混乱的影响。使用纯函数也可以通过改变评估顺序来实现一些优化。然而，最大的优势来自于纯函数在概念上更简单，更容易测试。

要在 Python 中编写纯函数，我们必须编写仅限于本地的代码。这意味着我们必须避免使用`global`语句。我们需要仔细查看任何使用`nonlocal`；虽然它是另一个作用域中的副作用，但它局限于`nested`函数定义。这是一个容易满足的标准。纯函数是 Python 程序的一个常见特性。

没有一种简单的方法来保证 Python 函数没有副作用。很容易粗心地违反纯函数规则。如果我们想担心我们能否遵循这个规则，我们可以编写一个使用`dis`模块扫描给定函数的`__code__.co_code`编译代码的全局引用的函数。它还可以报告内部闭包的使用，以及`__code__.co_freevars` `tuple`方法。这是一个对一个罕见问题的相当复杂的解决方案；我们不会进一步追求它。

Python 的`lambda`是一个纯函数。虽然这不是一个高度推荐的风格，但通过`lambda`值可以创建纯函数。

这是通过将`lambda`分配给变量创建的一个函数：

```py
>>> mersenne = lambda x: 2**x-1
>>> mersenne(17)
131071

```

我们使用`lambda`创建了一个纯函数，并将其分配给变量`mersenne`。这是一个可调用对象，具有一个参数值，返回一个值。因为 lambda 不能有赋值语句，它们总是纯函数，适用于函数式编程。

## 高阶函数

我们可以使用高阶函数实现富有表现力、简洁的程序。这些函数接受一个函数作为参数，或者返回一个函数作为值。我们可以使用高阶函数来从简单的函数中创建复合函数。

考虑 Python 的`max()`函数。我们可以提供一个函数作为参数，并修改`max()`函数的行为。

这是一些我们可能想要处理的数据：

```py
>>> year_cheese = [(2000, 29.87), (2001, 30.12), (2002, 30.6), (2003, 30.66),(2004, 31.33), (2005, 32.62), (2006, 32.73), (2007, 33.5), (2008, 32.84), (2009, 33.02), (2010, 32.92)]

```

我们可以这样应用`max()`函数：

```py
>>> max(year_cheese)
(2010, 32.92)

```

默认行为是简单地比较序列中的每个`tuple`。这将返回在位置 0 上具有最大值的`tuple`。

由于`max()`函数是一个高阶函数，我们可以提供另一个函数作为参数。在这种情况下，我们将使用`lambda`作为函数；这将被`max()`函数使用，如下所示：

```py
>>> max(year_cheese, key=lambda yc: yc[1])
(2007, 33.5)

```

在这个例子中，`max()`函数应用了提供的`lambda`，并返回了位置 1 中最大值的元组。

Python 提供了丰富的高阶函数集合。我们将在后面的章节中看到 Python 的每个高阶函数的示例，主要在第五章中，*高阶函数*。我们还将看到如何轻松地编写我们自己的高阶函数。

# 不可变数据

由于我们不使用变量来跟踪计算的状态，我们的重点需要放在不可变对象上。我们可以广泛使用`tuples`和`namedtuples`来提供更复杂的不可变数据结构。

不可变对象的概念对 Python 并不陌生。使用不可变的`tuples`而不是更复杂的可变对象可能会带来性能优势。在某些情况下，好处来自于重新思考算法，以避免对象变异的成本。

我们将几乎完全避免类定义。在**面向对象**(**OOP**)语言中避免对象似乎是一种厌恶。函数式编程根本不需要有状态的对象。我们将在本书中看到这一点。有理由定义`callable`对象；这是一种为密切相关的函数提供`namespace`的整洁方式，并且支持愉快的可配置性。

我们将看一个与不可变对象很好配合的常见设计模式：`wrapper()`函数。元组列表是一种相当常见的数据结构。我们经常以以下两种方式之一处理这个元组列表：

+   **使用高阶函数**：如前所示，我们将`lambda`作为`max()`函数的参数提供：`max(year_cheese, key=lambda yc: yc[1])`

+   **使用 Wrap-Process-Unwrap 模式**：在一个函数上下文中，我们应该称之为`unwrap(process(wrap(structure)))`模式

例如，看下面的命令片段：

```py
>>> max(map(lambda yc: (yc[1],yc), year_cheese))
(33.5, (2007, 33.5))
>>> _[1]
(2007, 33.5)

```

这符合三部分模式，尽管它可能不明显地符合得很好。

首先，我们使用`map(lambda yc: (yc[1],yc), year_cheese)`进行包装。这将把每个项目转换成一个带有原始项目后面的两个元组。在这个例子中，比较键仅仅是`yc[1]`。

其次，使用`max()`函数进行处理。由于每个数据片段都被简化为一个用于比较的两个元组，我们实际上不需要`max()`函数的高阶函数特性。`max()`函数的默认行为正是我们需要的。

最后，我们使用下标`[1]`进行解包。这将选择`max()`函数选定的两个元组中的第二个元素。

这种`wrap`和`unwrap`是如此常见，以至于一些语言有特殊的函数，名称如`fst()`和`snd()`，我们可以使用作为函数前缀，而不是语法后缀`[0]`或`[1]`。我们可以使用这个想法来修改我们的 wrap-process-unwrap 示例，如下：

```py
snd= lambda x: x[1]
snd( max(map(lambda yc: (yc[1],yc), year_cheese)))

```

我们定义了一个`snd()`函数来选择`元组`中的第二个项目。这为我们提供了一个更易读的版本`unwrap(process(wrap()))`。我们使用`map(lambda... , year_cheese)`来`wrap`我们的原始数据项。我们使用`max()`函数作为处理，最后使用`snd()`函数从元组中提取第二个项目。

在第十三章中，*条件表达式和操作符模块*，我们将看一些替代`lambda`函数的选择，比如`fst()`和`snd()`。

# 严格和非严格评估

函数式编程的效率部分来自于能够推迟计算直到需要。懒惰或非严格评估的想法非常有帮助。它是如此有帮助，以至于 Python 已经提供了这个特性。

在 Python 中，逻辑表达式运算符`and`、`or`和`if-then-else`都是非严格的。我们有时称它们为*短路*运算符，因为它们不需要评估所有参数来确定结果值。

以下命令片段显示了`and`运算符的非严格特性：

```py
>>> 0 and print("right")
0
>>> True and print("right")
right

```

当我们执行上述命令片段时，`and`运算符的左侧等同于`False`；右侧不会被评估。当左侧等同于`True`时，右侧会被评估。

Python 的其他部分是严格的。在逻辑运算符之外，表达式会从左到右急切地进行评估。一系列的语句行也会按顺序严格进行评估。`Literal`列表和`元组`需要急切的评估。

当一个类被创建时，方法函数是按严格顺序定义的。在类定义的情况下，方法函数被收集到一个字典中（默认情况下），并且在创建后不保持顺序。如果我们提供了两个同名的方法，第二个方法会被保留，因为严格的评估顺序。

然而，Python 的生成器表达式和生成器函数是懒惰的。这些表达式不会立即创建所有可能的结果。如果不明确记录计算的细节，很难看到这一点。这是`range()`函数的一个版本的例子，它具有显示它创建的数字的副作用：

```py
>>> def numbers():
...    for i in range(1024):
...        print( "=", i )
...        yield i

```

如果这个函数是急切的，它会创建所有 1024 个数字。由于它是懒惰的，它只在被请求时创建数字。

### 注意

旧的 Python 2 `range()`函数是急切的，并创建了一个包含所有请求的数字的实际列表对象。Python 2 有一个`xrange()`函数，它是懒惰的，并且与 Python 3 的`range()`函数的语义相匹配。

我们可以以一种显示懒惰评估的方式使用这个喧闹的`numbers()`函数。我们将编写一个函数，评估这个迭代器的一些值，但不是全部值：

```py
>>> def sum_to(n):
...    sum= 0
...    for i in numbers():
...        if i == n: break
...        sum += i
...    return sum

```

`sum_to()`函数不会评估`numbers()`函数的整个结果。它只在消耗了`numbers()`函数的一些值后中断。我们可以在以下日志中看到对值的消耗：

```py
>>> sum_to(5)
= 0
= 1
= 2
= 3
= 4
= 5
10

```

正如我们将在后面看到的，Python 生成器函数具有一些特性，使它们在简单的函数式编程中有些尴尬。具体来说，生成器在 Python 中只能使用一次。我们必须小心使用懒惰的 Python 生成器表达式。

# 递归而不是显式循环状态

函数式程序不依赖于`循环`和跟踪循环状态的相关开销。相反，函数式程序试图依赖于递归函数的更简单的方法。在一些语言中，程序被写成递归，但是编译器的**尾递归优化**（**TCO**）将它们改为`循环`。我们将在第六章中介绍一些递归，并对其进行仔细的检查。

我们将看一个简单的迭代来测试一个数是否为质数。质数是一个自然数，只能被 1 和它自己整除。我们可以创建一个天真且性能不佳的算法来确定一个数在 2 和该数之间是否有任何因子。这个算法的优点是简单；它可以用来解决**Project Euler**问题。阅读**Miller**-**Rabin**素性测试，以获得一个更好的算法。

我们将使用术语`互质`来表示两个数只有 1 作为它们的公因数。例如，数字 2 和 3 是`互质`的。然而，数字 6 和 9 不是`互质`的，因为它们有 3 作为公因数。

如果我们想知道一个数*n*是否是质数，我们实际上是在问：数字*n*是否与所有质数*p*`互质`，使得![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_03.jpg)。我们可以简化这个问题，使用所有整数*p*，使得![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_05.jpg)。

有时，将其形式化如下有所帮助：

![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_02.jpg)

在 Python 中，表达式可能如下所示：

```py
not any(n%p==0 for p in range(2,int(math.sqrt(n))+1))

```

从数学形式转换为 Python 的更直接的转换将使用`all(n%p != 0... )`，但这需要严格评估所有值*p*。`not any`版本可以在找到`True`值时提前终止。

这个简单的表达式中有一个`for`循环：它不是无状态的函数式编程的纯例子。我们可以将其重新构建为一个处理值集合的函数。我们可以询问数字*n*是否在范围![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_07.jpg)内是`互质`的。这使用符号`)`来显示半开区间：包括较小的值，不包括较大的值。这是 Python `range()`函数的典型行为。我们还将限制自己在自然数的域内。例如，平方根值被隐式地截断为`整数`。

我们可以将质数的定义看作是以下内容：

![递归而不是显式循环状态当在一系列简单的值上定义递归函数时，基本情况可以是一个空范围。非空范围通过处理一个值和一个比一个值更窄的范围来递归处理。我们可以将其形式化如下：![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_11.jpg)

通过检查以下两种情况，可以相对容易地确认这个版本：

+   如果范围为空，![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_12.jpg)，我们会评估类似于：![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_14.jpg)。范围不包含任何值，因此返回值是一个微不足道的`True`。

+   如果范围不为空，我们会询问类似于![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_16.jpg)。这可以分解为![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_18.jpg)。对于这个例子，我们可以看到第一个子句是`True`，我们将递归地评估第二个子句。

作为读者的练习：可以重新定义这个递归，使其递减而不是递增，在第二种情况下使用`a,b-1)`。

顺便说一句，有些人喜欢将空区间视为*a*≥*b*，而不是*a*=*b*。这是不必要的，因为*a*每次增加 1，我们可以很容易地保证*a*≤*b*，最初。没有办法让*a*通过函数中的某个错误跳过*b*；我们不需要过度指定空区间的规则。

以下是一个实现这个质数定义的 Python 代码片段：

```py
def isprimer(n):
    def isprime(k, coprime):
        """Is k relatively prime to the value coprime?"""
        if k < coprime*coprime: return True
        if k % coprime == 0: return False
        return isprime(k, coprime+2)
    if n < 2: return False
    if n == 2: return True
    if n % 2 == 0: return False
    return isprime(n, 3)
```

这显示了一个`isprime()`函数的递归定义。半开区间![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_19.jpg)被缩减为只有低端参数*a*，在这个函数中被重命名为`coprime`以澄清其目的。基本情况被实现为`n < coprime*coprime`；从`coprime`到`1+math.sqrt(n)`的值范围将为空。

非严格的`and`操作是通过将其拆分成一个单独的`if`语句来实现的，`if n % coprime == 0`。`return`语句是具有不同`coprime`测试值的递归调用。

因为递归是函数的尾部，这是**尾递归**的一个例子。这个函数嵌入在一个函数中，该函数建立了*n*是一个大于 2 的奇数的边界条件。没有必要测试任何偶数是否为质数，因为 2 是唯一的偶数质数。

在这个例子中重要的是，这个递归函数的两种情况设计起来非常简单。将值范围作为内部`isprime()`函数的显式参数允许我们以反映不断缩小的区间的参数值递归调用函数。

虽然这通常非常简洁和富有表现力，但我们在使用 Python 中的递归时必须要小心。出现了两个问题。它们如下所述：

+   Python 对递归函数施加了递归限制，以检测具有不正确定义基本情况的递归函数。

+   Python 确实有一个编译器来进行尾调用优化（TCO）。

默认的递归限制是 1,000，对于许多算法来说是足够的。可以使用`sys.setrecursionlimit()`函数来更改这个限制。提高这个限制并不明智，因为这可能会导致超出操作系统的内存限制，并导致 Python 解释器崩溃。

如果我们尝试在一个超过 1,000,000 的数字上使用递归的`isprimer()`函数，我们将违反递归限制。如果我们使用了一个更聪明的`isprimer()`函数，它只检查质因数而不是所有因数，我们将在第 1,000 个质数 7,919 处停止，将我们的质数测试限制在 62,710,561 以下的数字。

一些函数式编程语言可以优化简单的递归函数，比如我们的`isprimer()`函数。优化编译器可以将`isprimer(n, coprime+1)`方法的递归评估转换为低开销的`循环`。优化往往会使调用堆栈混乱；调试优化程序变得困难。Python 不执行这种优化。性能和内存被牺牲以换取清晰和简单。

在 Python 中，当我们使用生成器表达式而不是递归函数时，我们实质上是手动进行尾调用优化。我们不依赖于某些函数式语言的编译器来进行这种优化。这是作为生成器表达式完成的 TCO：

```py
def isprime(p):
    if p < 2: 
        return False    
    if p == 2: 
        return True    
    if p % 2 == 0: 
        return False    
    return not any(p==0 for p in range(3,int(math.sqrt(n))+1,2))
```

这个函数包含了许多函数式编程原则，但它使用了生成器表达式而不是纯递归。### 提示我们经常会优化一个纯递归函数，使用显式的`for` `loop`来进行生成器表达式。

这个算法对于大质数来说很慢。对于合数，该函数通常会快速返回一个值。如果用于像![递归而不是显式循环状态](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_02_21.jpg)这样的值，它将花费几分钟来证明这是质数。显然，慢的原因在于检查 1,518,500,249 个候选因子。

# 函数类型系统

一些函数式编程语言，如**Haskell**和**Scala**，是静态编译的，并依赖于声明的函数和它们的参数的类型。为了提供 Python 已经具有的灵活性，这些语言具有复杂的类型匹配规则，以便编写一个通用函数，可以适用于各种相关类型。

在面向对象的 Python 中，我们经常使用类继承层次结构，而不是复杂的函数类型匹配。我们依赖 Python 根据简单的名称匹配规则将运算符分派给适当的方法。

由于 Python 已经具有所需的灵活性，编译函数语言的类型匹配规则并不相关。事实上，我们可以说，复杂的类型匹配是静态编译强加的一种变通方法。Python 不需要这种变通方法，因为它是一种动态语言。

在某些情况下，我们可能不得不诉诸于使用`isinstance(a, tuple)`来检测参数值是`tuple`还是单个值。这在函数式程序中和面向对象程序中一样罕见。

# 熟悉的领域

从前面的主题列表中出现的一个想法是，大多数函数式编程已经存在于 Python 中。事实上，大多数函数式编程已经是面向对象编程的一个非常典型和常见的部分。

作为一个非常具体的例子，一个流利的**应用程序接口**（**API**）是函数式编程的一个非常明显的例子。如果我们花时间创建一个类，在每个方法函数中都有`return self()`，我们可以这样使用它：

```py
some_object.foo().bar().yet_more()

```

我们可以很容易地编写几个密切相关的函数，其工作如下：

```py
yet_more(bar(foo(some_object)))

```

我们已经将语法从传统的面向对象的后缀表示法切换到了更具功能性的前缀表示法。Python 自由地使用这两种表示法，通常使用特殊方法名的前缀版本。例如，`len()`函数通常由类的`__len__()`特殊方法实现。

当然，上面显示的类的实现可能涉及高度状态化的对象。即使如此，观点上的微小变化可能会揭示出一个功能性的方法，可以导致更简洁或更表达的编程。

重点不是命令式编程在某种程度上有问题，或者函数式编程提供了如此大幅度的优越技术。重点是函数式编程导致了一种观点的改变，这在许多情况下可能非常有帮助。

# 保存一些高级概念

我们将把一些更高级的概念放在一边，以便在以后的章节中考虑。这些概念是纯函数语言的实现的一部分。由于 Python 不是纯函数的，我们的混合方法不需要深入考虑这些主题。

我们将提前识别这些内容，以使那些已经了解 Haskell 等函数语言并学习 Python 的人受益。这些基本问题存在于所有编程语言中，但我们将在 Python 中以不同的方式处理它们。在许多情况下，我们可以并且将会转入命令式编程，而不是使用严格的函数式方法。

主题如下：

+   **引用透明度**：当看到惰性评估和编译语言中可能的各种优化时，多条路径指向同一对象的想法是重要的。在 Python 中，这并不重要，因为没有相关的编译时优化。

+   **柯里化**：类型系统将使用柯里化将多参数函数减少为单参数函数。我们将在第十一章*装饰器设计技术*中深入研究柯里化。

+   **单子**：这些是纯函数构造，允许我们以灵活的方式结构化顺序处理管道。在某些情况下，我们将求助于命令式 Python 来实现相同的目标。我们还将利用优雅的`PyMonad`库。我们将把这个推迟到第十四章*PyMonad 库*。

# 总结

在本章中，我们确定了一些特征，这些特征表征了函数式编程范式。我们从头等和高阶函数开始。这个想法是一个函数可以是另一个函数的参数或函数的结果。当函数成为额外编程的对象时，我们可以编写一些非常灵活和通用的算法。

在命令式和面向对象的编程语言（如 Python）中，不可变数据的概念有时会显得奇怪。然而，当我们开始专注于函数式编程时，我们会看到状态变化可能会令人困惑或无益的方式。使用不可变对象可以是一个有益的简化。

Python 专注于严格评估：所有子表达式都通过语句从左到右进行评估。然而，Python 确实执行一些非严格评估。`or`、`and`和`if-else`逻辑运算符是非严格的：并非一定要评估所有子表达式。同样，生成器函数也是非严格的。我们也可以称之为急切与懒惰。Python 通常是急切的，但我们可以利用生成器函数来实现惰性评估。

虽然函数式编程依赖于递归而不是显式的`循环`状态，但 Python 在这方面施加了一些限制。由于堆栈限制和缺乏优化编译器，我们被迫手动优化递归函数。我们将在第六章*递归和归约*中回到这个话题。

尽管许多函数式语言拥有复杂的类型系统，但我们将依赖于 Python 的动态类型解析。在某些情况下，这意味着我们将不得不在类型之间进行手动转换。这也可能意味着我们将不得不创建类定义来处理非常复杂的情况。然而，在大多数情况下，Python 的内置规则将非常优雅地工作。

在下一章中，我们将探讨纯函数的核心概念以及这些概念如何与 Python 的内置数据结构配合。有了这个基础，我们可以看看 Python 中可用的高阶函数以及如何定义我们自己的高阶函数。


# 第三章：函数、迭代器和生成器

函数式编程的核心是使用纯函数将值从输入域映射到输出范围。纯函数没有副作用，在 Python 中相对容易实现。

避免副作用也意味着减少我们对变量赋值来维护计算状态的依赖。我们无法从 Python 语言中清除赋值语句，但我们可以减少对有状态对象的依赖。这意味着我们需要在可用的 Python 内置数据结构中进行选择，选择那些不需要有状态操作的数据结构。

本章将从功能的角度介绍几个 Python 特性，如下所示：

+   无副作用的纯函数

+   函数作为可以作为参数传递或作为结果返回的对象

+   使用面向对象的后缀表示法和前缀表示法来使用 Python 字符串

+   使用元组和命名元组来创建无状态对象的方法

+   使用可迭代集合作为我们的主要功能编程设计工具

我们将研究生成器和生成器表达式，因为这些是处理对象集合的方法。正如我们在第二章中所指出的，*介绍一些功能特性*，在尝试用递归替换所有生成器表达式时会出现一些边界问题。Python 会强加递归限制，并且不会自动处理 TCO：我们必须使用生成器表达式手动优化递归。

我们将编写生成器表达式来执行以下任务：

+   转换

+   重构

+   复杂计算

我们将快速调查许多内置的 Python 集合，以及在追求功能范式时如何使用集合。这可能会改变我们处理`lists`、`dicts`和`sets`的方式。编写功能性的 Python 鼓励我们专注于元组和不可变集合。在下一章中，我们将强调更多与特定类型的集合一起工作的功能性方法。

# 编写纯函数

纯函数没有副作用：变量没有全局变化。如果我们避免使用`global`语句，我们几乎可以达到这个标准。我们还需要避免改变状态可变对象。我们将研究确保纯函数的这两个方面的几种方法。在 Python 全局中引用一个值，使用自由变量是我们可以重写为适当参数的。在大多数情况下，这是相当容易的。

这里有一个例子，解释了使用全局语句的用法：

```py
 **def some_function(a, b, t):
 **return a+b*t+global_adjustment

```

我们可以重构这个函数，将`global_adjustment`变量变成一个适当的参数。我们需要改变对这个函数的每个引用，这可能会在一个复杂的应用程序中产生很大的连锁反应。全局引用将在函数体中作为自由变量可见。对于这个变量，既没有参数也没有赋值，因此可以清楚地看出它是全局的。

Python 中有许多内部对象，这些对象是有状态的。`file`类的实例和所有类似文件的对象都是常用的有状态对象的例子。我们观察到 Python 中最常用的有状态对象通常表现为上下文管理器。并非所有开发人员都使用可用的上下文管理器，但许多对象实现了所需的接口。在一些情况下，有状态对象并没有完全实现上下文管理器接口；在这些情况下，通常会有一个`close()`方法。我们可以使用`contextlib.closing()`函数为这些对象提供适当的上下文管理器接口。

我们无法轻易消除所有有状态的 Python 对象，除非是小型程序。因此，我们必须在利用函数式设计的优势的同时管理状态。为此，我们应该始终使用`with`语句将有状态的文件对象封装到一个明确定义的范围内。

### 提示

始终在`with`上下文中使用文件对象。

我们应该始终避免全局文件对象、全局数据库连接和相关的状态问题。全局文件对象是处理打开文件的非常常见的模式。我们可能有一个如下命令片段所示的函数：

```py
def open(iname, oname):
 **global ifile, ofile
 **ifile= open(iname, "r")
 **ofile= open(oname, "w")

```

在这种情况下，许多其他函数可以使用`ifile`和`ofile`变量，希望它们正确地引用应用程序要使用的`global`文件，这些文件保持打开状态。

这不是一个很好的设计，我们需要避免它。文件应该是函数的适当参数，并且打开的文件应该嵌套在`with`语句中，以确保它们的有状态行为得到适当处理。

这种设计模式也适用于数据库。数据库连接对象通常可以作为应用程序函数的形式参数提供。这与一些流行的 Web 框架的工作方式相反，这些框架依赖于全局数据库连接，以使数据库成为应用程序的一个透明特性。此外，多线程 Web 服务器可能无法从共享单个数据库连接中受益。这表明使用功能设计和一些孤立的有状态特性的混合方法有一些好处。

# 函数作为一等对象

Python 函数是一等对象并不足为奇。在 Python 中，函数是带有许多属性的对象。参考手册列出了适用于函数的许多特殊成员名称。由于函数是带有属性的对象，我们可以使用特殊属性，如`__doc__`或`__name__`提取`docstring`函数或函数的名称。我们还可以通过`__code__`属性提取函数的主体。在编译语言中，由于需要保留源信息，这种内省相对复杂。在 Python 中，这很简单。

我们可以将函数分配给变量，将函数作为参数传递，并将函数作为值返回。我们可以轻松使用这些技术来编写高阶函数。

由于函数是对象，Python 已经具备了许多成为函数式编程语言所需的特性。

此外，可调用对象还帮助我们创建函数，这些函数是一等对象。我们甚至可以将可调用类定义视为高阶函数。我们需要谨慎地使用可调用对象的`__init__()`方法；我们应该避免设置有状态的类变量。一个常见的应用是使用`__init__()`方法创建符合**策略设计模式**的对象。

遵循策略设计模式的类依赖于另一个对象来提供算法或算法的部分。这允许我们在运行时注入算法细节，而不是将细节编译到类中。

以下是一个带有嵌入式策略对象的可调用对象的示例：

```py
import collections
class Mersenne1(collections.Callable):
 **def __init__(self, algorithm):
 **self.pow2= algorithm
 **def __call__(self, arg):
 **return self.pow2(arg)-1

```

这个类使用`__init__()`保存对另一个函数的引用。我们没有创建任何有状态的实例变量。

作为策略对象给出的函数必须将 2 提升到给定的幂。我们可以将三个候选对象插入到这个类中，如下所示：

```py
def shifty(b):
 **return 1 << b
def multy(b):
 **if b == 0: return 1
 **return 2*multy(b-1)
def faster(b):
 **if b == 0: return 1
 **if b%2 == 1: return 2*faster(b-1)
 **t= faster(b//2)
 **return t*t

```

`shifty()`函数使用位左移将 2 提升到所需的幂。`multy()`函数使用一个天真的递归乘法。`faster()`函数使用分治策略，将执行![函数作为一等对象](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_03_01.jpg)次乘法，而不是*b*次乘法。

我们可以使用嵌入的策略算法创建`Mersenne1`类的实例，如下所示：

```py
m1s= Mersenne1(shifty)
m1m= Mersenne1(multy)
m1f= Mersenne1(faster)

```

这显示了我们如何定义产生相同结果但使用不同算法的替代函数。

### 提示

Python 允许我们计算![函数作为一等对象](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_03_02.jpg)，因为这甚至没有接近 Python 的递归限制。这是一个非常大的质数，有 27 位数。

# 使用字符串

由于 Python 字符串是不可变的，它们是函数式编程对象的绝佳示例。Python 的`string`模块有许多方法，所有这些方法都会产生一个新的字符串作为结果。这些方法是没有副作用的纯函数。

`string`方法函数的语法是后缀的，其中大多数函数是前缀的。这意味着当它们与常规函数混合在一起时，复杂的字符串操作可能很难阅读。

在从网页中抓取数据时，我们可能会有一个更干净的函数，它对字符串应用多种转换以清除标点，并返回一个供应用程序其余部分使用的`Decimal`对象。这将涉及前缀和后缀语法的混合使用。

它可能看起来像以下命令片段：

```py
from decimal import *
def clean_decimal(text):
 **if text is None: return text
 **try:
 **return Decimal(text.replace("$", "").replace(",", ""))
 **except InvalidOperation:
 **return text

```

此函数对字符串进行两次替换，以删除`$`和`,`字符串值。生成的字符串被用作`Decimal`类构造函数的参数，该构造函数返回所需的对象。

为了使其更一致，我们可以考虑为`string`方法函数定义自己的前缀函数，如下所示：

```py
def replace(data, a, b):
 **return data.replace(a,b)

```

这使我们可以使用具有一致外观的前缀语法`Decimal(replace(replace(text, "$", ""), ",", ""))`。在这种情况下，我们只是重新排列现有的参数值，允许我们使用额外的技术。我们可以对简单情况进行这样做，例如以下情况：

```py
>>> replace=str.replace
>>> replace("$12.45","$","")

```

12.45

目前尚不清楚这种一致性是否比混合前缀和后缀符号的表示方式有重大改进。多参数函数的问题在于参数最终出现在表达式的各个位置。

一个稍微更好的方法可能是定义一个更有意义的前缀函数来去除标点，如下面的命令片段所示：

```py
def remove( str, chars ):
 **if chars: return remove( str.replace(chars[0], ""), chars[1:] )
 **return str

```

此函数将递归地从`char`变量中删除每个字符。我们可以将其用作`Decimal(remove(text, "$,"))`，以使我们的字符串清理意图更清晰。

# 使用元组和命名元组

由于 Python 元组是不可变对象，它们是适合函数式编程的另一个绝佳示例。Python 的“元组”几乎没有方法函数，因此几乎所有操作都是通过使用前缀语法的函数完成的。元组有许多用例，特别是在处理列表-元组、元组-元组和生成器-元组构造时。

当然，命名元组为元组添加了一个基本功能：我们可以使用名称而不是索引。我们可以利用命名元组来创建数据的堆积对象。这使我们能够编写基于无状态对象的纯函数，但仍然将数据绑定到整洁的对象包中。

我们几乎总是在值集合的上下文中使用元组（和命名元组）。如果我们处理单个值或精确两个值的整洁组，我们通常会将命名参数用作函数的参数。然而，在处理集合时，我们可能需要具有元组的可迭代对象或具有命名元组的可迭代对象。

使用“元组”或“命名元组”对象的决定完全是出于方便考虑。我们可能会将一系列值作为三元组（数字，数字，数字）的形式（假设三元组按照红色、绿色和蓝色的顺序排列）。

我们可以使用函数来拆分三元组，如下面的命令片段所示：

```py
red = lambda color: color[0]
green = lambda color: color[1]
blue = lambda color: color[2]

```

或者，我们可以引入以下命令行：

```py
Color = namedtuple("Color", ("red", "green", "blue", "name"))

```

这使我们可以使用`item.red`而不是`red(item)`。

元组的函数式编程应用集中在可迭代元组设计模式上。我们将仔细研究一些可迭代元组技术。我们将在第七章中查看命名元组技术，*其他元组技术*。

## 使用生成器表达式

我们已经展示了一些生成器表达式的示例。我们将在本章的后面展示更多示例。在本节中，我们将介绍一些更复杂的生成器技术。

我们需要在这里提到一小部分 Python 语法。通常会看到生成器表达式被用来通过`list`推导或`dict`推导创建`list`或`dict`字面量。对于我们的目的，列表显示（或推导）只是生成器表达式的一种用法。我们可以尝试区分显示之外的生成器表达式和显示之内的生成器表达式，但这样做没有任何好处。语法是一样的，除了封闭的标点符号，语义是无法区分的。

显示包括封闭的文字语法：`[x**2 for x in range(10)]`；这个例子是一个列表推导，它从封闭的生成器表达式创建一个列表对象。在本节中，我们将专注于生成器表达式。我们偶尔会创建一个显示，以演示生成器的工作原理。显示的缺点是创建（可能很大的）`collection`对象。生成器表达式是惰性的，只在需要时才创建对象。

我们必须提供关于生成器表达式的两个重要警告，如下：

+   生成器看起来像是序列，除了像`len()`函数这样需要知道集合大小的函数。

+   生成器只能使用一次。之后，它们会变为空。

这是一个我们将用于一些示例的生成器函数：

```py
def pfactorsl(x):
 **if x % 2 == 0:
 **yield 2
 **if x//2 > 1:
 **yield from pfactorsl(x//2)
 **return
 **for i in range(3,int(math.sqrt(x)+.5)+1,2):
 **if x % i == 0:
 **yield i
 **if x//i > 1:
 **yield from pfactorsl(x//i)
 **return
 **yield x

```

我们正在寻找一个数字的质因数。如果数字*x*是偶数，我们将产出 2，然后递归地产出*x*÷2 的所有因子。

对于奇数，我们将遍历大于或等于 3 的奇数值，以找到数字的候选因子。当我们找到一个因子时，我们将产出该因子*i*，然后递归地产出*x*÷*i*的所有因子。

如果我们无法找到一个因子，那么这个数字必须是质数，所以我们可以产出它。

我们将 2 作为一个特殊情况来处理，以减少迭代次数。除了 2 以外，所有的质数都是奇数。

我们除了使用递归之外，还使用了一个重要的`for`循环。这使我们能够轻松处理最多有 1,000 个因子的数字。这个数字至少和![使用生成器表达式](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_03_03.jpg)一样大，这是一个有 300 位数字的数字。由于`for`变量`i`在缩进的循环体之外没有被使用，`i`变量的有状态特性不会导致混淆，如果我们对循环体进行任何更改。

实际上，我们已经进行了尾递归优化，递归调用从 3 到![使用生成器表达式](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_03_04.jpg)。`for`循环使我们免受深度递归调用的影响，这些调用会测试范围内的每个数字。

其他两个`for`循环只是为了消耗可迭代的递归函数的结果而存在。

### 提示

在递归生成器函数中，要小心 return 语句。

不要使用以下命令行：

`return recursive_iter(args)`

它只返回一个生成器对象；它不会评估函数以返回生成的值。使用以下任一种：

`for result in recursive_iter(args): yield result`

或者`yield from recursive_iter(args)`

作为替代，以下命令是一个更纯粹的递归版本：

```py
def pfactorsr(x):
 **def factor_n(x, n):
 **if n*n > x:
 **yield x
 **return
 **if x % n == 0:
 **yield n
 **if x//n > 1:
 **yield from factor_n(x//n, n)
 **else:
 **yield from factor_n(x, n+2)
 **if x % 2 == 0:
 **yield 2
 **if x//2 > 1:
 **yield from pfactorsr(x//2)
 **return
 **yield from factor_n(x, 3)

```

我们定义了一个内部递归函数`factor_n()`，来测试范围内的因子*n*。如果候选因子*n*在范围之外，那么*x*就是质数。否则，我们将看看*n*是否是*x*的因子。如果是，我们将产出*n*和![使用生成器表达式](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_03_06.jpg)的所有因子。如果*n*不是因子，我们将递归地使用*n*+2 进行函数求值。这种递归来测试![使用生成器表达式](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_03_07.jpg)的每个值可以被优化为一个`for`循环，就像前面的例子中所示的那样。

外部函数处理一些边缘情况。与其他与素数相关的处理一样，我们将 2 作为一个特殊情况处理。对于偶数，我们将产生 2，然后递归地评估`pfactorsr()`以获得*x*÷2。所有其他素数因子必须是大于或等于 3 的奇数。我们将从 3 开始评估`factors_n()`函数以测试这些其他候选素数因子。

### 提示

纯递归函数只能找到最多约 4,000,000 的数字的素数因子。在这之上，Python 的递归限制将被达到。

## 探索生成器的限制

我们注意到生成器表达式和生成器函数有一些限制。可以通过执行以下命令片段来观察这些限制：

```py
>>> from ch02_ex4 import *
>>> pfactorsl( 1560 )
<generator object pfactorsl at 0x1007b74b0>
>>> list(pfactorsl(1560))
[2, 2, 2, 3, 5, 13]
>>> len(pfactorsl(1560))
Traceback (most recent call last):
 **File "<stdin>", line 1, in <module>
TypeError: object of type 'generator' has no len()

```

在第一个例子中，我们看到生成器函数并不严格。它们是懒惰的，在我们消耗生成器函数之前没有正确的值。这并不是一个限制，这正是生成器表达式与 Python 中的函数式编程相匹配的整个原因。

在第二个例子中，我们从生成器函数中实现了一个列表对象。这对于查看输出和编写单元测试用例很方便。

在第三个例子中，我们看到了生成器函数的一个限制：没有`len()`。

生成器函数的另一个限制是它们只能使用一次。例如，看下面的命令片段：

```py
>>> result= pfactorsl(1560)
>>> sum(result)
27
>>> sum(result)
0

```

`sum()`方法的第一次评估执行了生成器的评估。`sum()`方法的第二次评估发现生成器现在为空了。我们只能消耗值一次。

生成器在 Python 中有一个有状态的生命周期。虽然它们对于函数式编程的某些方面非常好，但并不完美。

我们可以尝试使用`itertools.tee()`方法来克服一次性限制。我们将在第八章*迭代工具模块*中深入研究这个问题。这里是它的一个快速示例用法：

```py
import itertools
def limits(iterable):
 **max_tee, min_tee = itertools.tee(iterable, 2)
 **return max(max_tee), min(min_tee)

```

我们创建了参数生成器表达式的两个克隆，`max_tee()`和`min_tee()`。这使原始迭代器保持不变，这是一个令人愉快的特性，允许我们对函数进行非常灵活的组合。我们可以消耗这两个克隆来从可迭代对象中获得`maxima`和`minima`。

虽然吸引人，但我们会发现这在长期内并不奏效。一旦被消耗，可迭代对象将不再提供任何值。当我们想要计算多种类型的缩减，例如`sums`、`counts`、`minimums`、`maximums`时，我们需要考虑这种一次性限制。

## 组合生成器表达式

函数式编程的本质来自于我们如何轻松地组合生成器表达式和生成器函数来创建非常复杂的复合处理序列。在使用生成器表达式时，我们可以以几种方式组合生成器。

组合生成器函数的一种常见方式是当我们创建一个复合函数时。我们可能有一个计算`(f(x) for x in range())`的生成器。如果我们想计算`g(f(x))`，我们有几种方法来组合两个生成器。

我们可以调整原始的生成器表达式如下：

```py
g_f_x = (g(f(x)) for x in range())

```

虽然在技术上是正确的，但这破坏了任何重用的想法。我们不是重用一个表达式，而是重写它。

我们还可以在另一个表达式中替换一个表达式，如下所示：

```py
g_f_x = (g(y) for y in (f(x) for x in range()))

```

这有一个优点，允许我们使用简单的替换。我们可以稍微修改这个以强调重用，使用以下命令：

```py
f_x= (f(x) for x in range())
g_f_x= (g(y) for y in f_x)

```

这有一个优点，它保留了初始表达式`(f(x) for x in range())`，基本上没有改变。我们所做的只是将表达式分配给一个变量。

生成的复合函数也是一个生成器表达式，也是懒惰的。这意味着从`g_f_x`中提取下一个值将从`f_x`中提取一个值，这将从源`range()`函数中提取一个值。

# 使用生成器函数清理原始数据

探索性数据分析中出现的任务之一是清理原始数据源。这通常作为一个复合操作，对每个输入数据应用多个标量函数来创建一个可用的数据集。

让我们看一个简化的数据集。这个数据通常用来展示探索性数据分析技术。它被称为**Anscombe's Quartet**，来源于 F. J. Anscombe 在 1973 年发表在*American Statistician*上的文章**Graphs in Statistical Analysis**。以下是一个下载文件中这个数据集的前几行：

```py
Anscombe's quartet
I  II  III  IV
x  y  x  y  x  y  x  y
10.0  8.04  10.0  9.14	  10.0  7.46  8.0  6.58
8.0	6.95  8.0  8.14  8.0  6.77  8.0  5.76
13.0  7.58  13.0  8.74  13.0  12.74  8.0  7.71
```

遗憾的是，我们不能简单地使用`csv`模块处理这个问题。我们必须对文件进行一些解析，以提取出文件中的有用信息。由于数据是正确的制表符分隔的，我们可以使用`csv.reader()`函数来遍历各行。我们可以定义一个数据迭代器如下：

```py
import csv
def row_iter(source):
 **return csv.reader(source, delimiter="\t")

```

我们只是将一个文件包装在`csv.reader`函数中，以创建一个行的迭代器。我们可以在以下上下文中使用这个迭代器：

```py
with open("Anscombe.txt") as source:
 **print( list(row_iter(source)) )

```

问题在于结果可迭代对象中的前三个项目不是数据。当打开 Anacombe's quartet 文件时，它看起来是这样的：

```py
[["Anscombe's quartet"], ['I', 'II', 'III', 'IV'], ['x', 'y', 'x', 'y', 'x', 'y', 'x', 'y'],** 

```

我们需要从可迭代对象中过滤这些行。下面是一个可以整洁地切除三个预期标题行，并返回剩余行的迭代器的函数：

```py
def head_split_fixed(row_iter):
 **title= next(row_iter)
 **assert len(title) == 1 and title[0] == "Anscombe's quartet"
 **heading= next(row_iter)
 **assert len(heading) == 4 and heading == ['I', 'II', 'III', 'IV']
 **columns= next(row_iter)
 **assert len(columns) == 8 and columns == ['x', 'y', 'x', 'y', 'x', 'y', 'x', 'y']
 **return row_iter

```

这个函数从可迭代对象中取出三行。它断言每行都有一个预期值。如果文件不符合这些基本期望，那么这表明文件已损坏，或者我们的分析可能集中在错误的文件上。

由于`row_iter()`和`head_split_fixed()`函数都期望一个可迭代对象作为参数值，它们可以如下简单地组合：

```py
with open("Anscombe.txt") as source:
 **print( list(head_split_fixed(row_iter(source))))

```

我们只是将一个迭代器应用到另一个迭代器的结果上。实际上，这定义了一个复合函数。当然，我们还没有完成；我们仍然需要将`strings`值转换为`float`值，而且我们还需要拆分每行中的四个并行数据系列。

最终的转换和数据提取更容易使用高阶函数，比如`map()`和`filter()`。我们将在第五章*高阶函数*中回到这些内容。

# 使用列表、字典和集合。

Python 序列对象，比如`list`，是可迭代的。但它还有一些额外的特性。我们将把它看作是一个实现的可迭代对象。我们在几个例子中使用`tuple()`函数来收集生成器表达式或生成器函数的输出到一个单一的`tuple`对象中。我们也可以实现一个序列来创建一个`list`对象。

在 Python 中，列表显示提供了简单的语法来实现生成器：我们只需添加`[]`括号。这是无处不在的，以至于生成器表达式和列表推导之间的区别在实际上并不重要。

以下是一个枚举案例的例子：

```py
>>> range(10)
range(0, 10)
>>> [range(10)]
[range(0, 10)]
>>> [x for x in range(10)]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> list(range(10))
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

```

第一个例子是一个生成器函数。

### 提示

`range(10)`函数是惰性的；在通过迭代遍历值的上下文中才会产生这 10 个值。

第二个例子展示了由单个生成器函数组成的列表。要评估这个，我们将不得不使用`嵌套`循环。类似这样`[x for gen in [range(10)] for x in gen]`。

第三个例子展示了从包含生成器函数的生成器表达式构建的`list`推导。函数`range(10)`通过生成器表达式`x for x in range(10)`进行评估。结果值被收集到一个`list`对象中。

我们也可以使用`list()`函数从可迭代对象或生成器表达式构建一个列表。这对于`set()`、`tuple()`和`dict()`也适用。

### 提示

`list(range(10))`函数评估了生成器表达式。`[range(10)]`列表文字不评估生成器函数。

虽然有`list`、`dict`和`set`的简写语法，使用**[]**和`{}`，但没有元组的简写语法。为了实现一个元组，我们必须使用`tuple()`函数。因此，使用`list()`、`tuple()`和`set()`函数作为首选语法似乎是最一致的。

在数据清洗示例中，我们使用一个复合函数来创建四个元组的列表。函数如下所示：

```py
with open("Anscombe.txt") as source:
 **data = head_split_fixed(row_iter(source))
 **print(list(data))

```

我们将复合函数的结果分配给一个名为`data`的名称。数据如下所示：

```py
[['10.0', '8.04', '10.0', '9.14', '10.0', '7.46', '8.0', '6.58'],** 
['8.0', '6.95', '8.0', '8.14', '8.0', '6.77', '8.0', '5.76'], ...
['5.0', '5.68', '5.0', '4.74', '5.0', '5.73', '8.0', '6.89']]

```

我们需要做一些更多的处理才能让它有用。首先，我们需要从八个元组中选择一对列。我们可以使用一个函数选择一对列，如下面的命令片段所示：

```py
from collections import namedtuple
Pair = namedtuple("Pair", ("x", "y"))
def series(n, row_iter):
 **for row in row_iter:
 **yield Pair(*row[n*2:n*2+2])

```

这个函数根据 0 到 3 之间的数字选择两个相邻的列。它从这两列创建一个`namedtuple`对象。这使我们可以从每一行中选择*x*或*y*值。

我们现在可以创建一个元组集合，如下所示：

```py
with open("Anscombe.txt") as source:
 **data = tuple(head_split_fixed(row_iter(source)))
 **sample_I= tuple(series(0,data))
 **sample_II= tuple(series(1,data))
 **sample_III= tuple(series(2,data))
 **sample_IV= tuple(series(3,data))

```

我们将`tuple()`函数应用于基于`head_split_fixed()`和`row_iter()`方法的复合函数。这将创建一个对象，我们可以在其他几个函数中重复使用。如果我们不实现一个`tuple`对象，那么只有第一个样本会有任何数据。之后，源迭代器将被耗尽，所有其他尝试访问它都将产生空的序列。

`series()`函数将选择一对项目来创建`Pair`对象。同样，我们对结果的元组-命名元组序列应用了一个整体的`tuple()`函数，以便我们可以对每个序列进行进一步处理。

`sample_I`序列看起来像下面的命令片段：

```py
(Pair(x='10.0', y='8.04'), Pair(x='8.0', y='6.95'),** 
Pair(x='13.0', y='7.58'), Pair(x='9.0', y='8.81'),** 
Etc.** 
Pair(x='5.0', y='5.68'))

```

其他三个序列的结构类似。然而，值是非常不同的。

我们需要做的最后一件事是从我们积累的字符串中创建适当的数值，以便我们可以计算一些统计摘要值。我们可以将`float()`函数转换应用为最后一步。有许多替代的地方可以应用`float()`函数，我们将在第五章*高阶函数*中看一些选择。

下面是一个描述`float()`函数用法的例子：

```py
 **mean = sum(float(pair.y) for pair in sample_I)/len(sample_I)

```

这将提供`Pair`对象中`y`值的平均值。我们可以按如下方式收集一些统计信息：

```py
for subset in sample_I, sample_II, sample_III, sample_III:
 **mean = sum(float(pair.y) for pair in subset)/len(subset)
 **print(mean)

```

我们计算了从源数据库构建的每个`pair`中`y`值的平均值。我们创建了一个通用的元组-命名元组结构，这样我们就可以清晰地引用源数据集的成员。使用`pair.y`比`pair[1]`更清晰一些。

为了减少内存使用并提高性能，我们尽可能使用生成器表达式和函数。这些以一种惰性（或非严格）的方式迭代集合，只在需要时计算值。由于迭代器只能使用一次，有时我们被迫将一个集合实现为`tuple`（或`list`）对象。实现一个集合会消耗内存和时间，所以我们不情愿地这样做。

熟悉**Clojure**的程序员可以使用`lazy-seq`和`lazy-cat`函数与 Python 的惰性生成器相匹配。这个想法是我们可以指定一个潜在的无限序列，但只在需要时从中取值。

## 使用有状态的映射

Python 提供了几种有状态的集合；各种映射包括 dict 类和`collections`模块中定义的许多相关映射。我们需要强调这些映射的有状态性质，并谨慎使用它们。

对于我们在学习 Python 中的函数式编程技术的目的，`mapping`有两种用例：累积映射的有状态字典和冻结字典。在本章的第一个例子中，我们展示了一个被`ElementTree.findall()`方法使用的冻结字典。Python 没有提供一个易于使用的不可变映射的定义。`collections.abc.Mapping`抽象类是不可变的，但它不是我们可以轻易使用的东西。我们将在第六章中深入了解细节，*递归和归约*。

而不是使用`collections.abc.Mapping`抽象类的形式，我们可以确认变量`ns_map`在赋值语句的左侧只出现一次，方法如`ns_map.update()`或`ns_map.pop()`从未被使用，`del`语句也没有与映射项一起使用。

有状态的字典可以进一步分解为两种典型的用例；它们如下：

+   一个字典只建立一次，从不更新。在这种情况下，我们将利用`dict`类的哈希键特性来优化性能。我们可以通过`dict(sequence)`从任何可迭代的(key, value)两元组序列创建字典。

+   一个逐步构建的字典。这是一个我们可以使用的优化，可以避免实现和排序列表对象。我们将在第六章中看到这一点，*递归和归约*。我们将把`collections.Counter`类作为一个复杂的归约。逐步构建对于记忆化特别有帮助。我们将把记忆化推迟到第十六章中，*优化和改进*。

第一个例子，只建立一次字典，源自一个具有三个操作阶段的应用程序：收集一些输入，创建一个`dict`对象，然后根据字典中的映射处理输入。作为这种应用程序的一个例子，我们可能正在进行一些图像处理，并且有一个特定的调色板，由名称和(R, G, B)元组表示。如果我们使用**GNU 图像处理程序**（**GIMP**）**GNU 通用公共许可证**（**GPL**）文件格式，颜色调色板可能看起来像以下命令片段：

```py
 **GIMP Palette
 **Name: Small
 **Columns: 3
 **#
 **0  0  0    Black
 **255 255 255    White
 **238  32  77    Red
 **28 172 120      Green
 **31 117 254      Blue

```

解析这个文件的细节是第六章的主题，*递归和归约*。重要的是解析的结果。

首先，我们假设我们正在使用以下的`Color`命名元组：

```py
from collections import namedtuple
Color = namedtuple("Color", ("red", "green", "blue", "name"))

```

其次，我们假设有一个产生`Color`对象可迭代的解析器。如果我们将其实现为一个元组，它看起来会像这样：

```py
(Color(red=239, green=222, blue=205, name='Almond'), Color(red=205, green=149, blue=117, name='Antique Brass'), Color(red=253, green=217, blue=181, name='Apricot'), Color(red=197, green=227, blue=132, name='Yellow Green'), Color(red=255, green=174, blue=66, name='Yellow Orange'))

```

为了快速定位给定的颜色名称，我们将从这个序列创建一个冻结字典。这不是获取颜色名称快速查找的唯一方法。我们稍后会看另一个选项。

为了从元组创建映射，我们将使用`process(wrap(iterable))`设计模式。以下命令显示了我们如何创建颜色名称映射：

```py
name_map= dict( (c.name, c) for c in sequence )

```

其中，序列变量是先前显示的`Color`对象的可迭代对象，设计模式的`wrap()`元素简单地将每个`Color`对象`c`转换成两元组`(c.name, c)`。设计的`process()`元素使用`dict()`初始化来创建从名称到`Color`的映射。结果字典如下所示：

```py
{'Caribbean Green': Color(red=28, green=211, blue=162, name='Caribbean Green'),'Peach': Color(red=255, green=207, blue=171, name='Peach'), 'Blizzard Blue': Color(red=172, green=229, blue=238, name='Blizzard Blue'),

```

顺序不能保证，所以你可能看不到加勒比绿色排在第一位。

现在我们已经实现了映射，我们可以在以后的一些处理中使用这个`dict()`对象，用于从颜色名称到(R, G, B)颜色数字的重复转换。查找将非常快，因为字典会快速将键转换为哈希值，然后在字典中查找。

## 使用 bisect 模块创建映射

在前面的例子中，我们创建了一个`dict`映射，以实现从颜色名称到`Color`对象的快速映射。这不是唯一的选择；我们可以使用`bisect`模块。使用`bisect`模块意味着我们必须创建一个排序对象，然后进行搜索。为了与`dict`映射完全兼容，我们可以使用`collections.abc.Mapping`作为基类。

`dict`映射使用哈希来几乎立即定位项。然而，这需要分配一个相当大的内存块。`bisect`映射进行搜索，不需要那么多的内存，但性能可以描述为立即。

`static`映射类看起来像以下命令片段：

```py
import bisect
from collections.abc import Mapping
class StaticMapping(Mapping):
 **def __init__( self, iterable ):
 **self._data = tuple(iterable)
 **self._keys = tuple(sorted(key for key, _ in self._data))

 **def __getitem__(self, key):
 **ix= bisect.bisect_left(self._keys, key)
 **if ix != len(self._keys) and self._keys[ix] == key:
 **return self._data[ix][1]
 **raise ValueError("{0!r} not found".format(key))
 **def __iter__(self):
 **return iter(self._keys)
 **def __len__(self):
 **return len(self._keys)

```

这个类扩展了抽象超类`collections.abc.Mapping`。它提供了三个函数的初始化和实现，这些函数在抽象定义中缺失。`__getitem__()`方法使用`bisect.bisect_left()`函数来搜索键的集合。如果找到键，则返回相应的值。`__iter__()`方法返回一个迭代器，如超类所需。`__len__()`方法同样提供了集合的所需长度。

另一个选择是从`collections.OrderedDict`类的源代码开始，将超类更改为`Mapping`而不是`MutableMapping`，并删除所有实现可变性的方法。有关要保留哪些方法和要丢弃哪些方法的更多详细信息，请参阅*Python 标准库*第 8.4.1 节。

访问以下链接以获取更多详细信息：

[`docs.python.org/3.3/library/collections.abc.html#collections-abstract-base-classes`](https://docs.python.org/3.3/library/collections.abc.html#collections-abstract-base-classes)

这个类似乎并不体现太多的函数式编程原则。我们的目标是支持一个最小化使用有状态变量的更大的应用程序。这个类保存了一组静态的键值对。作为一种优化，它实现了两个对象。

创建此类的实例的应用程序正在使用一个实例化对象来执行对键的快速查找。超类不支持对对象的更新。整个集合是无状态的。它不像内置的`dict`类那样快，但它使用的内存更少，并且通过作为`Mapping`子类的形式，我们可以确保该对象不用于包含处理状态。

## 使用有状态集合

Python 提供了几种有状态的集合，包括 set 集合。对于我们的目的，集合有两种用途：一个是累积项的有状态集合，另一个是用于优化搜索项的 frozenset。

我们可以像创建`tuple`对象一样从可迭代对象中创建 frozenset，`fronzenset(some_iterable)`方法；这将创建一个具有非常快速的`in`运算符的结构。这可以用于收集数据、创建集合，然后使用那个 frozenset 来处理其他数据项的应用程序。

我们可能有一组颜色，我们将使用作为一种**色度**-**键**：我们将使用这种颜色创建一个蒙版，该蒙版将用于组合两个图像。从实用的角度来看，单一颜色并不合适，但一小组非常相似的颜色效果最佳。在这种情况下，我们将检查图像文件的每个像素，以查看像素是否在色度键集中。对于这种处理，色度键颜色在处理目标图像之前加载到 frozenset 中。有关色度键处理的更多信息，请阅读以下链接：

[`en.wikipedia.org/wiki/Chroma_key`](http://en.wikipedia.org/wiki/Chroma_key)

与映射一样 - 具体来说是`Counter`类 - 有一些算法可以从一个记忆化的值集中受益。一些函数受益于记忆化，因为函数是域值和值域之间的映射，这是映射很好的工作。一些算法受益于一个有记忆的集合，它是有状态的，并且随着数据的处理而增长。

我们将在第十六章*优化和改进*中回顾记忆化。

# 总结

在本章中，我们仔细研究了编写纯函数：没有副作用。这里的标准很低，因为 Python 强制我们使用`global`语句来编写不纯的函数。我们研究了生成器函数以及我们如何将其用作函数式编程的支柱。

我们还研究了内置的集合类，以展示它们在函数范式中的使用方式。虽然函数式编程背后的一般理念是限制使用有状态的变量，但集合对象通常是有状态的，并且对于许多算法也是必不可少的。我们的目标是在使用 Python 的非函数式特性时要谨慎。

在接下来的两章中，我们将研究高阶函数：接受函数作为参数并返回函数的函数。我们将从探索内置的高阶函数开始。在后面的章节中，我们将研究定义自己的高阶函数的技术。我们还将在后面的章节中研究`itertools`和`functools`模块及其高阶函数。


# 第四章：处理集合

Python 提供了许多处理整个集合的函数。它们可以应用于序列（列表或元组）、集合、映射和生成器表达式的可迭代结果。我们将从函数式编程的角度看一些 Python 的集合处理函数。

我们将首先看一下可迭代对象和一些与可迭代对象一起工作的简单函数。我们将看一些额外的设计模式来处理可迭代对象和递归序列，以及显式的`for`循环。我们将看一下如何使用生成器表达式将`scalar()`函数应用于数据集合。

在本章中，我们将展示如何使用以下函数来处理集合的示例：

+   `any()`和`all()`

+   `len()`和`sum()`以及与这些函数相关的一些高阶统计处理

+   `zip()`和一些相关的技术来构造和展平数据列表

+   `reversed()`

+   `enumerate()`

前四个函数都可以称为缩减函数；它们将集合减少为单个值。另外三个函数（`zip()`、`reversed()`和`enumerate()`）是映射函数；它们从现有集合中产生一个新的集合。在下一章中，我们将看一些使用额外函数作为参数来定制其处理的`mapping()`和`reduction()`函数。

在本章中，我们将首先看一下使用生成器表达式处理数据的方法。然后，我们将应用不同类型的集合级函数，以展示它们如何简化迭代处理的语法。我们还将看一些不同的数据重构方式。

在下一章中，我们将专注于使用高阶集合函数来进行类似的处理。

# 函数种类概述

我们需要区分以下两种广义函数：

+   标量函数适用于单个值，并计算单个结果。`abs()`、`pow()`和整个`math`模块都是标量函数的例子。

+   `Collection()`函数与可迭代集合一起工作。

我们可以进一步将集合函数细分为三个亚种：

+   **缩减**：这使用一个函数来将集合中的值合并在一起，产生一个最终的单一值。我们可以称之为聚合函数，因为它为输入集合产生一个单一的聚合值。

+   **映射**：这将一个函数应用于集合的所有项目；结果是相同大小的集合。

+   **过滤器**：这将一个函数应用于集合的所有项目，拒绝一些项目并通过其他项目。结果是输入的子集。过滤器可能什么也不做，这意味着输出与输入匹配；这是一个不恰当的子集，但它仍然符合子集的更广泛定义。

我们将使用这个概念框架来描述我们使用内置集合函数的方式。

# 使用可迭代对象

正如我们在前几章中所指出的，我们经常使用 Python 的`for`循环来处理集合。当处理元素化的集合（如元组、列表、映射和集合）时，`for`循环涉及对状态的显式管理。虽然这偏离了纯函数式编程，但它反映了 Python 的必要优化。如果我们确保状态管理局限于作为`for`语句评估的一部分创建的迭代器对象，我们就可以利用这个特性，而不会偏离纯粹的函数式编程太远。例如，如果我们在缩进的`loop`体之外使用`for`循环变量，我们就偏离了纯粹的函数式编程。

我们将在第六章*递归和缩减*中回顾这一点。这是一个重要的话题，我们在这里只是简单地用一个快速的例子来介绍与生成器一起工作。

`for`循环可迭代处理的一个常见应用是`unwrap(process(wrap(iterable)))`设计模式。`wrap()`函数首先将可迭代对象的每个项转换为一个带有派生排序键或其他值的两个元组，然后是原始的不可变项。然后我们可以根据包装值处理这两个元组。最后，我们将使用`unwrap()`函数丢弃用于包装的值，恢复原始项。

这在功能上经常发生，我们有两个函数经常用于此目的; 它们如下：

```py
fst = lambda x: x[0]
snd = lambda x: x[1]
```

这两个函数从元组中选择第一个和第二个值，对于`process()`和`unwrap()`函数都很方便。

另一个常见的模式是`wrap(wrap(wrap()))`。在这种情况下，我们从简单的元组开始，然后用额外的结果包装它们，以构建更大更复杂的元组。这个主题的一个常见变体是`extend(extend(extend()))`，其中额外的值构建新的更复杂的`namedtuple`实例，而不实际包装原始元组。我们可以将这两者总结为 Accretion 设计模式。

我们将应用 Accretion 设计来处理一系列简单的纬度和经度值。第一步将简单的路径上的点(`lat`, `lon`)转换为腿(`begin`, `end`)的对。结果中的每对将是((`lat`, `lon`), (`lat`, `lon`))。

在接下来的几节中，我们将展示如何创建一个生成器函数，它将迭代文件的内容。这个可迭代对象将包含我们将处理的原始输入数据。

一旦我们有了数据，后面的部分将展示如何在每条路径上装饰**haversine**距离。`wrap(wrap(iterable())))`处理的最终结果将是三个元组的序列：((`lat`, `lon`), (`lat`, `lon`), `distance`)。然后我们可以分析结果，找出最长、最短的距离，边界矩形和其他数据的摘要。

## 解析 XML 文件

我们将从解析一个**XML**（**可扩展** **标记** **语言**的缩写）文件开始，以获取原始的纬度和经度对。这将展示我们如何封装 Python 的一些不太功能性的特性，以创建一个可迭代的值序列。我们将使用`xml.etree`模块。解析后，生成的`ElementTree`对象有一个`findall()`方法，可以遍历可用的值。

我们将寻找以下代码片段这样的结构：

```py
<Placemark><Point>
<coordinates>-76.33029518659048,37.54901619777347,0</coordinates>
</Point></Placemark>
```

文件将有许多`<Placemark>`标签，每个标签中都有一个点和坐标结构。这是包含地理信息的**Keyhole Markup Language** (**KML**)文件的典型情况。

解析 XML 文件可以在两个抽象级别上进行。在较低级别，我们需要定位 XML 文件中的各种标签、属性值和内容。在较高级别，我们希望将文本和属性值转换为有用的对象。

较低级别的处理可以通过以下方式进行：

```py
import xml.etree.ElementTree as XML
def row_iter_kml(file_obj):
 **ns_map= {
 **"ns0": "http://www.opengis.net/kml/2.2",
 **"ns1": "http://www.google.com/kml/ext/2.2"}
 **doc= XML.parse(file_obj)
 **return (comma_split(coordinates.text)
 **for coordinates in doc.findall("./ns0:Document/ns0:Folder/ns0:Placemark/ns0:Point/ns0:coordinates", ns_map))

```

这个函数需要一个已经打开的文件，通常是通过`with`语句打开的。但它也可以是 XML 解析器可以处理的任何文件类对象。该函数包括一个简单的静态`dict`对象`ns_map`，为我们将要搜索的 XML 标签提供`namespace`映射信息。这个字典将被`XML` `ElementTree.findall()`方法使用。

解析的本质是一个生成器函数，它使用`doc.findall()`定位的标签序列。然后，这些标签序列由`comma_split()`函数处理，将文本值分解为逗号分隔的组件。

`comma_split()`函数是字符串`split()`方法的功能版本，如下所示：

```py
def comma_split(text):
 **return text.split(",")

```

我们使用功能包装器来强调略微更统一的语法。

这个函数的结果是一个可迭代的数据行序列。每一行将是一个由三个字符串组成的元组：`纬度`、`经度`和路径上一个航路点的`高度`。这还不直接有用。我们需要做一些额外的处理，以获得`纬度`和`经度`，并将这两个数字转换为有用的浮点值。

将较低级别解析的结果作为元组的可迭代序列的想法，使我们能够以一种简单和统一的方式处理某些类型的数据文件。在第三章中，*函数、迭代器和生成器*，我们看到**逗号** **分隔** **值**（**CSV**）文件可以很容易地处理为元组的行。在第六章中，*递归和归约*，我们将重新讨论解析的想法，以比较这些各种例子。

前一个函数的输出看起来像以下的代码片段：

```py
[['-76.33029518659048', '37.54901619777347', '0'], ['-76.27383399999999', '37.840832', '0'], ['-76.459503', '38.331501', '0'], and so on ['-76.47350299999999', '38.976334', '0']]

```

每一行都是使用`,`分割的`<ns0:coordinates>`标签的源文本内容。这些值是东西经度、南北纬度和高度。我们将对这个函数的输出应用一些额外的函数，以创建一个可用的数据集。

## 在更高级别解析文件

一旦我们解析了低级语法，我们可以将原始数据重构为我们的 Python 程序中可用的形式。这种结构适用于 XML、**JavaScript 对象表示**（**JSON**）、CSV 以及数据序列化的各种物理格式。

我们将致力于编写一套小的生成器函数，将解析后的数据转换为我们的应用程序可以使用的形式。生成器函数包括对`row_iter_kml()`函数找到的文本进行一些简单的转换，如下所示：

+   丢弃`高度`，或者可能只保留`纬度`和`经度`

+   将顺序从（`经度`，`纬度`）更改为（`纬度`，`经度`）

我们可以通过定义一个实用函数来使这两种转换具有更多的语法统一性，如下所示：

```py
def pick_lat_lon(lon, lat, alt):
 **return lat, lon

```

我们可以按照以下方式使用这个函数：

```py
def lat_lon_kml(row_iter):
 **return (pick_lat_lon(*row) for row in row_iter)

```

这个函数将对每一行应用`pick_lat_lon()`函数。我们使用`*row`将每个行的三元组的每个元素分配给`pick_lat_lon()`函数的单独参数。然后函数可以从每个三元组中提取和重新排序两个相关值。

重要的是要注意，一个良好的函数式设计允许我们自由地用其等效物替换任何函数，这使得重构非常简单。当我们提供各种函数的替代实现时，我们试图实现这个目标。原则上，一个聪明的函数式语言编译器可能会在优化过程中进行一些替换。

我们将使用以下类型的处理来解析文件并构建一个我们可以使用的结构，例如以下代码片段：

```py
with urllib.request.urlopen("file:./Winter%202012-2013.kml") as source:
 **v1= tuple(lat_lon_kml(row_iter_kml(source)))
print(v1)

```

我们使用`urllib`命令打开一个源。在这种情况下，它是一个本地文件。然而，我们也可以打开一个远程服务器上的 KML 文件。我们使用这种文件打开的目的是确保我们的处理无论数据的来源如何都是统一的。

我们展示了两个执行 KML 源的低级解析的函数。`row_iter_kml(source)`表达式产生一个文本列的序列。`lat_lon_kml()`函数将提取和重新排序`纬度`和`经度`的值。这创建了一个中间结果，为进一步处理奠定了基础。随后的处理与原始格式无关。

当我们运行这个函数时，我们会看到以下结果：

```py
(('37.54901619777347', '-76.33029518659048'), ('37.840832', '-76.27383399999999'), ('38.331501', '-76.459503'), ('38.330166', '-76.458504'), ('38.976334', '-76.47350299999999'))

```

我们已经从一个复杂的 XML 文件中提取了`纬度`和`经度`的值，使用了几乎纯函数式的方法。由于结果是可迭代的，我们可以继续使用函数式编程技术来处理从文件中检索到的每个点。

我们明确地将低级别的 XML 解析与数据的高级重组分开。XML 解析产生了一个通用的字符串结构元组。这与 CSV 解析器的输出兼容。在处理**SQL**数据库时，我们将有一个类似的元组结构的可迭代对象。这使我们能够编写用于处理来自各种来源的数据的高级处理代码。

我们将展示一系列转换，将这些数据从字符串集合重新排列为路径上的路标集合。这将涉及许多转换。我们需要重组数据，以及从`字符串`转换为`浮点`值。我们还将研究一些简化和澄清后续处理步骤的方法。我们将在后面的章节中使用这个数据集，因为它相当复杂。

## 从序列中配对项目

一个常见的重组要求是将序列中的点制作成起始-停止对。给定一个序列，![从序列中配对项目](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_01.jpg)，我们想要创建一个配对的序列![从序列中配对项目](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_02.jpg)。在进行时间序列分析时，我们可能会组合更广泛分开的值。在这个例子中，是相邻的值。

配对的序列将允许我们使用每对来计算点与点之间的距离，使用`haversine`函数的一个简单应用。这种技术也用于将点的路径转换为图形应用程序中的一系列线段。

为什么要配对项目？为什么不像这样做？

```py
begin= next(iterable)
for end in iterable:
 **compute_something(begin, end)
 **begin = end

```

这显然会将数据的每个部分处理为一个起始-结束对。然而，处理函数和重组数据的循环是紧密绑定的，使得重用比必要复杂。配对算法很难在隔离中进行测试，因为它与`compute_something()`函数绑定在一起。

这个组合函数也限制了我们重新配置应用程序的能力。没有简单的方法来注入`compute_something()`函数的替代实现。此外，我们有一个显式状态，即`begin`变量，这可能使生活变得复杂。如果我们试图在`loop`的主体中添加功能，如果一个点被从考虑中删除，我们很容易无法正确设置`begin`变量。`filter()`函数引入了一个`if`语句，可能导致在更新`begin`变量时出错。

通过分离这个简单的配对函数，我们实现了更好的重用。这在长远来看是我们的一个目标。如果我们建立一个有用的原语库，比如这个配对函数，我们就可以更快更自信地解决问题。

有许多方法可以将路径上的点配对，以为每条路径创建起始和停止信息。我们将在这里看一些方法，然后在第五章*高阶函数*中重新讨论这个问题，再次在第八章*Itertools 模块*中重新讨论。

可以使用递归以纯函数方式创建配对。以下是一个配对路径上点的函数的一个版本：

```py
def pairs(iterable):
 **def pair_from( head, iterable_tail ):
 **nxt= next(iterable_tail)
 **yield head, nxt
 **yield from pair_from( nxt, iterable_tail )
 **try:
 **return pair_from( next(iterable), iterable )
 **except StopIteration:
 **return

```

基本函数是内部的`pair_from()`函数。它使用可迭代对象头部的项目加上可迭代对象本身。它产生第一对，从可迭代对象中弹出下一个项目，然后递归调用自身以产生任何额外的对。

我们从`pairs()`函数中调用了这个函数。`pairs()`函数确保初始化被正确处理，并且终止异常被正确地消除。

### 注意

Python 可迭代递归涉及使用`for`循环来正确消耗并产生递归的结果。如果我们尝试使用一个看起来更简单的`return pair_from(nxt, iterable_tail)`方法，我们会发现它并没有正确消耗可迭代对象并产生所有的值。

生成器函数中的递归需要`yield` from 语句来消耗生成的可迭代对象。为此，使用`yield from recursive_iter(args)`。

类似`return recursive_iter(args)`的语句将只返回一个生成器对象；它不会评估函数以返回生成的值。

我们进行尾递归优化的策略是用生成器表达式替换递归。我们可以将这种递归明显优化为简单的`for`循环。以下是另一个配对路线上点的函数的版本：

```py
def legs(lat_lon_iter):
 **begin= next(lat_lon_iter)
 **for end in lat_lon_iter:
 **yield begin, end
 **begin= end

```

这个版本非常快速，没有堆栈限制。它不依赖于任何特定类型的序列，因为它将任何序列生成器发出的任何东西配对。由于循环内没有处理函数，我们可以根据需要重用`legs()`函数。

我们可以将这个函数看作是产生以下类型的配对序列：

```py
list[0:1], list[1:2], list[2:3], ..., list[-2:]

```

这个函数的另一个视图如下：

```py
zip(list, list[1:])

```

虽然信息丰富，但这另外两种表述只适用于序列对象。`legs()`和`pairs()`函数适用于任何可迭代对象，包括序列对象。

## 使用 iter()函数显式地

纯粹的功能观点是，我们所有的可迭代对象都可以用递归函数处理，其中状态仅仅是递归调用堆栈。从实用的角度来看，Python 可迭代对象通常涉及其他`for`循环的评估。有两种常见情况：集合和可迭代对象。在处理集合时，`for`语句会创建一个迭代器对象。在处理生成器函数时，生成器函数是迭代器，并维护其自己的内部状态。从 Python 编程的角度来看，这些通常是等效的。在极少数情况下，通常是那些必须使用显式的`next()`函数的情况下，这两者不会完全等效。

我们之前展示的`legs()`函数有一个显式的`next()`函数调用，以从可迭代对象中获取第一个值。这在生成器函数、表达式和其他可迭代对象中非常有效。但在元组或`lists`等序列对象中却不起作用。

以下是三个例子，以阐明`next()`和`iter()`函数的用法：

```py
>>> list(legs(x for x in range(3)))
[(0, 1), (1, 2)]
>>> list(legs([0,1,2]))
Traceback (most recent call last):
 **File "<stdin>", line 1, in <module>
 **File "<stdin>", line 2, in legs
TypeError: 'list' object is not an iterator
>>> list(legs( iter([0,1,2])))
[(0, 1), (1, 2)]

```

在第一种情况下，我们将`legs()`函数应用于一个可迭代对象。在这种情况下，可迭代对象是一个生成器表达式。根据本章中之前的例子，这是预期的行为。项目被正确地配对，以从三个航点中创建两条腿。

在第二种情况下，我们尝试将`legs()`函数应用于一个序列。这导致了一个错误。虽然`list`对象和可迭代对象在`for`语句中使用时是等效的，但它们在其他地方并不等效。序列不是迭代器；它不实现`next()`函数。然而，`for`语句通过自动从序列创建迭代器来优雅地处理这个问题。

为了使第二种情况起作用，我们需要显式地从`list`对象创建一个迭代器。这允许`legs()`函数从`list`项的迭代器中获取第一个项目。

## 扩展简单循环

我们有两种扩展可以因素成一个简单的循环。我们首先看一下`filter`扩展。在这种情况下，我们可能会拒绝进一步考虑的值。它们可能是数据异常值，或者可能是格式不正确的源数据。然后，我们将通过执行简单的转换来映射源数据，从原始对象创建新对象。在我们的情况下，我们将把`strings`转换为`floating-point`数字。然而，将简单的`loop`与映射扩展的想法适用于各种情况。我们将重新设计上面的`pairs()`函数。如果我们需要调整点的序列以丢弃一个值，会引入一个`filter`扩展来拒绝一些数据值。

由于我们设计的循环只是返回一对，而没有执行任何额外的应用相关处理，所以复杂性是最小的。简单意味着我们更不太可能混淆处理状态。

在这个设计中添加一个`filter`扩展可能看起来像以下代码片段：

```py
def legs_filter(lat_lon_iter):
 **begin= next(lat_lon_iter)
 **for end in lat_lon_iter:
 **if #some rule for rejecting:
 **continue
 **yield begin, end
 **begin= end

```

我们已经插入了一个处理规则来拒绝某些值。由于`loop`保持简洁和表达力十足，我们有信心处理将会被正确完成。此外，我们可以很容易地为这个函数编写一个测试，因为结果适用于任何可迭代对象，而不管这些对象的长期目的地是什么。

下一次重构将向循环引入额外的映射。当设计正在演变时，添加映射是很常见的。在我们的情况下，我们有一系列`string`值。我们需要将它们转换为以后使用的`floating-point`值。这是一个相对简单的映射，展示了设计模式。

以下是通过包装一个生成器函数的生成器表达式来处理这些数据映射的一种方法：

```py
print(tuple(legs((float(lat), float(lon)) for lat,lon in lat_lon_kml())))

```

我们将`legs()`函数应用于一个生成器表达式，该表达式从`lat_lon_kml()`函数的输出中创建`float`值。我们也可以以相反的顺序阅读。`lat_lon_kml()`函数的输出被转换为一对`float`值，然后转换为一系列`legs`。

这开始变得复杂了。我们这里有大量嵌套的函数。我们将`float()`、`legs()`和`tuple()`应用于数据生成器。复杂表达式的一个常见重构是将生成器表达式与任何实现的集合分开。我们可以做以下工作来简化表达式：

```py
flt= ((float(lat), float(lon)) for lat,lon in lat_lon_kml())
print(tuple(legs(flt)))

```

我们将生成函数分配给一个名为`flt`的变量。这个变量不是一个集合对象；我们没有使用`list`推导来创建一个对象。我们只是将生成器表达式分配给一个变量名。然后我们在另一个表达式中使用了`flt`变量。

`tuple()`方法的评估实际上导致了一个适当的对象被构建，以便我们可以打印输出。`flt`变量的对象只在需要时被创建。

我们可能还想做其他的重构。一般来说，数据的来源是我们经常想要更改的。在我们的例子中，`lat_lon_kml()`函数与表达式的其余部分紧密绑定。当我们有不同的数据源时，这使得重用变得困难。

在`float()`操作是我们想要参数化以便重用的情况下，我们可以定义一个围绕生成器表达式的函数。我们将一些处理提取到一个单独的函数中，仅仅是为了将操作分组。在我们的情况下，字符串对到浮点对是特定于特定源数据的。我们可以将复杂的从字符串到浮点数的表达式重写为一个更简单的函数，如下所示：

```py
def float_from_pair( lat_lon_iter ):
 **return ((float(lat), float(lon)) for lat,lon in lat_lon_iter)

```

`float_from_pair()`函数将`float()`函数应用于可迭代项中的第一个和第二个值，产生从输入值创建的两个浮点数元组。我们依赖于 Python 的`for`语句来分解这两个元组。

我们可以在以下上下文中使用这个函数：

```py
legs( float_from_pair(lat_lon_kml()))

```

我们将创建从 KML 文件中获取的`float`值构建的`legs`。很容易将处理可视化，因为过程中的每个阶段都是一个简单的前缀函数。

在解析时，我们经常有一系列`string`值。对于数值应用，我们需要将`strings`转换为`float`、`int`或`Decimal`值。这通常涉及将一个函数插入到一系列清理源数据的表达式中，比如`float_from_pair()`函数。

我们先前的输出都是字符串；看起来像以下代码片段：

```py
(('37.54901619777347', '-76.33029518659048'), ('37.840832', '-76.27383399999999'), ... ('38.976334', '-76.47350299999999'))

```

我们希望数据像以下代码片段一样，其中包含浮点数：

```py
(((37.54901619777347, -76.33029518659048), (37.840832, -76.273834)), ((37.840832, -76.273834), … ((38.330166, -76.458504), (38.976334, -76.473503)))

```

我们需要创建一个更简单的转换函数的管道。上面，我们得到了`flt= ((float(lat), float(lon)) for lat,lon in lat_lon_kml())`。我们可以利用函数的替换规则，用一个具有相同值的函数替换一个复杂的表达式，比如`(float(lat), float(lon)) for lat,lon in lat_lon_kml())`，在这种情况下，是`float_from_pair(lat_lon_kml())`。这种重构允许我们确保简化具有与更复杂表达式相同的效果。

我们将在第五章*高阶函数*中查看一些简化。我们将在第六章*递归和缩减*中重新讨论这个问题，看看如何将这些简化应用到文件解析问题上。

## 将生成器表达式应用于标量函数

我们将看到一种更复杂的生成器表达式，将数据值从一种数据映射到另一种数据。在这种情况下，我们将对生成器创建的单个数据值应用一个相当复杂的函数。

我们将这些非生成器函数称为*标量*，因为它们处理简单的`标量`值。要处理数据集，标量函数将嵌入到生成器表达式中。

继续之前的示例，我们将提供一个`haversine`函数，然后使用生成器表达式将标量`haversine()`函数应用于我们 KML 文件中的一系列对。

`haversine()`函数如下所示：

```py
from math import radians, sin, cos, sqrt, asin

MI= 3959
NM= 3440
KM= 6371

def haversine( point1, point2, R=NM ):
 **lat_1, lon_1= point1
 **lat_2, lon_2= point2

 **Δ_lat = radians(lat_2 - lat_1)
 **Δ_lon = radians(lon_2 - lon_1)
 **lat_1 = radians(lat_1)
 **lat_2 = radians(lat_2)
 **a = sin(Δ_lat/2)**2 + cos(lat_1)*cos(lat_2)*sin(Δ_lon/2)**2
 **c = 2*asin(sqrt(a))

 **return R * c

```

这是一个相对简单的实现，复制自**World** **Wide** **Web**。

以下是我们如何使用我们的函数集合来检查一些 KML 数据并产生一系列距离的方式：

```py
 **trip= ((start, end, round(haversine(start, end),4))
 **for start,end in legs(float_from_pair(lat_lon_kml())))
 **for start, end, dist in trip:
 **print(start, end, dist)

```

处理的精髓是分配给`trip`变量的生成器表达式。我们已经组装了三个元组，其中包括起点、终点和起点到终点的距离。起点和终点对来自`legs()`函数。`legs()`函数使用从 KML 文件中提取的`纬度-经度`对构建的`浮点`数据。

输出看起来像以下命令片段：

```py
(37.54901619777347, -76.33029518659048) (37.840832, -76.273834) 17.7246
(37.840832, -76.273834) (38.331501, -76.459503) 30.7382
(38.331501, -76.459503) (38.845501, -76.537331) 31.0756
(36.843334, -76.298668) (37.549, -76.331169) 42.3962
(37.549, -76.331169) (38.330166, -76.458504) 47.2866
(38.330166, -76.458504) (38.976334, -76.473503) 38.8019

```

每个单独的处理步骤都被简洁地定义了。同样，概述也可以被表达为函数和生成器表达式的组合。

显然，我们可能希望对这些数据应用几个进一步的处理步骤。首先，当然，是使用字符串的`format()`方法来产生更好看的输出。

更重要的是，我们想要从这些数据中提取一些聚合值。我们将这些值称为可用数据的缩减。我们想要缩减数据以获得最大和最小纬度，例如，以显示这条路线的极端北端和南端。我们想要缩减数据以获得一条腿的最大距离以及所有`legs`的总距离。

我们在使用 Python 时会遇到的问题是，`trip`变量中的输出生成器只能使用一次。我们无法轻松地对这些详细数据进行多次缩减。我们可以使用`itertools.tee()`来多次使用可迭代对象。然而，每次缩减都读取和解析 KML 文件似乎是一种浪费。

我们可以通过实现中间结果来使我们的处理更有效。我们将在下一节中看到这一点。然后，我们可以看看如何计算可用数据的多个缩减。

## 使用 any()和 all()作为缩减

`any()`和`all()`函数提供了`布尔`缩减功能。这两个函数都将一组值缩减为单个`True`或`False`。`all()`函数确保所有值都为`True`。`any()`函数确保至少有一个值为`True`。

这些函数与用于表达数学逻辑的普遍量词和存在量词密切相关。例如，我们可能想要断言给定集合中的所有元素都具有某种属性。其中一种形式可能如下所示：

![使用 any()和 all()作为缩减](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_03.jpg)

我们会读到这样的内容：*对于 SomeSet 中的所有 x，函数*![使用 any()和 all()作为缩减](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_04.jpg) *是真的*。我们在逻辑表达式前面放了一个量词。

在 Python 中，我们稍微改变了项目的顺序，以转录逻辑表达式如下：

```py
all(isprime(x) for x in someset)

```

这将评估每个参数值（`isprime(x)`）并将值集合缩减为单个`True`或`False`。

`any()`函数与存在量词有关。如果我们想要断言集合中没有值是素数，我们可能会有类似以下两个等价表达式之一：

![使用 any()和 all()作为缩减](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_05.jpg)

第一个陈述*SomeSet 中的所有元素都不是素数*。第二个版本断言*SomeSet 中存在一个不是素数的元素*。这两者是等价的——也就是说，*如果不是所有元素都是素数，那么必定存在一个元素不是素数*。

在 Python 中，我们可以交换术语的顺序，并将其转录为以下工作代码：

```py
not all(isprime(x) for x in someset)
any(not isprime(x) for x in someset)

```

由于它们是等价的，有两个原因可以优先选择一个而不是另一个：性能和清晰度。性能几乎相同，所以归结为清晰度。哪一个最清晰地陈述了条件？

`all()`函数可以描述为一组值的`and`缩减。结果类似于在给定值序列之间折叠`and`运算符。类似地，`any()`函数可以描述为`or`缩减。当我们查看第十章中的`reduce()`函数时，我们将回到这种通用缩减。*Functools 模块*。

我们还需要看一下这些函数的退化情况。如果序列有 0 个元素会怎样？`all(())`或`all([])`的值是什么？

如果我们问，“空集中的所有元素都是素数吗？”，那么答案是什么？由于没有元素，这个问题有点难以回答。

如果我们问“空集中的所有元素都是素数，`SomeSet`中的所有元素都是素数吗？”，我们对如何继续进行有一些提示。我们正在执行空集的`and`缩减和`SomeSet`的`and`缩减。

![使用 any()和 all()作为缩减](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_06.jpg)

事实证明`and`运算符可以自由分布。我们可以将其重写为两个集合的并集，然后对其进行素数评估：

![使用 any()和 all()作为缩减](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_07.jpg)

显然，![使用 any()和 all()作为缩减](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_08.jpg)。如果我们联合一个空集，我们会得到原始集合。空集可以称为**联合标识元素**。这类似于 0 是加法标识元素的方式：![使用 any()和 all()作为缩减](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_09.jpg)。

同样，`any(())`必须是`or`标识元素，即`False`。如果我们考虑乘法标识元素 1，其中![使用 any()和 all()作为缩减](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_10.jpg)，那么`all(())`必须是`True`。

我们可以证明 Python 遵循这些规则：

```py
>>> all(())
True
>>> any(())
False

```

Python 为我们提供了一些非常好的工具来执行涉及逻辑的处理。我们有内置的`and`、`or`和`not`运算符。但是，我们还有这些面向集合的`any()`和`all()`函数。

## 使用 len()和 sum()

`len()`和`sum()`函数提供了两个简单的缩减：元素的计数和序列中元素的总和。这两个函数在数学上是相似的，但它们的 Python 实现是非常不同的。

从数学上讲，我们可以观察到这种很酷的平行性。`len()`函数返回集合 X 中每个值的 1 的总和：![使用 len()和 sum()](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_11.jpg)。

`sum()`函数返回集合 X 中每个值的*x*的总和：![使用 len()和 sum()](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_12.jpg)。

`sum()`函数适用于任何可迭代对象。`len()`函数不适用于可迭代对象；它只适用于序列。这些函数的实现中存在的这种小不对称在统计算法的边缘有点尴尬。

对于空序列，这两个函数都返回一个适当的加法恒元素 0。

```py
>>> sum(())
0

```

当其他数值类型被使用时，`sum(())`返回整数 0。整数 0 将被强制转换为可用数据的适当类型。

## 使用求和和计数进行统计

算术均值的定义基于`sum()`和`len()`有一个吸引人的平凡定义，如下所示：

```py
def mean( iterable ):
 **return sum(iterable)/len(iterable)

```

虽然优雅，但实际上这对于可迭代对象并不适用。这个定义只适用于序列。

事实上，我们很难基于可迭代对象执行均值或标准差的简单计算。在 Python 中，我们必须要么实例化一个序列对象，要么使用更复杂的操作。

我们有一个相当优雅的均值和标准差的表达式如下定义：

```py
import math
s0= len(data) # sum(1 for x in data) # x**0
s1= sum(data) # sum(x for x in data) # x**1
s2= sum(x*x for x in data)

mean= s1/s0
stdev= math.sqrt(s2/s0 - (s1/s0)**2)

```

这三个总和`s0`、`s1`和`s2`有一个整洁的平行结构。我们可以很容易地从这两个总和中计算均值。标准差稍微复杂一些，但仍然基于这三个总和。

这种愉快的对称性也适用于更复杂的统计函数，比如相关性甚至最小二乘线性回归。

两组样本之间的相关性矩可以从它们的标准化值中计算。以下是一个计算标准化值的函数：

```py
def z( x, μ_x, σ_x ):
 **return (x-μ_x)/σ_x

```

计算很简单，只需从均值`μ_x`中减去每个样本`x`，然后除以标准差`σ_x`。这给出了一个以 sigma 为单位的值，`σ`。±1σ的值预计大约有三分之二的时间。更大的值应该更少见。±3σ之外的值应该少于 1%的时间发生。

我们可以使用这个标量函数如下：

```py
>>> d = [2, 4, 4, 4, 5, 5, 7, 9]
>>> list(z(x, mean(d), stdev(d)) for x in d)
[-1.5, -0.5, -0.5, -0.5, 0.0, 0.0, 1.0, 2.0]

```

我们已经实例化了一个由变量`d`中的一些原始数据基于标准化分数组成的`list`。我们使用了一个生成器表达式来将标量函数`z()`应用于序列对象。

`mean()`和`stdev()`函数只是基于上面显示的例子：

```py
def mean(x):** 
 **return s1(x)/s0(x)
def stdev(x):
 **return math.sqrt(s2(x)/s0(x) - (s1(x)/s0(x))**2)

```

同样，这三个总和函数是基于上面的例子：

```py
def s0(data):
 **return sum(1 for x in data) # or len(data)
def s1(data):** 
 **return sum(x for x in data) # or sum(data)
def s2(data):** 
 **return sum(x*x for x in data)

```

虽然这非常表达和简洁，但有点令人沮丧，因为我们不能简单地在这里使用可迭代对象。我们正在计算一个均值，这需要对可迭代对象进行求和，再加上一个计数。我们还在计算一个需要从可迭代对象中进行两次求和和一个计数的标准差。对于这种统计处理，我们必须实例化一个序列对象，以便我们可以多次检查数据。

以下是我们如何计算两组样本之间的相关性：

```py
def corr( sample1, sample2 ):
 **μ_1, σ_1 = mean(sample1), stdev(sample1)
 **μ_2, σ_2 = mean(sample2), stdev(sample2)
 **z_1 = (z(x, μ_1, σ_1) for x in sample1)
 **z_2 = (z(x, μ_2, σ_2) for x in sample2)
 **r = sum(zx1*zx2 for zx1, zx2 in zip(z_1, z_2) )/s0(sample1)
 **return r

```

这个相关性函数收集了两组样本的基本统计摘要：均值和标准差。在得到这些摘要后，我们定义了两个生成器函数，它们将为每组样本创建标准化值。然后我们可以使用`zip()`函数（见下一个例子）将来自两个标准化值序列的项目配对，并计算这两个标准化值的乘积。标准化分数的乘积的平均值就是相关性。

以下是一个收集两组样本之间相关性的例子：

```py
 **>>> xi= [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65,...    1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83,] #  Height (m)
 **>>> yi= [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29,...    63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46,] # ...    Mass (kg)
 **>>> round(corr( xi, yi ), 5)
 **0.99458

```

我们展示了两组数据点`xi`和`yi`。相关性超过了 0.99，显示了两个序列之间非常强的关系。

这显示了函数式编程的一个优点。我们使用了半打函数来创建一个方便的统计模块，这些函数的定义都是单个表达式。反例是`corr()`函数，它可以简化为一个非常长的表达式。这个函数中的每个内部变量只使用一次；一个局部变量可以用创建它的表达式的复制粘贴来替换。这告诉我们，`corr()`函数具有函数式设计，即使它是用 Python 的六行单独写出的。

# 使用 zip()来构造和展开序列

`zip()`函数会从几个迭代器或序列中交错值。它将从每个*n*输入可迭代对象或序列中的值创建*n*个元组。我们在上一节中使用它来交错来自两组样本的数据点，创建两个元组。

### 注意

`zip()`函数是一个生成器。它不会实现一个结果集合。

以下是一个示例，展示了`zip()`函数的作用：

```py
>>> xi= [1.47, 1.50, 1.52, 1.55, 1.57, 1.60, 1.63, 1.65,... 1.68, 1.70, 1.73, 1.75, 1.78, 1.80, 1.83,]** 
>>> yi= [52.21, 53.12, 54.48, 55.84, 57.20, 58.57, 59.93, 61.29,... 63.11, 64.47, 66.28, 68.10, 69.92, 72.19, 74.46,]** 
>>> zip( xi, yi )
<zip object at 0x101d62ab8>
>>> list(zip( xi, yi ))
[(1.47, 52.21), (1.5, 53.12), (1.52, 54.48), (1.55, 55.84), (1.57, 57.2), (1.6, 58.57), (1.63, 59.93), (1.65, 61.29), (1.68, 63.11), (1.7, 64.47), (1.73, 66.28), (1.75, 68.1), (1.78, 69.92), (1.8, 72.19), (1.83, 74.46)]

```

`zip()`函数有许多边缘情况。我们必须问以下关于其行为的问题：

+   如果没有任何参数会发生什么？

+   当只有一个参数时会发生什么？

+   当序列长度不同时会发生什么？

对于缩减（`any()`、`all()`、`len()`、`sum()`）,我们希望从缩减空序列中得到一个标识元素。

显然，这些边缘情况中的每一个都必须产生某种可迭代的输出。以下是一些例子，以澄清这些行为。首先是空参数列表：

```py
>>> zip()
<zip object at 0x101d62ab8>
>>> list(_)
[]

```

我们可以看到，`zip()`函数没有参数是一个生成器函数，但不会有任何项。这符合输出是可迭代的要求。

接下来，我们将尝试一个单个可迭代对象：

```py
>>> zip( (1,2,3) )
<zip object at 0x101d62ab8>
>>> list(_)
[(1,), (2,), (3,)]

```

在这种情况下，`zip()`函数从每个输入值中发出一个元组。这也是非常有意义的。

最后，我们将看一下`zip()`函数使用的不同长度的`list`方法：

```py
>>> list(zip((1, 2, 3), ('a', 'b')))
[(1, 'a'), (2, 'b')]

```

这个结果是有争议的。为什么要截断？为什么不用`None`值填充较短的列表？`zip()`函数的另一种定义在`itertools`模块中作为`zip_longest()`函数可用。我们将在第八章中看到，*迭代工具模块*。

## 解压压缩的序列

`zip()`映射可以被反转。我们将看几种解压元组集合的方法。

### 注意

我们无法完全解压元组的可迭代对象，因为我们可能需要多次遍历数据。根据我们的需求，我们可能需要实现可迭代对象以提取多个值。

第一种方法是我们已经看到很多次的；我们可以使用一个生成器函数来解压一个元组序列。例如，假设以下对是一个包含两个元组的序列对象：

```py
p0= (x[0] for x in pairs)
p1= (x[1] for x in pairs)

```

这将创建两个序列。`p0`序列有每个两元组的第一个元素；`p1`序列有每个两元组的第二个元素。

在某些情况下，我们可以使用`for`循环的多重赋值来分解元组。以下是一个计算乘积和的示例：

```py
sum(p0*p1 for for p0, p1 in pairs)

```

我们使用`for`语句将每个两元组分解为`p0`和`p1`。

## 展平序列

有时，我们会有需要展平的压缩数据。例如，我们的输入可能是一个看起来像这样的文件：

```py
 **2      3      5      7     11     13     17     19     23     29
 **31     37     41     43     47     53     59     61     67     71
 **...

```

我们可以轻松地使用`((line.split() for line in file)`来创建一个包含十个元组的序列。

我们可能会有以下形式的数据块：

```py
blocked = [['2', '3', '5', '7', '11', '13', '17', '19', '23', '29'], ['31', '37', '41', '43', '47', '53', '59', '61', '67', '71'],...

```

尽管这不是我们想要的。我们希望将数字放入一个单一的、扁平的序列中。输入中的每个项目都是一个十元组；我们宁愿不要与逐个分解这个项目打交道。

我们可以使用两级生成器表达式，如下面的代码片段所示，用于这种展平：

```py
>>> (x for line in blocked for x in line)
<generator object <genexpr> at 0x101cead70>
>>> list(_)
['2', '3', '5', '7', '11', '13', '17', '19', '23', '29', '31', '37', '41', '43', '47', '53', '59', '61', '67', '71', … ]

```

最初，两级生成器是令人困惑的。我们可以通过一个简单的重写来理解这一点：

```py
for line in data:
 **for x in line:
 **yield x

```

这个转换向我们展示了生成器表达式的工作原理。第一个`for`子句（`for line in data`）遍历数据中的每个十元组。第二个`for`子句（`for x in line`）遍历第一个`for`子句中的每个项目。

这个表达式将一个序列结构压缩成一个单一的序列。

## 构造平面序列

有时，我们会有原始数据，它是一列值的平面列表，我们希望将其分成子组。这有点复杂。我们可以使用`itertools`模块的`groupby()`函数来实现这一点。这将等到第八章*迭代工具模块*。

假设我们有一个简单的平面`list`如下：

```py
flat= ['2', '3', '5', '7', '11', '13', '17', '19', '23', '29', '31', '37', '41', '43', '47', '53', '59', '61', '67', '71', ... ]

```

我们可以编写嵌套的生成器函数，从平面数据构建一个序列结构。为了做到这一点，我们需要一个可以多次使用的单一迭代器。表达式看起来像以下的代码片段：

```py
>>> flat_iter=iter(flat)
>>> (tuple(next(flat_iter) for i in range(5)) for row in range(len(flat)//5))
<generator object <genexpr> at 0x101cead70>
>>> list(_)
[('2', '3', '5', '7', '11'), ('13', '17', '19', '23', '29'), ('31', '37', '41', '43', '47'), ('53', '59', '61', '67', '71'), ('73', '79', '83', '89', '97'), ('101', '103', '107', '109', '113'), ('127', '131', '137', '139', '149'), ('151', '157', '163', '167', '173'), ('179', '181', '191', '193', '197'), ('199', '211', '223', '227', '229')]

```

首先，我们创建了一个迭代器，它存在于我们将用来创建我们的序列结构的两个循环之外。生成器表达式使用`tuple(next(flat_iter) for i in range(5))`从`flat_iter`变量中的可迭代值创建了五个元组。这个表达式被嵌套在另一个生成器中，它重复内部循环正确次数，以创建所需的值序列。

这仅在平面列表均匀分割时有效。如果最后一行有部分元素，我们需要单独处理它们。

我们可以使用这种函数将数据分组为相同大小的元组，最后一个元组的大小为奇数，使用以下定义：

```py
def group_by_seq(n, sequence):
 **flat_iter=iter(sequence)
 **full_sized_items = list( tuple(next(flat_iter)** 
 **for i in range(n))
 **for row in range(len(sequence)//n))
 **trailer = tuple(flat_iter)
 **if trailer:
 **return full_sized_items + [trailer]
 **else:
 **return full_sized_items

```

我们创建了一个初始的`list`，其中每个`tuple`的大小为`n`。如果有剩余的元素，我们将有一个长度非零的尾部`tuple`，我们可以将其附加到完整大小的项目的`list`上。如果尾部`tuple`的长度为 0，我们将忽略它。

这不像我们之前看过的其他算法那样简单和功能性。我们可以将其改写为一个相当愉快的生成器函数。以下代码使用`while`循环作为尾递归优化的一部分：

```py
def group_by_iter( n, iterable ):** 
 **row= tuple(next(iterable) for i in range(n))
 **while row:
 **yield row
 **row= tuple(next(iterable) for i in range(n))

```

我们从输入可迭代对象中创建了所需长度的一行。当我们到达输入可迭代对象的末尾时，`tuple(next(iterable) for i in range(n))`的值将是一个长度为零的元组。这是递归的基本情况，我们已经将其写成了`while`循环的终止条件。

## 构造平面序列——另一种方法

假设我们有一个简单的平面`list`，我们想从这个`list`中创建成对的元素。以下是所需的数据：

```py
flat= ['2', '3', '5', '7', '11', '13', '17', '19', '23', '29', '31', '37', '41', '43', '47', '53', '59', '61', '67', '71',... ]

```

我们可以使用列表切片创建成对的元素，如下所示：

```py
zip(flat[0::2], flat[1::2])

```

切片`flat[0::2]`是所有偶数位置。切片`flat[1::2]`是所有奇数位置。如果我们将它们一起压缩，我们得到一个两个元素的元组`(0)`，第一个偶数位置的值，和`(1)`，第一个奇数位置的值。如果元素的数量是偶数，这将很好地产生成对。

这有一个相当简短的优点。前一节中显示的函数是解决相同问题的更长的方法。

这种方法可以泛化。我们可以使用`*(args)`方法生成必须被压缩在一起的序列结构。它看起来像以下的样子：

```py
zip(*(flat[i::n] for i in range(n)))

```

这将生成`n`个切片：`flat[0::n]`，`flat[1::n]`，`flat[2::n]`，…，`flat[n-1::n]`。这些切片的集合成为`zip()`的参数，然后交错地从每个切片中提取值。

回想一下，`zip()`会将序列截断为最短的`list`。这意味着，如果`list`不是分组因子`n`的偶数倍（`len(flat)%n != 0`），也就是最后一个切片，它的长度将不同于其他切片的长度，其他切片都将被截断。这很少是我们想要的。

如果我们使用`itertools.zip_longest()`方法，那么我们将看到最终的元组将填充足够的`None`值，使其长度为`n`。在某些情况下，这种填充是可以接受的。在其他情况下，额外的值是不希望的。

`list`切片方法对数据进行分组是另一种处理将扁平数据结构化为块的方法。作为一种通用解决方案，它似乎并没有比前一节中的函数提供太多优势。作为专门用于从扁平数据中制作两个元组的解决方案，它非常简单。

# 使用 reversed()改变顺序

有时我们需要一个反转的序列。Python 为我们提供了两种方法：`reversed()`函数和使用反转索引的切片。

例如，考虑将基数转换为十六进制或二进制。以下是一个简单的转换函数：

```py
def digits(x, b):
 **if x == 0: return
 **yield x % b
 **for d in to_base(x//b, b):
 **yield d

```

此函数使用递归从最不重要的位到最重要的位产生数字。`x%b`的值将是基数`b`中`x`的最不重要的数字。

我们可以将其形式化如下：

![使用 reversed()改变顺序](https://github.com/OpenDocCN/freelearn-python-pt2-zh/raw/master/docs/fp-py/img/B03652_04_13.jpg)

在许多情况下，我们更喜欢以相反的顺序产生数字。我们可以使用`reversed()`函数包装这个函数，以交换数字的顺序：

```py
def to_base(x, b):
 **return reversed(tuple(digits(x, b)))

```

### 注意

`reversed()`函数产生一个可迭代对象，但参数值必须是一个序列对象。然后该函数以相反的顺序产生该对象的项目。

我们也可以使用切片来做类似的事情，比如`tuple(digits(x, b))[::-1]`。然而，切片不是一个迭代器。切片是从另一个实例化对象构建的实例化对象。在这种情况下，对于这样小的值集合，区别是微不足道的。由于`reversed()`函数使用的内存较少，对于更大的集合来说可能更有优势。

# 使用 enumerate()包括序列号

Python 提供了`enumerate()`函数，将索引信息应用于序列或可迭代对象中的值。它执行一种特殊的包装，可以作为`unwrap(process(wrap(data)))`设计模式的一部分使用。

它看起来像下面的代码片段：

```py
>>> xi
[1.47, 1.5, 1.52, 1.55, 1.57, 1.6, 1.63, 1.65, 1.68, 1.7, 1.73, 1.75, 1.78, 1.8, 1.83]
>>> list(enumerate(xi))
[(0, 1.47), (1, 1.5), (2, 1.52), (3, 1.55), (4, 1.57), (5, 1.6), (6, 1.63), (7, 1.65), (8, 1.68), (9, 1.7), (10, 1.73), (11, 1.75), (12, 1.78), (13, 1.8), (14, 1.83)]

```

`enumerate()`函数将每个输入`item`转换为一个带有序列号和原始`item`的对。它与以下内容略有相似：

```py
zip(range(len(source)), source)

```

`enumerate()`的一个重要特点是，结果是可迭代的，并且可以与任何可迭代的输入一起使用。

例如，在统计处理时，`enumerate()`函数非常方便，可以通过为每个样本加上一个数字，将单个值序列转换为更适当的时间序列。

# 摘要

在本章中，我们详细介绍了使用多种内置缩减的方法。

我们使用`any()`和`all()`来进行基本逻辑处理。这些都是使用简单运算符如`or`或`and`的简洁示例。

我们还看了一些数值缩减，如`len()`和`sum()`。我们应用这些函数来创建一些高阶统计处理。我们将在第六章*递归和缩减*中回顾这些缩减。

我们还看了一些内置映射。

`zip()`函数合并多个序列。这使我们考虑在结构化和扁平化更复杂的数据结构的上下文中使用它。正如我们将在后面的章节中看到的例子，嵌套数据在某些情况下很有帮助，而扁平数据在其他情况下很有帮助。

`enumerate()`函数将可迭代对象映射到两个元组的序列。每个两元组都有`(0)`作为序列号和`(1)`作为原始项目。

`reversed()`函数按照它们的原始顺序迭代序列对象中的项目。一些算法更有效地按照一种顺序产生结果，但我们希望以相反的顺序呈现这些结果。

在下一章中，我们将看看`mapping`和`reduction`函数，它们使用额外的函数作为参数来定制它们的处理。接受函数作为参数的函数是我们的第一个高阶函数的例子。我们还将涉及返回函数作为结果的函数。
