# 安卓应用安全基础知识（二）

> 原文：[`zh.annas-archive.org/md5/88CB58B22F96FE00C43EA554A1F58FCE`](https://zh.annas-archive.org/md5/88CB58B22F96FE00C43EA554A1F58FCE)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 第六章：你的工具 - 加密 API

为了尊重用户隐私，处理敏感数据的应用程序需要保护这些数据不被窥探。尽管 Android 栈提供了分层的安全架构，安全功能内置于操作系统本身，但在设备上获取 root 访问权限相对容易，从而危及存储在设备上的数据。因此，应用程序开发者了解他们可以用来安全存储数据的工具是很重要的。同样，他们了解如何正确传输数据也是至关重要的。

Android 栈为开发者提供了工具，用于执行诸如加密和解密、散列、生成随机数以及消息认证码等任务。这些工具是栈中各个软件包提供的加密 API。`javax.crypto` 软件包提供了加密和解密消息、生成消息认证码和密钥协商 API 的能力。`java.util.Random` 类提供了生成随机数的工具，而 `java.security` 软件包提供了散列、密钥生成和证书管理的 API。

在本章中，我们将讨论 Android 栈提供的加密 API，应用程序开发者可以利用这些 API 来保护敏感信息。我们首先介绍密码学中使用的基本术语，然后是如何确定可用的安全提供者。接下来，我们将讨论随机数生成，随后是散列函数。接着会讨论非对称和对称密钥密码学以及不同的加密模式，然后是消息认证码。

# 术语

让我们先了解一些在密码学中使用的术语。随着我们深入本章，这些术语将反复出现，因此在我们继续之前，熟悉它们是很重要的。

+   密码学：密码学是在不安全环境中以及在对手存在的情况下进行安全通信的研究和实践。随着我们的生活越来越数字化和互联，密码学的重要性日益增加。密码学以算法和协议的形式实践，这些算法和协议是使用数学公式和计算上困难的问题设计的。

+   明文：也称为纯文本，明文是发送者想要传输的需要保密的消息。如果爱丽丝想要向鲍勃发送一条消息"Hello World"，那么"Hello World"就是明文。

+   密文：也称为编码文本，这是发送给接收者的经过编码或加密的明文消息。让我们继续之前的例子，爱丽丝想要将消息"Hello World"发送给鲍勃。爱丽丝使用了一种替换方法，每个字母被下一个字母替换，形成密文。因此，明文"Hello World"现在变成了"Ifmmp Xpsme"。"Ifmmp Xpsme"就是传送给鲍勃的密文。

+   加密：加密是将明文转换为密文的过程，这样窃听者无法在传输或存储过程中解读信息，只有知道密码的双方才能理解。在上述示例中，将"Hello World"转换为"Ifmmp Xpsme"的过程称为加密。![术语](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_01.jpg)

+   解密：解密是加密的逆过程。它是在接收端将密文转换回明文以获取信息的过程。因此，将"Ifmmp Xpsme"转换回"Hello World"的过程称为解密。![术语](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_02.jpg)

+   关键：在密码学术语中，密钥是决定加密算法输出的关键信息或数学参数。在上述示例中，将"Hello World"转换为"Ifmmp Xpsme"时，关键信息是给每个字母加一，这就是密钥。在解密过程中，关键信息是从每个字母减一，这就是解密的密钥。

+   密码：密码是执行消息加密和解密的加密算法。它也被称为加密算法。在上述示例中，密码是一种将"Hello World"加密为"Ifmmp Xpsme"的算法，然后在接收端将"Ifmmp Xpsme"转换回"Hello World"。

# 安全提供者

就安全提供者而言，Android 堆栈是可定制的。这意味着设备制造商可以添加他们自己的加密提供者。作为应用程序开发者，您也可以自由使用自己的安全提供者。由于 Android 堆栈仅提供 Bouncy Castle 安全提供者的一些功能，因此 Spongy Castle 非常受欢迎。此外，不同版本的 Android 堆栈通过移除不安全的加密算法并添加新的算法，不断更新其加密功能。您可能想要检查在特定时间点提供者及其支持算法的完整列表。同时，确保在不同的设备上测试您的应用程序，以确认加密算法按预期工作。

下面的代码片段展示了如何使用`java.security.Providers`方法获取加密提供者列表：

```kt
for (Provider provider: Security.getProviders()) {
    System.out.println(provider.getName());
}
```

![安全提供者](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_03.jpg)

现在为了获取每个提供者的详细信息，让我们增强函数以记录更多细节，如下所示：

```kt
for (Provider provider: Security.getProviders()) {
    System.out.println(provider.getName());
    for (String key: provider.stringPropertyNames()) {
      System.out.println("\t" + key +
        "\t" + provider.getProperty(key));
    }
}
```

下面的屏幕截图显示了有关一些安全提供者的详细信息：

![安全提供者](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_04.jpg)

始终使用知名、行业标准的加密算法。编写加密例程听起来很有趣也很简单，但实际上比看上去要困难得多。我们将在下一节学习的行业标准算法是由加密专家开发并经过彻底测试的。如果发现这些算法有任何弱点，那么这些信息会被公开，开发者可以用更强大的加密算法更新他们的代码。

# 随机数生成

生成随机数是密码学中最重要的任务之一。随机数作为其他加密功能的种子，如加密和生成消息认证码。模拟真正的随机数生成是很困难的，因为它们来自自然界不可预测的行为。计算机系统生成伪随机数，这意味着它们并不是真正的随机，但看起来是随机的。

计算生成的随机数有两种方法：**伪随机数生成器**（**PRNG**）和**真随机数生成器**（**TRNG**）。PRNG 是基于某些数学公式算法生成的。TRNG 基于系统特性，如**CPU**（**中央处理单元**）周期、时钟、噪声和按键操作等。都柏林三一学院的 Mads Haahr 博士运行着[www.random.org](http://www.random.org)，这是任何对随机性感兴趣的人的一个非常有趣的站点。请查看！

随机数的应用场景包括游戏应用，比如用户掷骰子的应用、赌博应用、随机播放歌曲的音乐应用，以及作为加密操作（如哈希、加密或密钥生成）的种子等。并非所有的应用场景都需要强烈的随机性。比如，随机播放曲目的音乐播放器不需要像密钥生成算法那样强烈的随机性。

安卓提供了使用`java.util`包中的`java.util.Random`类生成随机数的能力。这个类提供了生成一个或多个随机双精度浮点数、字节、浮点数、整数或长整数的数组的方法。这个类是线程安全的。

下面的代码片段展示了如何在 1 到 100 的范围内生成一个随机数的例子。

```kt
int min = 1;
int max = 100;

public int getRandom(int min, int max) {
  Random random = new Random();
  int num = random.nextInt(max - min + 1) + min;
  return num;
}
```

也可以使用种子生成随机数。然而，由于安卓堆栈有一个伪随机数生成器，它使用一个相当不可预测的初始状态作为种子，实际上种子使得随机数更容易被预测。

# 哈希函数

哈希函数是处理任意长度数据以产生固定长度输出的算法。对于相同的输入，输出总是相同的，对于不同的输入值，输出总是不同的。这些函数是单向的，这意味着对数据的反向操作是不可能的。

在数学术语中，单向哈希函数可以定义如下：

给定一个消息*M*，和一个单向哈希函数*H*，很容易计算出*x*使得*H(M) = x*。但是给定*x*和*H*，要得到消息*M*是不可行的。这可以数学上如下表示：

*H(M) = x*

*H(x) ≠ M*

哈希函数的另一个特性是低碰撞概率。这意味着给定一个消息*M*，很难找到另一个消息*M*，使得：

*H(M)* ≠ *H(M')*

单向哈希函数可用于各种应用。它们用于为可变长度字符串创建固定大小的输出。使用哈希，可以安全地存储给定哈希的值；无法检索原始消息。例如，在表中存储密码的哈希，而不是密码本身。由于给定的消息哈希值始终相同，输入正确的密码将导致生成相同的哈希值。它们用作校验和，以确保消息在传输过程中未被更改。

目前广泛使用的最流行的哈希函数是**MD5**（**消息摘要算法**）和**SHA**（**安全哈希算法**）系列的哈希函数。所有这些哈希函数在强度和碰撞概率上都有所不同，你应该选择最适合你应用的一个。通常，使用 SHA-256 是一个不错的选择。许多应用程序仍然使用 MD5 和 SHA-1，但现在这些被认为足够安全。对于需要非常高级别安全的应用程序，应考虑使用更强大的哈希函数，如 SHA-3。以下表格总结了一些常见哈希函数的输出长度：

| 哈希算法 | 块长度（位） | 输出长度（位） |
| --- | --- | --- |
| MD5 | 512 | 128 |
| SHA-1 | 512 | 160 |
| SHA-256 | 512 | 256 |
| SHA-512 | 1024 | 512 |

下面的维基百科图片展示了输入的微小变化如何完全改变输出。这个案例中的哈希函数是 SHA-1：

![哈希函数](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_05.jpg)

`java.security`包中的`java.security.MessageDigest`类提供了哈希功能。以下代码片段展示了如何使用这个类对字符串`s`创建一个 SHA-256 哈希。`update`方法使用字节更新摘要，而`digest`方法创建最终的摘要。

```kt
final MessageDigest digest = MessageDigest.getInstance("SHA-256");
digest.update(s.getBytes());
byte messageDigest[] = digest.digest();
```

# 公钥密码学

公钥密码学是一种使用两个密钥的密码系统：一个用于加密，另一个用于解密。其中一个密钥是公开的，另一个是私有的。

公钥密码学最常见的用途是针对两个用例。一个是保密性，另一个是认证。在保密性情况下，发送者使用接收者的公钥加密消息并发送。由于接收者持有私钥，接收者使用私钥来解密消息。

在作为数字签名的认证情况下，发送者使用他们的私钥加密消息（在大多数使用场景中，加密的是消息的哈希值而不是整个消息），并将其公开。任何拥有公钥的人都可以访问它，并确信消息来自发送者。

下面的截图展示了两个使用场景：

![公钥密码学](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_06.jpg)

在以下章节中，我们讨论了两种常见的公钥密码算法：用于加密和认证的 RSA，以及用于密钥交换的 Diffie-Hellman。

## RSA

以其发明者 Ron Rivest、Adi Shamir 和 Leonard Adleman 的名字命名，RSA 是基于公钥密码学的一种算法。RSA 的安全性基于分解两个大素数。算法本身不是秘密，公钥也不是。只有素数是秘密的。

根据所需的强度，使用的 RSA 密钥长度可以是 512、1024、2048 或 4096 位。目前 2048 位的密钥被认为是强的。RSA 非常慢，因此应避免用它来加密大量数据集。需要注意的是，可以用 RSA 加密的消息长度不能超过模数（两个素数的乘积的长度）。由于 RSA 本质上很慢，通常的做法是使用对称密钥加密明文，然后再用 RSA 加密密钥。

RSA 可以用于保密和认证的数字签名。在使用 RSA 时有三种主要操作，如下所述：

### 密钥生成

实现 RSA 的第一步是生成密钥。在 Android 中，可以通过使用`java.security.KeyPairGenerator`类来完成。以下代码片段展示了如何生成一个 2048 位的密钥对：

```kt
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
keyGen.initialize(2048);
KeyPair key = keyGen.generateKeyPair();
```

如果密钥已经以原始形式存在，并且需要从中提取私钥和公钥，那么可以使用`java.security.KeyFactory`类从密钥规格中提取公钥和私钥，如下所示：

```kt
KeyFactory keyFactory = KeyFactory.getInstance("RSA");
keyFactory.generatePublic(keySpecs);
```

### 加密

根据使用场景，加密和解密可以通过私钥或公钥来执行。以下代码片段使用接收者的公钥加密数据。这个示例紧接着前面使用`java.security.KeyPairGenerator`类生成密钥对的方法。以下示例使用`java.security.Cipher`类来初始化密码并执行操作：

```kt
private String rsaEncrypt (String plainText) {
    Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
    PublicKey publicKey = key.getPublic();
    cipher.init(Cipher.ENCRYPT_MODE, publicKey);
    byte [] cipherBytes = cipher.doFinal(plainText.getBytes());
    String cipherText = new String(cipherBytes,
        "UTF8").toString();
    return cipherText;
}
```

### 解密

解密是加密的相反操作。以下代码展示了如何使用私钥来解密数据。接着前面的示例，这是一个发送者使用接收者的公钥加密消息，然后接收者使用他们的私钥进行解密的案例。

```kt
private String rsaDecrypt (String cipherText) {
    Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
    PrivateKey privateKey = key.getPrivate();
    cipher.init(Cipher.DECRYPT_MODE, privateKey);
    byte [] plainBytes = cipher.doFinal(cipherText.getBytes());
    String plainText = new String(plainBytes, "UTF8").toString();
    return plainText;
}
```

### 填充（Padding）

在前面的示例中，您会注意到加密算法是用**PKCS1Padding**进行初始化的。让我们来更多地了解一下填充。RSA 算法没有随机成分。这意味着使用相同的密钥加密相同的明文将产生相同的密文。这种特性可能导致针对加密系统的选定明文攻击。在加密明文之前，通常会用随机数据填充。由 RSA 实验室发布的**PKCS#1**（**公钥密码学标准**）用于在明文中嵌入结构化随机数据。后来证明，即使是 PKCS#1 填充也不足以避免适应性选定明文攻击。这是一种选定密文攻击，在这种攻击中，随后的密文是根据第一组解密密文的结果来选择的。为了减轻这类攻击，建议使用 PKCS#1 v1.5。另一种可以使用的填充是**OAEP**（**光不对称加密填充**）。

在示例中，您还会注意到参数中的**CBC**（**Cipher Block Chaining**，密文块链）。这种模式将在本章的*块密码模式*部分进行讨论。

## Diffie-Hellman 算法

由 Whitefield Diffie 和 Martin Hellman 于 1976 年发布，Diffie-Hellman 是最受欢迎的密钥交换算法。这个算法的巧妙之处在于，双方可以在不安全的通道上独立生成一个秘密密钥，而无需交换秘密密钥。然后可以使用这个秘密密钥进行对称加密。

Diffie-Hellman 算法没有验证双方的身份。因此，它容易受到中间人攻击，在这种攻击中，窃听者坐在中间，冒充另一方与双方通信。维基百科下面的插图完美地解释了 Diffie-Hellman 的概念，使用了两方：Alice 和 Bob：

![Diffie-Hellman 算法](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_07.jpg)

下面的代码示例显示了生成密钥对的示例实现。使用`java.security.KeyPairGenerator`类基于 DH 参数生成密钥对。接下来，使用`javax.crypto`类生成密钥协商：

```kt
// DH params
BigInteger g = new BigInteger("0123456789", 16);
BigInteger p = new BigInteger("0123456789", 16);
DHParameterSpec dhParams = new DHParameterSpec(p, g);

// Generate Key pair
KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DH");
keyGen.initialize(dhParams, new SecureRandom());

// Generate individual keys
KeyAgreement aKeyAgree = KeyAgreement.getInstance("DH");
KeyPair aPair = keyGen.generateKeyPair();
aKeyAgree.init(aPair.getPrivate());

KeyAgreement bKeyAgree = KeyAgreement.getInstance("DH");
KeyPair bPair = keyGen.generateKeyPair();
bKeyAgree.init(bPair.getPrivate());

// Do the final phase of key agreement using other party's 
  public key
aKeyAgree.doPhase(bPair.getPublic(), true);
bKeyAgree.doPhase(aPair.getPublic(), true);
```

# 对称密钥加密

对称密钥加密基于一个秘密密钥，双方都相同。加密和解密都使用相同的密钥。与公钥密码学相比，这是一个问题，因为需要通过某种方式安全地交换秘密密钥。如果窃听者获得了密钥，系统的安全性就被破坏了。

![对称密钥加密](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_08.jpg)

对称密钥比公钥快得多，在加密/解密大量数据时非常理想。对称密钥算法的安全性基于密钥的长度。

## 流密码

流密码是一种对称密钥加密类型，其中每个位或字节的数据是使用称为密钥流的随机位序列单独进行加密的。通常，每个位或字节与密钥流进行**异或**（**Exclusive OR**）操作。密钥流的长度与数据的长度相同。流密码的安全性取决于密钥流的随机性。如果使用相同的密钥流对多个数据集进行加密，那么算法的漏洞可能会被发现并利用。下图展示了流密码的工作情况：

![流密码](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_09.jpg)

流密码的最佳应用场景是数据长度可变的情况，如在 Wi-Fi 或加密语音数据中。它们在硬件中的实现也相对容易。使用流密码技术的一些算法示例包括 RC4、A5/1、A5/2 和 Helix。

由于密钥与需要加密的数据长度相同，流密码在密钥管理上存在严重问题。

## 块密码

在块密码的情况下，数据块是逐个使用密钥进行加密的。明文被划分为固定长度的块，每个块单独进行加密。下图展示了块密码的基本思想。每个明文被划分为固定大小的数据块。如果块不能均匀划分，它们会使用一组标准的位进行填充，以达到期望的长度。然后每个块使用一个密钥进行加密，并生成固定长度的加密块。

![块密码](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_10.jpg)

块密码的一个问题是，如果相同的数据块被重复，输出总是相同的。另一个问题是，如果数据块在传输过程中丢失，没有办法识别出数据块已经丢失。已经设计出各种块密码模式来解决前面提到的问题。块密码在加密算法中得到了广泛的应用，例如 AES、DES、RC5 和 Blowfish。

由于明文被划分为块，通常最后一个块将没有足够的位来填满块。在这种情况下，最后一个块会填充额外的位以达到所需的长度。这个过程被称为填充。

## 块密码模式

在块密码模式下，明文被划分为多个块，每个块都使用相同的密钥进行加密。在下面一节中，将讨论实现块加密的一些技术。这些模式既用于对称加密，也用于非对称加密，如 RSA。然而，在实际应用中，很少使用非对称密码对大量数据进行加密，因为它们通常速度非常慢。

### 电子密码本（ECB）

在 ECB 模式下，明文被划分为块，每个块独立地使用密钥进行加密。这种模式可以很容易地进行并行处理，因此速度很快。这种模式不隐藏明文模式。因此，相同的块将产生相同的密文。任何攻击者都可以修改或窃取明文，而发送者却一无所知。

下图展示了在 ECB 模式下如何实现加密和解密：

![电子密码本（ECB）](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_11.jpg)

下面的代码演示了如何使用 ECB 模式初始化 RSA 密码：

```kt
Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
```

同样，为了使用 ECB 初始化 AES 对称算法，可以使用以下代码：

```kt
Cipher cipher = Cipher.getInstance("AES/ECB");
```

### 密文块链（CBC）

在 CBC 模式下，每个明文块与之前的密文块进行异或操作，然后进行加密。这种模式解决了与 ECB 模式相关的两个缺点。将块与之前的明文块进行异或操作可以隐藏明文中的任何模式。此外，如果除了第一个和最后一个块之外的任何块被删除或更改，接收者可以轻松检测到。

下图说明了使用 CBC 模式对明文块进行加密和解密。注意使用**初始化向量**（**IV**）为第一个块添加随机性。IV 是一组随机的位，与第一个块进行异或操作：

![密文块链（CBC）](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_12.jpg)

下面的代码演示了如何使用 CBC 模式初始化 RSA 密码：

```kt
Cipher cipher = Cipher.getInstance("RSA/CBC/PKCS1Padding");
```

同样，为了使用 CBC 初始化 AES 对称算法，可以使用以下代码：

```kt
Cipher cipher = Cipher.getInstance("AES/CBC");
```

### 密文反馈链（CFB）

在 CFB 模式下，先对前一个密文块进行加密，然后与明文进行异或操作以生成密文。这种模式同样隐藏了明文模式，并使一个明文块依赖于前一个块。这使得在传输过程中可以跟踪和验证块的一致性。同样，注意第一个块使用了初始化向量（IV）。

![密文反馈链（CFB）](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_13.jpg)

下面的代码演示了如何使用 CFB 模式初始化 RSA 密码：

```kt
Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
```

同样，为了使用 CFB 初始化 AES 对称算法，可以使用以下代码：

```kt
Cipher cipher = Cipher.getInstance("AES/CFB");
```

### 输出反馈模式（OFB）

OFB 模式与 CFB 模式相似，不同之处在于异或的密文充当同步流密码，这样一位的错误只会影响一位，而不是整个块。同样，使用 IV 来启动该过程，如下所示：

![输出反馈模式（OFB）](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_14.jpg)

下面的代码演示了如何使用 OFB 模式初始化 RSA 密码：

```kt
Cipher cipher = Cipher.getInstance("RSA/OFB/PKCS1Padding");
```

同样，为了使用 OFB 初始化 AES 对称算法，可以使用以下代码：

```kt
Cipher cipher = Cipher.getInstance("AES/OFB");
```

## 高级加密标准（AES）

AES 是最受欢迎的块对称密码。它比其他常见的块对称密码（如 DES 和 DES3）更安全。此密码将明文划分为固定块大小，为 128 位，密钥可以是 128 位，192 或 256 位密钥。AES 速度快，内存要求低。Android 磁盘加密也使用 AES 128 位加密，主密钥也使用 AES 128 位加密。

以下代码段展示了如何生成 128 位 AES 密钥：

```kt
//Generate individual keys
Cipher cipher = Cipher.getInstance("AES");
KeyGenerator keyGen = KeyGenerator.getInstance("AES");
generator.init(128);
Key secretKey = keyGen.generateKey();
byte[] key = skey.getEncoded();
```

接下来，以下代码展示了如何使用 AES 密钥加密明文：

```kt
byte[] plaintext = "plainText".getBytes();
SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
Cipher cipher = Cipher.getInstance("AES");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
byte[] cipherText = cipher.doFinal(plainText);
```

继续前面的示例，要使用 AES 解密，可以使用以下代码：

```kt
SecretKeySpec skeySpec = new SecretKeySpec(raw, "AES");
Cipher cipher = Cipher.getInstance("AES");
cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
byte[] encrypted = cipher.doFinal(cipherText);
```

# 消息认证码

**消息认证码**（**MAC**）是附加到消息上以确定其真实性和完整性的标签或校验和。通过拥有一个秘密密钥来提供认证，验证消息的意外或有意更改提供了完整性。下图说明了 MAC 的工作原理：

![消息认证码](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_06_15.jpg)

可以使用不同的方法生成 MAC：使用一次性密钥或一次性秘密密钥、使用哈希函数、使用流密码，或者使用块密码并将最后一个块作为校验和输出。最后一种方法的例子是使用 CBC 模式的 DES。

哈希函数用于创建称为**哈希 MAC**（**HMAC**）的校验和。然后使用对称密钥加密此哈希并将其附加到消息中。这是生成 MAC 最受欢迎的方法。这种 MAC 的一些示例是带有 SHA1 的 AES 128 和带有 SHA1 的 AES 256。

Android 通过使用`javax.crypto.Mac`类提供了生成 HMAC 的能力。以下代码段展示了如何使用 SHA-1 生成摘要：

```kt
String plainText = "This is my test string.";
String key = "This is my test key.";
Mac mac = Mac.getInstance("HmacSHA1");
SecretKeySpec secret = new SecretKeySpec(key.getBytes("UTF-8"),
    mac.getAlgorithm());
mac.init(secret);
byte[] digest = mac.doFinal(plainText.getBytes());
String stringDigest = new String(digest);
```

# 总结

在本章中，我们讨论了应用程序开发人员可以使用哪些工具来保护其应用程序和用户数据的隐私。我们讨论了用于种子和加密算法初始化向量的随机数生成。讨论了哈希技术，如 SHA-1 和 MD5，开发人员可以使用这些技术来存储密码。它们还非常适合将大量数据压缩成有限且定义的长度。我们讨论了用于交换密钥的公钥密码学和对称密钥算法，如 AES 加密大量数据。我们还讨论了流密码和块密码以及块密码模式。大多数算法都有已发布的测试向量，并且可以在网上找到。开发人员可以针对这些测试向量测试他们的实现。在以下章节中，我们将使用这些工具和技术来保护数据。现在让我们继续下一章，学习如何为不同类型的数据选择最佳的存储选项。


# 第七章：保护应用数据

应用程序开发者的信誉取决于他们如何安全地处理用户数据。明智的做法是从不在设备上存储大量用户数据。这不仅会占用内存，而且是一个巨大的安全风险。然而，有些用例需要应用程序共享数据，缓存应用程序偏好设置，并在设备上存储数据。这类数据可能是应用程序私有的，也可能是与其他应用程序共享的。此类数据的例子可能是用户的偏好语言或书籍类别。应用程序保存此类数据是为了提升用户体验。它对应用程序本身有用，并且不与其他应用程序共享。共享数据的例子可能是用户在浏览商店时不断添加到收藏中的书籍愿望清单。此类数据可能会也可能不会与其他应用程序共享。

根据隐私和数据类型，可以采用不同的存储机制。应用程序可以选择使用共享偏好设置、内容提供者、存储在内部或外部内存中的文件，甚至是开发者自己的服务器来存储数据。

本章从最重要的问题开始，即确定应用程序应存储的识别信息以及如何决定数据的存储位置。通常情况下，应收集最少量的信息，并在收集敏感信息前获得用户同意。接下来，我们将讨论 Android 中的存储机制，包括共享偏好设置、设备存储、外部存储以及在后端服务器上存储数据。我们将讨论保护传输中数据的协议。我们将以讨论在外部存储上安装应用程序来结束本章。

# 数据存储决策

在应用程序的背景下，许多因素会影响数据存储的决定。其中大部分是基于开发者应该了解的数据安全方面，如隐私、数据保留和系统实现细节。以下各节将讨论这些问题。

## 隐私

当今的应用程序收集和使用关于用户的不同类型的信息。用户偏好、位置、健康记录、金融账户和资产等都是其中的一部分。收集此类信息应当谨慎，并得到用户同意，因为收集私人信息可能引发法律和道德问题，并可能被视为侵犯隐私。即使收集了此类信息，也应妥善加密存储并安全传输。本章后半部分的重点是安全数据存储和传输。

隐私以不同的形式表现。首先，在不同的文化和国家中是不同的。每个国家都建立了关于个人识别信息（PII）的规则和法规。例如，欧盟有一个关于处理和转移个人数据的**数据保护指令**。更多信息可以在欧洲委员会司法总司维护的此网站上找到：[`ec.europa.eu/justice/data-protection/index_en.htm`](http://ec.europa.eu/justice/data-protection/index_en.htm)。关于此方面的印度网络法律可以在[`deity.gov.in/content/cyber-laws`](http://deity.gov.in/content/cyber-laws)找到。美国采取的是分部门的数据保护方法。这是立法、监管和自我监管的结合，而不是仅由政府执行。

第二，不同的使用场景有不同的法律。例如，如果一个应用程序与医疗或健康相关，那么其规则与跟踪用户位置或进行金融交易的应用程序是不同的。美国一些具体的法律例子包括美国残疾人法案、1998 年的儿童在线隐私法案和 1986 年的电子通信隐私法案。因此，了解与您的使用案例以及您希望运营的国家相关的规则和法规非常重要。如有疑问，可以寻求在其领域内具有专业知识的公司的服务。例如，与其尝试建立自己的支付系统，不如使用像 PayPal 这样的支付提供商，后者已经进行了多年的支付处理，并且符合此领域如 PCI 等的规则和法规。

第三，从一个国家向另一个国家转移私人信息也受到规则和法规的约束。在大多数情况下，另一个国家应具备足够的保护法律以满足另一国家的保护标准。

《世界人权宣言》第 12 条规定了隐私规则如下：

> *"任何人不得受到任意干涉其隐私、家庭、住宅或通信，也不得受到对其荣誉和声誉的攻击。每个人都有权受到法律的保护，以免受到此类干涉或攻击。"*

PII 的一些例子包括全名、电子邮件地址、邮寄地址、驾驶执照、选民登记号、出生日期、母亲的婚前姓、出生地、信用卡号码、犯罪记录和国民身份证号码。在某些情况下，年龄、性别、工作职位和种族可能被视为 PII。有时，隐私可能意味着匿名。

如果您的应用程序正在收集 PII，您将不得不向用户披露，并可能需要获得他们的同意。您可以向他们展示使用应用程序或使用可能需要您的应用程序收集有关用户的敏感信息的特定功能的条款和条件。

## 数据保留

数据保留是指在一定时间内存储数据。这种数据用于追踪和识别如人员、设备和位置等信息。例如，银行数据通常保存七年。在大多数使用场景中，数据保留不应成为问题，除非是针对特定使用场景的组织，如邮政、银行、政府、电信、公共卫生和安全。在大多数情况下，必须为访问此类个人识别信息（PII）定义适当的访问权限。同样，不同国家和不同使用场景的数据保留规则是不同的。

## 实施决策

在处理数据并决定最安全的安全机制时，第一个问题是确定数据将存储在哪里。让我们回到我们的书店示例。正如我们在第三章，*权限*中所确定的那样，我们示例中的数据元素是：

+   姓名

+   信用卡号码

+   邮寄地址

+   最后搜索的作者

+   最后搜索的语言

+   最后搜索的分类

+   用户名

+   密码

+   书籍愿望清单

根据它们的隐私需求对上述资产进行进一步分析，我们确定了 PII 为姓名、信用卡号码、邮寄地址和密码。请注意，这种分类也会根据国家而改变。

接下来是持久性的问题。我们希望数据在应用程序的一个实例中可用，还是在多个实例中？我们希望数据在重置后仍然存在吗？在我们的示例中，我们希望所有资产都能持久化。然而，如果用户偏好（如作者、分类和语言）在重置后不保留，我们并没有丢失有价值的信息，用户可以再次选择它们。

第三项重要的任务是识别哪些数据对应用程序是私有的，哪些数据是共享的。数据的可见性将影响我们选择的存储选项。

第四个问题是数据的大小。大文件最好存储在外部存储上。下图展示了典型安卓手机设备中可用的内存选项：

![实施决策](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_07_01.jpg)

始终建议使用框架提供的存储机制，而不是发明一个新的。在以下各节中，我将讨论 Android 框架为不同存储需求提供的存储机制。

# 用户偏好

应用程序以两种方式收集用户偏好设置。在第一种情况下，应用程序向用户展示设置屏幕，让用户选择如语言、每页显示的结果数量等偏好设置。这类偏好设置最好使用`Preference`类进行存储。另一种情况是在用户浏览应用程序时自动获取用户偏好设置。例如，在搜索书籍时，用户选择了特定作者的书籍。应用程序可能希望保存此类偏好设置，以便用户下次登录时使用。这类用户偏好设置最好使用`SharedPreferences`进行存储。需要注意的是，`Preference`类在底层也调用了`SharedPreferences`。请记住，`SharedPreferences`只能持久化基本数据类型。

## 共享偏好设置

`SharedPreferences`类用于以键值对的形式存储基本数据类型。这些基本类型包括`int`、`long`、`Boolean`、`float`、`string set`和`string`。存储在`SharedPreferences`中的数据在应用程序会话中持久存在。偏好文件以 XML 文件的形式存储在设备上应用程序的`data`目录中。因此，该文件受到与应用程序相同的 Linux 权限的沙盒保护。即使应用程序被杀死，偏好文件中的数据仍然存在，只有在应用程序被卸载或使用`Preference`类的方法删除特定值时，文件才会被销毁。

对于任何类型的数据存储，有三个操作：实例化存储、存储数据和检索数据。

### 创建偏好设置文件

下面的代码片段使用默认文件名实例化`SharedPreferences`：

```kt
SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
```

在这种情况下，文件名可以通过以下代码获取：

```kt
String preferencesName = this.getPreferenceManager().getSharedPreferencesName();
```

你也可以指定偏好设置文件的名称。在以下示例中，偏好设置文件的名称为`MyPref`：

```kt
public Static final String PREF_FILE = "MyPref";
SharedPreferences preferences = getSharedPreferences(PREF_FILE, MODE_PRIVATE);
```

上面的代码片段引发了一个关于偏好文件可见性和共享的重要讨论。默认情况下，所有偏好文件都是创建它的应用程序私有的。因此，它们的模式是`MODE_PRIVATE`。如果需要在不同应用程序之间共享偏好文件，可以将其设置为`MODE_WORLD_WRITABLE`或`MODE_WORLD_READABLE`，分别允许其他应用程序写入和读取偏好文件。

### 写入偏好设置

下一步是将基本数据存储到偏好文件中。下面的代码片段紧接着前面的代码片段，展示了如何将数据添加到偏好文件中。你会注意到，需要使用`SharedPreferences.Editor`类来存储值。`Editor`类中的所有值都是批处理的，需要提交才能使值持久化。在以下示例中，`MyString`是字符串的键，其值为`Hello World!`。

```kt
SharedPreferences.Editor editor = preferences.edit();
editor.putString("MyString", "Hello World!");
editor.commit();
```

### 读取偏好设置

下一步是读取偏好文件中的键值对。下面的代码片段紧接着前面的代码片段，展示了如何从偏好文件中读取数据：

```kt
String myString = preferences.getString("MyString", "");
```

### 提示

`SharedPreferences`可以被应用程序的所有组件访问。如果设置为`MODE_WORLD_WRITABLE`或`MODE_WORLD_READABLE`，其他应用程序可以写入和读取偏好设置文件。

要读取另一个应用程序的偏好设置文件，第一步是获取指向另一个应用程序上下文的指针，然后读取该值。

```kt
Context myContext = getApplicationContext().createPackageContext("com.android.example", Context.MODE_WORLD_READABLE);
SharedPreferences preference =
myContext.getSharedPreferences("MyPref",Context.MODE_WORLD_READABLE);
String mMyString = preference.getString("MyString", "");
```

## 偏好设置 Activity

从 Honeycomb 开始，Android 扩展了`Preference`类的功能，以从 UI 收集设置。这些值被设置为 XML 文件，而 Activity 从中加载。在幕后，`Preference`类使用`SharedPreferences`类来存储键值对。这些设置是应用程序私有的，只有`Activity`类可以访问。

要选择铃声，需要在`res/xml`目录下的`Preference.xml`文件中设置以下代码：

```kt
<RingtonePreference
  android:name="Ringtone Preference"
  android:summary="Select a Ringtone"
  android:title="Ringtones"
  android:key="ringtonePref" />
```

要从该 XML 文件中加载一个 Activity，可以在`onCreate()`方法中使用以下代码：

```kt
public class Preferences extends PreferenceActivity {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    addPreferencesFromResource(R.xml.preferences);
. . . .
}
```

记得在清单文件中添加这个 Activity。

# 文件

应用程序也可以使用 Android 的文件系统来存储和检索数据。`java.io`包提供了这一功能。这个包提供了从文件中读写不同数据类型的类。默认情况下，应用程序创建的文件是私有的，其他应用程序无法访问。文件在重启和应用程序崩溃后仍然存在；只有在应用程序被卸载时才会被删除。

## 创建文件

下面的代码片段展示了如何创建一个文件。正如我之前所说，默认情况下，所有文件都是应用程序私有的。

```kt
FileOutputStream fOut = openFileOutput("MyFile.txt", MODE_WORLD_READABLE);
```

文件`MyFile.txt`将被创建在`/data/data/<application-path>/files/`目录中。前面提到的文件是作为`MODE_WORLD_READABLE`创建的，这意味着其他应用程序可以读取这个文件。其他选项分别是`MODE_WORLD_READABLE`、`MODE_PRIVATE`和`MODE_APPEND`，它们允许其他应用程序写入文件、保持文件对应用程序私有或向文件追加内容。决定适当的可见性很重要。在安全性方面，永远只给出所需的最小可见性。

由于`MODE_WORLD_READABLE`和`MODE_WORLD_WRITABLE`是非常危险的选择，从 API 级别 17 开始，这些选项已被弃用。如果仍需要与同一证书关联的应用程序之间共享文件，可以使用`android:sharedUserId`选项。如果这些是不同的应用程序，则可以使用封装类来处理文件访问，并提供读写功能。可以通过权限来保护对此封装类的访问。

## 写入文件

下一步是写入文件。以下代码段展示了如何使用`OutputStreamWriter`类将字符串写入文件。在`java.io`包中有许多选项可用于将不同类型的数据写入文件。请检查该包以选择适合您用例的正确选项。

```kt
String myString = new String ("Hello World!");
FileOutputStream fOut = context.openFileOutput("MyFile.txt", MODE_PRIVATE);
OutputStreamWriter osw = new OutputStreamWriter(fOut);
osw.write(myString);
osw.flush();
osw.close();
```

## 从文件中读取

如前所述，请检查`java.io`包以找到从文件中读取数据的最佳方法。以下代码段展示了如何从文件中读取字符串。

下面的示例一次从文件中读取一行：

```kt
FileInputStream fIn = context.openFileInput("MyFile.txt");
InputStreamReader isr = new InputStreamReader(fIn);
BufferedReader bReader = new BufferedReader(isr);
StringBuffer stringBuf = new StringBuffer();
String in;
while ((in = bReader.readLine()) != null) {
  stringBuf.append(in);
  stringBuf.append("\n");
}
bReader.close();
String myString = stringBuf.toString();
```

## 外部存储上的文件操作

文件也可以创建在外部存储上。如果 API 级别为 8 或更高，Android 提供了一个特殊的函数`getExternalFilesDir()`，用于获取外部存储上的应用程序目录。

```kt
File file = new File (getExternalFilesDir(null), "MyFile.txt");
```

如您在前面的代码段中注意到的，`getExternalFilesDir()`方法接受一个参数。此参数用于根据媒体类型识别适当的存储目录。例如，要存储图片，使用`ENVIRONMENT.DIRECTORY_PICTURES`，要存储音乐文件，使用`ENVIRONMENT.DIRECTORY_MUSIC`。如果这样的目录不存在，它将被创建，然后文件将存储在那里。值`null`是应用程序的根目录。

```kt
File file = new File(
  getExternalFilesDir(ENVIRONMENT.DIRECTORY_PICTURES),
  "MyFile.jpg");
```

对于 API 级别小于 8 的情况，用户可以使用`getExternalStorageDirectory()`来获取外部存储的根目录。然后可以在`/Android/data/<application-path>/files/`目录中创建文件。

要在外部存储上创建文件，应用程序应具有`WRITE_EXTERNAL_STORAGE`权限。创建在外部存储上的文件将在用户卸载应用程序时被移除。

外部存储缺少内部存储的安全机制。最好假设存储在外部存储上的任何数据都是不安全的，并且可以被全局读取。如果外部存储未挂载，文件将无法访问，必须采用适当的错误处理机制，以便应用程序优雅地失败。

在某些情况下，可能实际上需要外部存储，特别是如果文件不包含个人识别信息（PII），并且旨在跨不同设备共享和可用。媒体扫描器在搜索相关内容时会扫描这些目录。这些目录如下列出。这些目录遵循应用程序的根目录`/data/data/<application-path>/`。

+   **音频（音乐）文件**：`Music/`

+   **播客文件**：`Podcasts/`

+   **视频文件（除摄像机外）**：`Movie/`

+   **铃声**：`Ringtones/`

+   **图片**：`Pictures/`

+   **杂项下载**：`Downloads/`

+   **通知声音**：`Notifications/`

+   **闹钟**：`Alarms/`

# 缓存

如果一个应用程序需要缓存数据，那么使用 Android 栈提供的缓存存储机制是明智的。Android 将缓存文件与应用程序一起存储在文件系统中，这样它们就会被创建它们的应用程序沙盒化。所有缓存文件都创建在`/data/data/<application-path>/cache/`目录中。当系统内存不足时，这些缓存文件会被首先删除。定期修剪这些文件是必要的，因为它们可能会变得很大并占用磁盘空间。

下面的代码片段首先将字符串写入缓存文件，然后从缓存文件中读取相同的字符串。您会注意到，读取和写入与任何文件输入/输出都相同，只是使用`getCacheDir()`获取文件的位置来写入字符串。

```kt
//Write to the cache file
String myString = new String ("Hello World!");
File file = new File (getCacheDir(), "MyCacheFile");
FileOutputStream fOut = new FileOutputStream(file);
OutputStreamWriter osw = new OutputStreamWriter(fOut);
osw.write(myString);
osw.flush();
osw.close();

// Now read from the cache file
File file = new File (getCacheDir(), "MyCacheFile");

FileInputStream fIn = new FileInputStream (file);
InputStreamReader isr = new InputStreamReader(fIn);
BufferedReader bReader = new BufferedReader(isr);
StringBuffer stringBuf = new StringBuffer();
String in;
while ((in = bReader.readLine()) != null) {
  stringBuf.append(in);
  stringBuf.append("\n");
}
bReader.close();
String myString = stringBuf.toString();
```

与在外部存储上创建文件一样，也可以创建缓存文件。根据 API 级别，方法会有所不同。从 API 级别 8 开始，Android 提供了一个特殊的函数`getExternalCacheDir()`，用于获取外部存储上的缓存目录。

```kt
File file = new File (getExternalCacheDir(), "MyCacheFile");
```

这个目录与应用程序关联，当应用程序被卸载时，这个目录将不复存在。如果是多用户环境，每个用户都有自己的个人目录。

如果 API 级别小于 8，用户可以使用`getExternalStorageDirectory()`获取外部存储，然后在`/Android/data/<application-path>/cache/`目录中创建文件。

要在外部存储上创建缓存，应用程序应具有`WRITE_EXTERNAL_STORAGE`权限。

在外部存储上创建缓存并非没有安全顾虑。首先，如果外部存储没有挂载缓存文件，那么它是无法访问的，必须为应用程序实施适当的错误处理机制，以便应用程序能够优雅地失败。其次，外部存储本质上是安全的，因此应假定外部存储上的任何内容都是全局可读的。

### 提示

应定期修剪缓存文件，并移除不需要的文件以保留内存。

# 数据库

数据库是存储结构化数据的最佳选择。Android 通过`android.database.sqlite`包支持 SQLite。这个数据库是 Android 栈的一部分，系统管理数据库。对于移动操作系统来说，使用 SQLite 是一个明智的选择，因为它体积小，无需设置或管理，且是免费的！

创建后，数据库文件与应用程序一起被沙盒化，并存储在`/data/data/<application-path>/databases/`目录中。这个私有数据库将对应用程序的所有组件开放，但不会对外开放。

下面的代码片段展示了如何创建一个位于内部存储上的数据库。这个类将扩展`SQLiteOpenHelper`类，并使用 SQL（结构化查询语言）的`CREATE_TABLE`子句。该表存储用户标记为心愿单的书籍列表。我们的表`wishlist`中有两列，一列是自动递增的 ID，另一列是书名。

你会注意到这里有两个方法，`onCreate()`和`onUpgrade()`。`onCreate()`将创建一个新的数据库（如果它不存在）以及一个新的数据库表。如果数据库已经存在，则会调用`onUpgrade()`方法。

```kt
public class MySQLiteHelper extends SQLiteOpenHelper {
  public static final String TABLE_NAME = "wishlist";
  public static final String COLUMN_ID = "_id";
  public static final String COLUMN_BOOK = "book";
  private static final String DATABASE_NAME = "bookstore.db";
  private static final int DATABASE_VERSION = 1;
  @Override
  public void onCreate(SQLiteDatabase database) {
    database.execSQL("create table " + TABLE_NAME + "("
      + COLUMN_ID + " integer primary key autoincrement, "
      + COLUMN_BOOK + " text not null);");
  }

  @Override
  public void onUpgrade(SQLiteDatabase database) {
    database.execSQL("drop table if exists " + TABLE_NAME);
    onCreate(db);
  }
. . . .
}
```

同样，其他数据库查询可以用来添加一行、读取一行和删除一行。任何关于 SQL 的好书都可以帮助你完成这些查询。

也有可能在外部内存中创建一个数据库。创建一个接受目录路径的自定义上下文类可以实现这一点。你还需要拥有对外部存储的写入权限。然而，如果表中有敏感信息，则不建议这样做。

正如我之前所提到的，SQLite 数据库是一个私有数据库，与应用程序一起被沙盒化。如果需要将此数据与其他应用程序共享，则可以通过作为 URI 地址的内容提供者来实现。我们在第二章，*应用程序构建块*中已经详细介绍了内容提供者。

# 账户管理器

在存储敏感数据的背景下，存储密码或认证令牌是一个重要的方面。考虑像 Google 邮箱、Twitter 和 Facebook 这样的应用程序，它们允许用户登录。其他应用程序使用像 OAuth2 这样的身份协议所使用的认证令牌。

安卓提供了`android.accounts.AccountManager`类作为存储用户凭据的中心化存储库。应用程序可以选择使用自己的可插拔认证器来处理账户认证。从存储用户名到身份信息，再到创建你自己的自定义账户管理器，安卓的`AccountManager`是一个强大的工具。

`AccountManager`类的功能受到权限保护，因此你的应用程序需要请求`android.permission.GET_ACCOUNTS`来访问存储在其上的账户列表，以及使用 OAuth2 的`android.permission.ACCOUNT_MANAGER`。

每个账户都采用命名空间格式。例如，Google 账户使用`com.google`，Twitter 账户使用`com.twitter.android.auth.login`。以下是如何访问`AccountManager`：

```kt
AccountManager am = AccountManager.get(getApplicationContext());
```

可以使用以下代码获取整个账户列表：

```kt
Account[] accounts = am.getAccounts();
```

`auth`令牌以`Bundle`的形式获取，使用名为`KEY_AUTHTOKEN`的值来检索。

```kt
String token = bundle.getString(AccountManager.KEY_AUTHTOKEN);
```

使用`AccountManager`时有两大要点需记住。首先，如果你的应用尝试使用 OAuth2 进行认证，你的应用将和服务器进行通信，这可能会导致延迟，因此这些调用应该是异步进行的。其次，凭据以明文形式存储在`AccountManager`中。所以在已获得根权限的手机上，任何使用`adb shell`命令的用户都能看到这些凭据。因此，在设备上存储信息时，应避免以明文形式存储密码和个人识别信息（PII），而应通过散列或加密以加密安全的方式存储，这将最小化设备被入侵的风险。

# SSL/TLS

我阅读了一项由德国汉诺威莱布尼茨大学和马尔堡菲利普大学的学生进行的研究，非常有趣，关于传输中数据的中间人（MITM）攻击。研究的应用程序使用了 SSL（安全套接层）或 TLS（传输层安全）协议来保护网络上的数据。许多应用程序没有正确使用 SSL/TLS，导致存在漏洞。另一个有趣的观察是，由于 Android 浏览器通常不会显示通常与使用 SSL/TLS 的网站相关的绿色挂锁，用户并不了解他们正在使用一个不安全的网站。查看这篇论文：[`www2.dcsec.uni-hannover.de/files/android/p50-fahl.pdf`](http://www2.dcsec.uni-hannover.de/files/android/p50-fahl.pdf)。我相信这将是一次有趣的阅读。

前述研究揭示了在应用程序中正确实现协议的重要性。本节介绍了 SSL/TLS 并提供了一些正确实现它的注意事项。SSL 是由 Netscape 开发的，用于在互联网上进行安全通信的协议。该协议遵循客户端和服务器之间的一系列调用，在这些调用中，它们协商用于数据交换的密钥和密码套件。

Android 提供了通过`javax.net.ssl`、`org.apache.http.conn.ssl`和`android.net`包集成 SSL/TLS 的能力。以下图示展示了 SSL 的顺序：

![SSL/TLS](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_07_02.jpg)

第一步是设置一个密钥库并导入服务器证书链。接下来是将密钥库链接到`DefaultHttpClient`，这样它就知道在哪里找到服务器的证书。

在开发阶段，尤其是在企业环境中，我们通过创建自定义`TrustManager`使 SSL 信任所有证书，并通过`SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER`允许所有主机名。如果这样的应用程序被发布，它将存在严重的安全缺陷。在发布你的应用程序之前，请检查这一点。因此，在发布应用程序之前，请记得修复这些问题。

# 在外部存储上安装应用程序

正如在第四章 *定义应用程序的策略文件* 中所讨论的，从 API 级别 8 开始，应用程序可以选择安装在 SD 卡上。一旦 APK 移动到外部存储，应用程序所占用的唯一内存就是存储在内部内存中的应用程序私有数据。需要注意的是，即使是 SD 卡上的 APK，DEX（Dalvik 可执行）文件、私有数据目录和本地共享库仍然保留在内部存储上。

在清单文件中添加一个可选属性可以启用此功能。对于此类应用程序的 **应用程序信息** 屏幕上，要么有 **移动到 SD 卡** 按钮，要么有 **移动到手机** 按钮，具体取决于 APK 的当前存储位置。然后用户可以选择相应地移动 APK 文件。如果外部设备被卸载或 USB 模式设置为 **大容量存储**（设备被用作磁盘驱动器），则托管在该外部设备上的所有运行中的活动和服务的进程会被立即结束。

下面的屏幕截图显示了应用程序设置中的 **移动到 SD 卡** 选项：

![在外部存储上安装应用程序](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_07_03.jpg)

现在，每个应用程序的 `ApplicationInfo` 对象都有一个名为 `FLAG_EXTERNAL_STORAGE` 的新标志。对于存储在外部设备上的应用程序，此标志的值为 `true`。如果这样的应用程序被卸载，该应用程序的内部存储也会被移除。如果外部设备不可用（例如，当 SD 卡被卸载时），内部存储不会被清除。在这种情况下，用户可以通过卸载应用程序来清除内部存储。执行此操作不需要挂载 SD 卡。

同时也添加了两个新的广播。

+   `ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE`：当 SD 卡被卸载时，会发送此意图。它包含一个禁用应用程序的列表（使用 `EXTRA_CHANGED_PACKAGE_LIST` 属性）和一个不可用应用程序 UID 的列表（使用 `EXTRA_CHANGED_UID_LIST` 属性）。

+   `ACTION_EXTERNAL_APPLICATIONS_AVAILABLE`：当 SD 卡再次可用时，会发送此意图。它包含一个禁用应用程序的列表（使用 `EXTRA_CHANGED_PACKAGE_LIST` 属性）和一个不可用应用程序 UID 的列表（使用 `EXTRA_CHANGED_UID_LIST` 属性）。

当一个应用程序从内部存储移动到外部位置时，会触发 `ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE`。然后，资源和资产会被复制到新位置。应用程序启用后，会再次触发 `ACTION_EXTERNAL_APPLICATIONS_AVAILABLE` 广播意图。

### 提示

任何类型的外部设备本质上都是不安全的。例如，由于电源故障（在手机中就是电池耗尽）或不正确的移除方式（没有正确卸载），SD 卡可能会遭受内存损坏。SD 卡在全球范围内可读，因此应用程序可以被读取、写入、复制或删除。

为了在外部设备上安全存储 APK，安卓应用程序被存储在一个加密容器（ASEC 文件）中，以防止其他应用程序或程序修改或损坏它们。ASEC 文件是一个加密的文件系统，其密钥是随机生成的并由设备存储，因此只能由最初安装它的设备进行解密。因此，安装在 SD 卡上的应用程序只适用于一个设备。

挂载 SD 卡（使用 Linux 回环机制）时，这些容器与内部存储上的应用程序以相同的方式挂载。文件系统强制执行权限，使得其他应用程序不能修改其内容，除了系统本身，没有其他人可以通过 ASEC 文件修改任何内容，因为其他应用程序没有相应的密钥。此外，SD 卡以`noexec`方式挂载，因此没有人可以在那里放置可执行代码。

一个设备可以关联多个 SD 卡，以便轻松更换 SD 卡。只要 SD 卡被挂载，就没有性能问题。

安卓开发者网站（[developer.android.com](http://developer.android.com)）列出了在 SD 卡上安装应用程序可能导致应用程序表现不稳定的使用场景，尤其是当 SD 卡被卸载时。其中一些，如服务，是基于服务在手机启动时可用顺序的。以下是列出的部分情况：

+   **服务**：运行中的服务将被杀死。应用程序可以注册`ACTION_EXTERNAL_APPLICATIONS_AVAILABLE`广播意图，当安装在扩展存储上的应用程序对系统可用时，该意图会通知你的应用程序。一旦收到该意图，服务就可以重新启动。

+   **闹钟服务**：使用`AlarmManager`注册的闹钟将被取消，并在外部存储重新挂载时手动重新注册。

+   **输入法引擎（IME）**：IME 是一个控件，允许用户输入文本。如果你的 IME 位于外部存储上，它将被默认的 IME 替换。当外部存储重新挂载时，用户将需要打开系统设置以重新启用自定义 IME。

+   **动态壁纸**：如果设置的动态壁纸存储在外部存储上，那么默认的动态壁纸将替换正在运行的动态壁纸。当外部存储重新挂载时，用户将需要重新选择他们自定义的动态壁纸。

+   **应用小部件**：如果你的应用小部件存储在外部存储上，它将被从主屏幕移除。在大多数情况下，需要系统重置才能让应用小部件再次出现在主屏幕上。

+   **账户管理器**：如果使用`AccountManager`创建了任何账户，它们将在外部存储重新挂载之前消失。

+   **同步适配器**：`AbstractThreadedSyncAdapter`及其所有同步功能将无法工作。需要重新挂载外部存储才能使同步功能再次工作。

+   **设备管理员**：这一部分非常重要，因为`DeviceAdminReceiver`及其所有管理功能将被禁用，即使重新挂载 SD 卡，这些功能可能也无法完全正常工作。

+   **广播接收器**：任何监听`ACTION_BOOT_COMPLETE`广播的广播接收器将停止工作，因为系统在外部存储挂载到设备之前发送此广播。因此，在外部存储上安装的任何应用程序都无法接收此广播。

# 概述

本章介绍了 Android 上可用的存储机制。我们从理解隐私和数据保留等术语开始。在收集可识别个人信息之前，我们应当始终考虑这些问题，以避免法律和道德问题。需要注意的是，关于隐私和数据安全的规则和法规根据国家和使用情况的不同而有所不同。我们探讨了使用共享偏好存储用户偏好，以及在文件、缓存和数据库上存储、读取和写入数据的方法。我们还讨论了在使用 SSL/TLS 以及在外部存储上安装应用程序时需要考虑的一些重要事项。

接下来的三章将介绍非常有趣的话题，包括设备管理、以安全为重点的测试以及 Android 上的新出现的使用案例。请继续阅读！


# 第八章：企业中的安卓

随着移动设备的普及，越来越多的员工将设备带到工作中，并要求企业数据能够在他们的个人或企业移动设备上访问。这带来了极大的便利，但同时也带来了日益增加的挑战。由于设备被破坏或丢失而造成的企业数据丢失成本非常高。

随着移动设备在工作场所的普及，IT 部门面临着许多挑战。第一个挑战是各种各样的移动设备，它们有着不同的外形和功能。第二个挑战是让员工接受并在特定应用程序和设备部分上接受企业控制。第三个挑战是持续支持设备管理。

本章节专注于安卓设备的管理。如果你不是为企业开发应用程序，可以安全地跳过这一章，直接进入下一章关于安卓应用程序的安全测试。

本章从设备管理的基础和安卓生态系统的独特挑战开始。其次，我们讨论设置和实施设备管理策略以及为安卓设置接收器的机制。我们还讨论了存储在设备上和传输过程中的数据的安全性。我们以提出为安卓设置设备管理的下一步建议以及设备管理员应了解的政策和合规性指南来结束本章。

# 基础知识

在企业中设备的背景下，BYOD、MDM 和 MAM 这三个术语经常被使用。我们将在本章的剩余部分继续使用它们，让我们了解它们各自的含义。

第一个术语是**自带设备**（**BYOD**）。这个术语指的是员工将自己的移动设备带到工作场所，并在个人设备上访问企业数据和应用程序的最新趋势。例如，在个人移动设备上访问电子邮件和办公文档。

第二个经常使用的术语是**移动设备管理**（**MDM**）。MDM 指的是对企业拥有或员工拥有的移动设备进行远程管理，这些设备访问企业应用程序和数据。例如远程擦除企业数据并要求用户设置密码等功能，这些都是 MDM 的例子。这些功能强化了企业对系统功能的控制。

在此背景下经常使用的第三个术语是**移动应用管理**（**MAM**）。这个术语指的是管理访问企业数据的移动设备上的软件和服务。MAM 的例子包括应用程序升级、捕获崩溃日志和用户统计信息并将其发送给 IT 部门。MAM 与 MDM 不同，因为后者专注于设备功能，而 MAM 专注于设备上安装的软件和服务。

# 理解安卓生态系统

Android 是一个具有众多定制版本的挑战性生态系统。下图展示了在撰写本书时 Android 版本的使用情况。如您所注意，在任何给定时间，都有不同版本的 Android 堆栈在使用中。理解每个版本细微差别和特殊需求本身就是一份全职工作。您始终可以在[`developer.android.com/about/dashboards/index.html`](http://developer.android.com/about/dashboards/index.html)查看最新的使用统计数据。

加上前述问题，每个制造商都有一个定制的 Android 堆栈版本，以及他们选择的功能和能力。在此堆栈之上，运营商也添加了他们的定制内容。这导致了市场的高度碎片化。

![了解 Android 生态系统](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_01.jpg)

# 设备管理功能

从 Android 2.2 开始，Android 增加了越来越多的功能，使 Android 准备好迎接企业环境。后续的每个版本都在改进现有功能并增加更多功能。下表列出了特定企业功能在 Android 堆栈中添加的时间。本节将重点介绍其中一些功能：

| Android 发布版 | 企业功能 |
| --- | --- |
| Froyo（发布版 2.2） |

+   密码策略

+   远程擦除

+   远程锁定

|

| Gingerbread（发布版 2.3） |
| --- |

+   SIP 支持

|

| Honeycomb（发布版 3.0） |
| --- |

+   平板电脑的加密和密码策略

+   平板电脑的系统加密

|

| Ice cream sandwich（发布版 4.0） |
| --- |

+   扩展系统加密，对设备实施加密和密码策略

+   证书管理功能

+   VPN

+   SSL VPN 的开发者接口

+   人脸识别解锁

+   网络数据使用监控

+   离线电子邮件搜索

|

## 设备管理 API

如前表所示，从 Android 2.2 开始，Android 一直在增加对设备管理的支持。在这方面最大的步骤是在 Android 2.2 中引入了设备管理 API，以支持对需要企业级系统级控制的设备的控制。

设备管理 API 通过四个步骤进行操作：

1.  系统管理员编写一个应用程序，以远程管理设备政策。

1.  用户从 Google Play 或其他应用商店下载应用程序。用户还可以通过电子邮件安装应用程序。

1.  下载完成后，用户安装应用程序。在安装时，用户会看到将在设备上执行的政策。用户必须同意这些政策才能激活应用程序。

1.  安装后，用户必须遵守这些政策才能访问敏感信息。用户可以卸载应用程序，这将导致无法访问敏感数据。

下图展示了如果用户安装了一个强制执行密码策略的管理应用程序，要求密码必须包含特定类型的字符，流程会是怎样的：

![设备管理 API](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_02.jpg)

设备管理 API 被封装为`android.app.admin`。这个包有三个类：用于定义和实现策略的`DevicePolicyManager`，包含设备管理类元数据的`DeviceAdminInfo`，以及用于实现接收器组件的`DeviceAdminReceiver`。

### 策略

策略是设备管理的重要组成部分。在撰写本书时，设备管理 API 支持的策略与密码、远程擦除、禁用摄像头、设备加密和锁定设备有关。密码策略的示例包括要求密码包含字母数字字符、密码过期和超时，以及最大密码尝试次数。当前策略的列表可以在`android.app.admin.DevicePolicyManager`中验证。

策略在`res`文件夹下的 XML 文件中定义。一个示例策略文件可以限制密码，远程重置设备到出厂设置，禁用摄像头，加密存储，并锁定设备。在安装期间，这些策略会展示给用户。

```kt
<device-admin >
    <uses-policies>
        <limit-password />
        <force-lock />
        <wipe-data />
        <expire-password />
        <encrypted-storage />
        <disable-camera />
    </uses-policies>
</device-admin>
```

新版本中会不断添加额外的策略。你可以检查当前构建版本，并根据情况实施策略。

设备管理应用程序包含`DevicePolicyManager`，它管理一个或多个设备管理接收器的策略。

```kt
DevicePolicyManager mDPMgr = 
  (DevicePolicyManager)getSystemService
    (Context.DEVICE_POLICY_SERVICE);
```

使用以下代码可以远程从手机中擦除数据。需要注意的是，市场上也有一些假的设备管理应用程序。请确保下载管理员建议的正确管理应用程序。不安全或受到木马影响的程序很容易导致数据泄露：

```kt
DevicePolicyManager mDPMgr;
mDPMgr.wipeData(0);
```

要设置加密文件系统的策略，可以使用以下代码片段：

```kt
DevicePolicyManager mDPMgr;
ComponentName mMyDeviceAdmin;
mDPMgr.setStorageEncryption(mMyDeviceAdmin, true);
```

### DeviceAdminReceiver

继承`DeviceAdminReceiver`类来创建设备管理应用程序。这个类包含了一些回调函数，当发生特定事件时会被触发。这些意图由系统发送。因此，接收器应该能够处理`ACTION_DEVICE_ADMIN_ENABLED`意图。

`DeviceAdminReceiver`需要`BIND_DEVICE_ADMIN`权限。`BIND_DEVICE_ADMIN`是一个特殊的权限，只有系统可以访问；应用程序无法访问。这确保只有系统与接收器交互。

接收器还引用了我们在上一节中讨论的元数据策略文件。以下代码片段展示了示例声明。

```kt
<receiver android:name="MyDeviceAdminReceiver"
        android:label="@string/my_device_admin_receiver"
        android:description="@string/my_device_admin_desc"
        android:permission="android.permission.BIND_DEVICE_ADMIN">
    <meta-data android:name="android.app.my_device_admin"
                android:resource="@xml/my_device_admin" />
    <intent-filter>
      <action   android:name="android.app.action.DEVICE_ADMIN_ENABLED" />
    </intent-filter>
</receiver>
```

以下屏幕截图展示了企业电子邮件的 Exchange ActiveSync 设置。这只是一个示例来说明流程。在第一张截图中，需要填写 Exchange 的实际账户详情。这些将是企业账户详情。注意选择加密的 SSL 连接：

![DeviceAdminReceiver](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_03.jpg)

在下一步中，用户选择应同步到设备的功能。在我们的案例中，用户勾选了 Exchange ActiveSync 提供的所有功能，即**邮件**、**联系人**和**日历**。这如下面的截图所示：

![设备管理接收器](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_04.jpg)

在第三步中，如下截图所示，用户必须确认他们同意在设备上实施的安全策略，如果他们决定安装应用程序并能够访问敏感信息。如果用户拒绝同意，将不会安装应用程序（在我们的案例中，**邮件**、**联系人**和**日历**将不会同步）。

![设备管理接收器](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_05.jpg)

在下一步中，用户将审查通过同步电子邮件实施的政策。这些是在前面示例中定义的策略文件中的政策。在我们的示例中，如下截图所示，设备管理员可以在设备丢失、员工停止为企业工作或任何其他原因的情况下远程擦除员工设备上的所有数据。第二个政策是设备管理员将设置密码规则。这些密码规则可能是以下任何一种：

![设备管理接收器](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_06.jpg)

## 保护设备上的数据

MDM 的主要要求是保护设备上的企业数据。Android 设备通常有两种数据存储形式：内部存储和外部（可移动）存储介质。从 Honeycomb 开始，内部文件系统挂载在`/mnt/sdcard`，外部存储挂载在`/mnt/external#`（其中`#`是外部设备的数量）。早期版本将内部存储挂载在`/mnt/sdcard`，SD 卡挂载在`/mnt/sdcard/external_sd`。Android 堆栈的定制版本可能会也可能不会遵循这些指导方针。

Android 通过全盘加密和支持加密算法来解决企业数据保护在设备上的问题。

### 加密

在 Android 3.0 中增加了支持全盘加密的能力，以防止未经授权访问用户数据。文件系统使用`dm_crypt`内核特性进行加密，并在块设备层上工作。密钥源自用户密码，使用的加密方式是带有 CBC 和 ESSIV: SHA-256 的 AES-128。主密钥或加密密钥通过使用 Open SSL 和 AES-128 进行加密。

为了使全盘加密工作，设备需要使用密码进行保护（图案密码将不起作用）。在访问文件系统之前，必须使用密码解锁设备。设备管理员可以设置一个政策，限制密码尝试次数，超过该次数设备将重置为出厂设置。

用户必须手动同意加密设备。注意，当设备首次进行加密时，设备应有足够的电量来完成加密过程。如果设备电量耗尽，那么必须将其恢复到出厂设置，所有用户数据将会丢失。

### 提示

只有设备上的文件系统被加密。外部存储，如 SD 卡，没有被加密。

如在第六章中讨论的，*你的工具 - 加密 API*，安卓堆栈支持加密和散列等加密算法。在需要将信息存储在 SD 卡上的情况下，可以使用堆栈支持的加密功能。设备管理员可以强制执行政策，要求所有存储在 SD 卡上的数据必须加密。

即使设备完全加密，用户仍然需要注意几个问题。首先是肩窥问题，在拥挤的地方，有人可能会从别人肩膀上偷看密码。人们应该注意这个问题。第二，尽管输入密码解锁手机相当麻烦，但这是为了保护企业数据的安全，建议选择更复杂的密码，而不是倾向于选择简单的密码。设备策略可能会对此提出要求。第三，请注意，只有文件系统的数据分区被加密。虽然很容易在其他地方存储数据，但出于安全考虑，任何企业数据都应该存储在数据分区中。

### 备份

谷歌为安卓设备提供备份服务。备份内容包括壁纸、设置、词典和浏览器设置等。当手机恢复出厂设置时，这些设置会被恢复。敏感数据，如密码、屏幕锁定 PIN 码、短信和通话记录不会被备份。备份服务只能通过使用`BackupManager` API 进行访问。用户需要在设置下的**隐私**选项手动开启备份功能。

谷歌不保证备份的安全性，因为不同的安卓版本实现备份的方式不同。此备份服务可能不支持所有类型的安卓设备。

## 安全连接

安卓设备原生支持 VPN。管理员可能会建议使用自定义 VPN，并可能要求所有通信都开启 VPN。这尤其在连接开放热点时特别有用。后者功能仅在安卓 4.2 及以上版本中提供。以下截图展示了我手机上支持的一些 VPN 协议：

![安全连接](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_07.jpg)

当用户连接 Wi-Fi 时，应选择安全的无线连接。在这种情况下，用户将被提示输入密码密钥。以下截图展示了这一过程：

![安全连接](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_08.jpg)

## 身份

Android 支持证书存储，用于在设备上存储证书，并允许授权应用在诸如电子邮件、Wi-Fi 和**VPN**（**虚拟专用网络**）的使用场景中使用它进行身份验证。Android 支持 DER 编码的 X.509 证书。它还支持存储为 PKCS#12 密钥库文件的 X.509 证书。

Android 支持 Bouncy Castle，并预装了证书。它们位于`cacerts.bks`密钥库中。

用户还可以从设备内存中安装证书。在**位置与安全**设置下，通过选择**从 SD 卡安装**选项，可以在设备上安装新的证书。用户在安装证书时应注意，安装非合法证书可能会危及设备的安全。

要删除证书，用户可以进入**个人** | **安全** | **凭据存储** | **信任的凭据**，并禁用或删除证书。

# 下一步

既然我们已经了解了 Android 支持 BYOD 的能力，本节将讨论如何利用这些知识在企业中推出 Android 支持。

## 设备特定决策

要充分利用 Android 设备的功能，设备必须与 Google 账户关联。这使用户能够访问 Google Play、位置服务以及其他一系列应用程序，如 Gmail、Drive、日历和 YouTube。设备管理员面临的重要问题是，他们是否希望员工使用个人 Google 账户还是单独的企业账户。

另一个重要的问题是启用位置服务，这可能会对一些高价值员工造成隐私风险，因为他们可能不希望被追踪。另一方面，启用位置服务可以帮助确定设备如果被盗时的位置。

第三个重要问题是备份和存储。与位置服务的情况一样，备份和存储是重要的功能，但可能会引发隐私问题。设备管理员可能会强制使用加密存储或指定一个私有的企业云。但这很快就会增加维护成本。要启用备份，用户必须明确进入**设置** | **隐私**，并选择**备份我的数据**，如下面的截图所示：

![设备特定决策](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_09.jpg)

在这里，重要的是要解决 root 过的 Android 设备的问题。root 一个 Android 设备并不需要太多时间，而且相关指导随处可见。在澳大利亚、欧洲和美国，root 设备是合法的。root 过的设备不符合企业使用的安全标准。因此，检测 root 过的设备是设备管理员的一个重要考虑因素。检测 root 过的设备并不容易，因为 root 设备的方法有很多种。

然后，还有一个问题是从哪个应用商店下载企业应用程序。除了 Google Play，Android 应用程序还可以从其他应用商店下载，如亚马逊应用商店和 GetJar。上次我查看时，有超过 128 个应用商店，应用程序可以托管在任何一家。应用程序也可以从网站下载，或者通过电子邮件或侧加载获取。设备管理员可以选择建立一个企业应用商店来解决这个问题。这样可以确保这里只有合法的应用程序。为了从除了 Google Play 以外的外部位置下载应用程序，用户必须明确选择以下截图所示的**未知来源**选项：

![针对特定设备的决策](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_08_10.jpg)

设备管理的核心理念是，设备应该是可用的、直观的，并且在不妨碍安全的前提下保留原生体验。这是一个艰难的平衡，也是一个确定的挑战。

要紧跟 Android 不断进化和充满活力的生态系统，需要一位热爱 Android、对 Android 生态系统的即将到来的变化保持关注的 Android 专家和爱好者。为了保持你的知识是最新的，需要对用户如何与他们的设备互动以及该领域即将到来的创新有敏锐的理解。这位 Android 专家应该成为企业在 Android 设备上部署应用程序的权威和主要联系人。

## 了解你的社区

在此部署中的第二步是了解你的员工队伍的偏好、需求和需要。这一步很重要，以便做出关于你的员工需要哪些应用程序和服务的明智决定，以及需要创建何种访问控制和政策。收集有关他们的设备偏好（他们喜欢手机还是平板电脑）、他们习惯的应用程序、他们在设备上需要的访问量等信息是重要的。另一个因素是地理多样性。没有一种解决方案适合所有情况。不同的地点有不同的首选设备，他们自己的首选应用程序，以及与设备上的企业数据的互动程度。

## 定义边界

明确哪些设备是被接受，哪些不被接受，将有助于处理 Android 的碎片化问题。这些边界应该基于功能而不是版本或发布，因为不同的制造商和运营商会在不同的设备上以不同的方式移植相同版本。

另一个需要定义的边界是信任。公司的**信息技术** (**IT**) 部门应根据设备能力的提升允许增加访问权限。例如，如果一个设备不支持全磁盘加密，它们只能读取数据，而不能将数据存储在设备上。鉴于 Android 开放的 应用生态系统，对用户在设备上安装的应用程序进行定期监控也很重要。

第三种边界是用户可以在其设备上安装的应用程序。Android 应用程序可以从不同的来源安装，这些来源在安全性上并没有像苹果 App Store 那样严格筛选应用程序。定义哪些应用程序允许安装，哪些不允许，将大大有助于保持设备的安全。

### 安卓兼容性计划

开放性是 Android 生态系统的目标。然而，为了在不同设备上提供一致的用户体验，OEM 必须参与 Android 兼容性计划。此计划向 OEM 提供工具和指导，以便他们正确标记设备并确保应用程序按预期在设备上运行。这对于 IT 人员来说是一个有趣的计划，因为他们可以根据兼容性级别定义自己的边界。

兼容性计划提供了三个关键组件：

+   **兼容性定义文档** (**CDC**): 这是关于兼容性的政策文件。它定义了兼容堆栈的要求。例如，它列出了一系列被认为是 Android 堆栈核心的 Intents，并且应该始终得到支持。

+   **兼容性测试套件** (**CTS**): CTS 是一个免费的测试套件，可在桌面上运行，用于在模拟器或设备上自动执行兼容性测试。在撰写本书时，CTS 包括单元测试、功能测试和健壮性以及性能测试的参考测试，未来还有计划增加更多测试。一些例子包括检查硬件特性，比如 Wi-Fi 和蓝牙。

+   **兼容性测试套件验证器** (**CTS Verifier**): CTS 是一个免费的测试套件，在桌面上运行，需要手动输入以在模拟器或设备上运行兼容性测试。它是 CTS 的补充。

根据上述标准，市场上存在三种类型的 Android 设备。以下表格展示了每种兼容性类型的关键特性：

| 谷歌领先设备 | 谷歌体验设备 | 其他（开放）设备 |
| --- | --- | --- |

|

+   纯正的 Android，100%由谷歌引领

+   无 OEM 或运营商定制

+   例子：三星 Galaxy Nexus，摩托罗拉 Xoom，HTC Nexus One

|

+   CTS 合规

+   OEM 和运营商定制

+   应符合谷歌升级承诺

+   例子：三星 Galaxy S11，HTC Rezound

|

+   非 CTS 合规

+   高度由 OEM 和运营商定制

+   例子：Kindle Fire，摩托罗拉 ET1 平板电脑

|

你可能会决定只支持提供一致特性并有一定定制体验的领先设备。

## 推出支持工作

规划分阶段的方法来推出对 Android 设备支持。IT 部门可以先进行试点推广，然后逐渐扩大范围。这有助于两个方面：首先，IT 部门可以确定他们的支持基础设施是否能够随着用户数量的增加而扩展；其次，他们可以根据收集到的使用统计数据调整支持。随着支持范围扩大到更多员工，可以修复任何错误和遗漏的需求。

在此推广过程中，通过培训、维基、海报和警报教育员工，将帮助员工了解正在发生的事情。这也帮助他们理解为什么允许某些设备而排除其他设备，他们可以期待什么，以及如何在设备上安全访问企业数据。

## 政策与合规性

在回顾所有前面的步骤时，不要忽视该领域新兴的标准和合规性。同时，要紧跟 BYOD、MDM 和 MAM 领域的研究进展，以及不同公司采用的创新方法。

### 金融行业监管局（FINRA）

**金融行业监管局（FINRA）** 是美国所有证券公司中最大的独立监管机构。FINRA 的使命是通过确保证券行业的公平和诚信运作来保护美国投资者的利益。他们发布了关于监管其会员公司移动设备电子通信的指导方针。这些方针需要与公司自身的分析相结合来考虑。更多信息请访问 FINRA 的网站：[www.finra.org](http://www.finra.org)。FINRA 发布了三项通知，以应对个人移动设备和社交网站日益增多的情况。在所有情况下，它都建议应对所有员工进行适当的培训，包括维护记录、审慎在社交媒体网站发布内容，以及持续的监管。

FINRA 在 2007 年 12 月发布了他们的第一个监管通知 07-59（[`www.finra.org/web/groups/industry/@ip/@reg/@notice/documents/notices/p037553.pdf`](https://www.finra.org/web/groups/industry/@ip/@reg/@notice/documents/notices/p037553.pdf)）。该通知提供了通过移动设备监管电子通信的核心指导原则。它建议企业电子邮件应始终通过企业电子邮件系统流转，不应通过个人账户转发。这些企业电子邮件应只通过受监控的网络流转。这将使得电子邮件得到适当的监管。

美国金融业监管局（FINRA）在 2010 年 1 月发布的第二份监管通知 10-06，主要关注社交媒体网站和博客的使用（[`www.finra.org/web/groups/industry/@ip/@reg/@notice/documents/notices/p120779.pdf`](http://www.finra.org/web/groups/industry/@ip/@reg/@notice/documents/notices/p120779.pdf)）。该通知建议员工不应在社交媒体网络上使用商业账户。这些网站应持续监控以避免员工发布误导性信息，因为这可能会对投资者产生不利影响。

2011 年 8 月发布的第三份监管通知 11-39，进一步扩展了关于个人设备和社会媒体网站指导方针（[`www.finra.org/web/groups/industry/@ip/@reg/@notice/documents/notices/p124186.pdf`](http://www.finra.org/web/groups/industry/@ip/@reg/@notice/documents/notices/p124186.pdf)）。该通知指出，只要确保信息可检索且与个人通信分离，员工可以使用个人设备进行通信。对设备的持续监督和培训至关重要。

### 安卓更新联盟

遵守标准并不总是容易的。在 2011 年 5 月的 Google I/O 大会上，谷歌与许多其他设备制造商承诺，将在任何新版本安卓发布后的 18 个月内更新设备。这个联盟被称为安卓更新联盟。这个想法很高尚，受到了好评，但原始设备制造商（OEM）很难跟上这一承诺。

# 摘要

在本章中，我们重点关注了公司及员工所有访问企业数据的设备的管理。携带个人设备办公（BYOD）面临的问题包括信任、合规性、治理和隐私，因为越来越多的员工要求在他们的移动设备上访问企业数据。用户体验与安全之间需要精妙的平衡。我们从复杂的安卓生态系统开始，接着讨论设备管理的实施细节以及安卓堆栈提供的企业其他功能。我们以关于合规性和政策的讨论结束本章，并考虑下一步如何在企业领域支持安卓。

现在，是时候进入下一章，从安全的角度讨论测试安卓应用程序。祝阅读愉快！


# 第九章：安全测试

这无疑是本书最重要的章节。作为开发者，我们都在努力编写优美、可用且安全的代码。我们都体验过伟大想法的兴奋和看到它实现的冲动。我们的工作安排和截止日期也常常很疯狂。因此，出现 bug 是自然的，而 bug 测试是任何编码生命周期的一部分。

目前大多数测试用例关注于可用性、功能性和压力测试。在大多数情况下，当涉及到安全测试时，测试工程师往往不知所措。当合规性和安全被忽视时，有时应用程序需要重新设计或实现。以创建消息摘要为例，用于确保完整性。开发者可能会选择 SHA-1，它产生一个 160 位的摘要。在服务器端，数据库被设计为容纳 160 位数据。一个非道德的黑客入侵了应用程序。在进行安全审查时，决定 SHA-1 对于该用例来说不够强大，需要更新到 SHA-256。由于数据库仅被设计为容纳 160 位，因此在客户端快速修复变得具有挑战性，因为整个设计必须改变。事情现在变得严重了。尤其是在考虑到移动生态系统快速发展和变化的情况下，这真是浪费时间。

本章节旨在介绍以安全为重点的测试概念。章节首先概述了测试。如果你已经熟悉测试，可以轻松跳过这一部分。下一节将讨论安全测试以及你可以如何测试应用程序的安全性，即安全审查、手动测试和利用工具的自动化测试。接下来的部分讨论一些可以作为编写测试基线的安全测试用例示例。章节最后讨论了开发者和测试工程师在开发测试用例和进行安全测试时可以使用的一些工具和资源。

# 测试概述

由于设备能力、外形和版本的不同，Android 是最具挑战性的操作系统之一进行测试。即使是获取基本的功能和用户体验本身就是一个挑战。下图说明了通常在 Android 应用程序开发背景下执行的测试。正如我们这个时代伟大的密码学家 Bruce Schneier 恰当指出的那样，“安全不是一个产品，而是一个过程”，因此你会注意到，我已经将安全测试添加到应用程序测试的整个生命周期中。

![测试概述](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_01.jpg)

让我们花点时间了解从 Android 的角度看，单元测试、集成测试和系统测试各自的含义。

+   **单元测试**：在大多数情况下，编写模块的开发人员也会开发单元测试。开发人员在将代码交给测试工程师之前，应该编写并单元测试他们的模块。Android SDK 附带了用于单元测试的仪器化 API。这个框架是基于 JUnit 实现的，JUnit 是 Java 单元测试中一个流行的框架。单元测试可以很容易地自动化。这些测试涵盖了边界测试、输入验证测试以及与后端的连接测试。

+   **集成测试**：单元测试完成后，不同的组件开始集成时，进行集成测试以确保不同的组件能够协同工作。这些测试是在组件捆绑在一起时执行的。设想有两个团队分别独立工作，一个负责登录模块，另一个负责搜索结果页面。一旦模块开发完成并且它们被集成在一起，就应该执行测试，检查这两个模块的组合。如今，大多数开发环境都使用持续集成来执行一些基本的健全性测试，以确保这两个模块能够一起编译。

+   **系统测试**：这些测试针对整个应用程序以及应用程序与 Android 平台的交互进行测试。系统测试的一些示例包括在不同平台上测试搜索功能以及基于 Android 的设备差异如何影响搜索结果的显示。

    安全测试应该在测试的每个阶段执行。例如，在单元测试级别，开发人员应该测试不一致和错误的输入值、缓冲区溢出以及用户的访问级别。

    在集成级别，工程师可以测试两个模块之间安全数据传输以及传递错误数据时的行为。

    在系统测试阶段，工程师可以测试他们的应用程序在不同 Android 平台上的外观和行为。在 Android 的情况下，由于不同厂商和运营商的 Android 设备和堆栈能力存在差异，这一阶段尤为重要。

    流程中提到的任何测试套件通常都包含不同类型的测试混合。这些在以下图中有所说明。请注意，我再次在混合中加入了安全测试。

    ![测试概览](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_02.jpg)

+   **功能测试**：这类测试检查应用程序是否表现出预期行为。例如，登录功能的功 能测试将检验用户输入用户名和密码并按下*回车*的情况；如果凭据有效，用户将能够登录系统，否则将显示错误。你可能还想验证在不同错误情况下是否生成了正确的错误消息。

+   **本地化测试**：如今，大多数应用程序都是全球性的，在不同的国家可用。为了支持不同的地区，应用程序必须进行本地化和国际化。本地化指的是语言翻译，而国际化是指根据特定地区的规范调整应用程序。例如，考虑一个适应接受日语地址的视图的情况（即你想支持日本作为国家）。本地化会将地址行 1、地址行 2、城市、州、邮编和国家翻译成日语对应的内容。然而，在日本，地址系统与罗马系统不同，接受地址的视图将不得不重新设计，一些标签可能需要重新排列。

    安卓有一个非常用户友好的框架，用于存储字符串和本地化视图，开发者应该充分利用这一点。在新的市场推出应用程序时，最好咨询本地化专家的意见。

+   **可用性测试**：也称为 UI 测试，这些测试关注用户界面的外观和感觉，确保用户能够轻松输入、在屏幕上阅读信息，以及改变应用程序的美观和总体流程。在屏幕空间受限的设备和不同屏幕尺寸的设备上，可用性非常重要。

+   **硬件兼容性测试**：这一系列测试将针对在不同设备上测试应用程序中使用的硬件特性。例如，如果一个应用程序使用了设备相机，就应该进行测试，以检查代码是否在不同设备相机和不同的对焦能力下正常工作。

+   **回归测试**：这些通常是自动化测试，在应用程序每次更改后运行，以确保应用程序仍然按预期工作。例如，在书店应用程序中，您可能会确定关键功能，如登录、登出、搜索书籍以及将书籍添加到愿望清单。每当添加新功能或更新现有功能时，都会执行这些健全性测试，以确保没有破坏任何功能。

以下各节将详细讨论安全测试。

如您所料，这些测试案例中的大多数是相互协作的。例如，要测试新国家的地址页面，本地化和 UI 测试必须同时进行。

# 安全测试基础

本章节概述了安全测试。我们讨论了可以围绕其开发安全测试的安全支柱。第二部分讨论了不同类型的安全测试。

## 安全原则

任何类型的应用程序安全测试都应遵循安全的六个原则，即认证、授权、可用性、保密性、完整性和不可否认性。我们在第六章，*您的工具 – 加密 API*中涵盖了这些概念的大部分内容以及如何实现它们。

![安全原则](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_03.jpg)

*认证*是识别用户的措施。你可以使用来自 Facebook、Twitter、LinkedIn 和 PayPal 等公司的认证 API。主要使用的协议是 OAuth 和 OpenID Connect。这些技术将认证任务从应用程序中卸载。这对于应用程序开发者和用户来说都是一个双赢的局面。应用程序开发者不需要实现自己的方案，可以使用内置的认证机制。用户不需要与不信任的应用程序共享个人信息。这对于开发此类方案的公司来说非常有用，因为它可以引导流量到他们的网站。这些技术大多数基于为用户提供一个认证令牌。

第十章，*展望未来*，讨论了认证方面的一些新进展。

授权是指访问控制——确定用户是否有适当的权限来访问资源。在 Android 的情况下，这可以通过保护应用程序组件的权限并在可能的情况下检查调用者身份来实现。

*可用性*意味着数据应在需要时对授权用户可用。使用带有数据的广播和意图可以确保这一安全措施。

*保密性*是指确保数据安全，只向预期的方透露数据。对数据加密、使用适当的权限、并符合 Android 沙盒可以帮助实现这一安全措施。

*完整性*意味着数据在传输或静态存储过程中未被修改。如果数据被篡改，这种篡改可以被识别出来。添加消息摘要、数字签名以及无论是在传输过程中还是静态存储时对数据进行加密，都可以帮助保持数据的完整性。

*不可否认性*可以通过使用数字签名、时间戳和证书来实现，确保发送方不能否认发送数据。在第六章，*你的工具 - 加密 API*中讨论的 DRM（数字版权管理）被实施，以使用户不能否认接收内容。

## 安全测试类别

在牢记刚刚讨论的安全原则的基础上，安全测试可以分为三个类别：应用程序审查、手动测试和自动化测试。

### 应用程序审查

安全测试的第一步是应用程序审查过程。这个过程关注于理解应用程序，并识别应用程序所使用的硬件、不同技术和功能。一旦识别出这些特性，审查者就会尝试访问这些功能中的安全漏洞。审查过程识别出的问题包括清单文件中明显的问题、使用破损或弱加密、协议的不安全使用以及在开发过程中可能遗漏的技术和硬件安全问题。它涵盖了合规性和标准，以及是否适当遵守了这些标准。

在清单文件中可以识别的一些安全问题示例包括：清单文件中不必要的权限，应用程序实际上不需要但为了调试目的而添加的权限，未使用权限保护组件，忘记关闭调试模式，以及日志语句等。

合规性基于用例。根据应用程序编写的用例，应用不同的标准。例如，支付和商务用例应用程序可能会关注 PCC-DSS 标准。基于地理位置的应用程序则必须注意隐私问题。

目前有一些专门从事移动应用程序审查过程的安全审计公司。如果你有疑问，应该使用这些公司。

### 手动测试

如其名称所示，手动安全测试是在开发过程中或由测试工程师手动完成的。工程师通过输入不同的数据来观察应用程序在不同场景下的行为。例如，查看日志以验证没有敏感信息泄露，多次返回上一个活动以观察应用程序的表现，尝试破坏应用程序的认证方案，以及检查用户是否具有适当的访问权限。无法自动化的场景也属于这一类。有一些公司如 uTest（[www.utest.com](http://www.utest.com)）雇佣手动测试人员可以为你的应用程序执行手动测试。

### 动态测试

也称为自动化测试，这些测试理想情况下是通过编写测试脚本来执行的。如输入验证、压力测试、模糊测试和边界测试等测试可以很容易地自动化。这些测试大多数可以轻松地成为标准开发/测试周期的一部分，并在添加新功能时作为健全性测试。你可能会决定使用专门从事此领域的安全公司的服务，如 Device Anywhere（[www.deviceanywhere.com](http://www.deviceanywhere.com)）。

# 样本测试案例场景

在本节中，我尝试列举了一些从安全角度出发有趣的样本测试案例。它们没有特定的顺序，你可以在为特定用例识别测试案例时参考它们。

## 服务器端测试

移动生态系统非常有趣；它年轻且仍在不断发展。应用程序可能希望将数据发送到服务器，但服务器接收到的内容可能大相径庭。这可能是因为通信通道出现问题，黑客窃听并更改传输中的内容，或者是因为客户端的问题。无论原因是什么，仅测试应用程序是不够的，服务器测试对你的应用程序的安全性至关重要。这些测试关注的是服务器端是否接收到了预期的内容，PII 是否以明文形式存储在服务器上，如果业务逻辑驻留在客户端，那么它是否正常工作。我们在第六章，*你的工具 - 加密 API*中讨论了这一点。

这个测试领域已经成熟，并且有大量的示例和工具可用于服务器端测试。使用像 Nmap 这样的端口扫描工具可以轻松检查开放端口和防火墙。

## 测试网络

基础设施层是移动设备的支柱，使移动性无处不在。它也带来了新的挑战和测试案例。设备使用不同的协议与服务器通信，每种协议都带来独特的安全漏洞。GSM 容易被破解；Wi-Fi 本质上不安全，特别是当你连接到恶意热点时。**长期演进**（**LTE**）是一种新的高速无线数据通信标准，基于 IP 但尚未经过彻底测试，而 NFC、蓝牙和 RFID 等邻近技术带来了完全不同的测试范式。因此，测试你的应用程序所使用的技术并围绕它构建测试案例是非常重要的。

## 保护传输中的数据

如果你的应用程序使用**传输层安全**（**TLS**），这是好的，但请确保它被正确实施，因此需要测试它。测试客户端和服务器之间的所有通信是否都已加密，并且没有 PII 或密钥在明文中传输。记住，序列化不是加密，混淆也不是加密。确保服务器正在检查证书验证和证书过期。检查所使用的加密算法和协议是否当前、对于你的用例足够安全。

## 安全存储

将敏感数据如私钥、用户名、密码及其他个人识别信息（PII）存储在客户端始终不是一个好主意。理想情况下，这些信息应当存储在服务器上。将密钥与它加密的数据一起存储违背了安全的目的。如果必须在客户端存储密钥，首先，它们不应当以明文形式存储；其次，它们不应当存储在文件、缓存文件或共享首选项中。密钥应当存储在`keystore`中，密码在`AccountManager`中，所有敏感信息应以加密方式存储。在大多数情况下，可以存储哈希值而不是密码。

## 行动前的验证

验证在不同应用程序组件之间以及来自其他应用程序传递的输入、数据和调用者。任何 Activity 都可以在 Intent 中封装任何类型的数据，而接收组件有责任在采取行动之前进行测试和验证。我们在第二章中详细讨论了这一点，*应用程序构建块*。在这种情况下，测试将包括向组件传递无效和错误的数据，并观察它的行为。

在某些情况下，你可能可以在处理来自他们的请求之前检查调用者的身份。使用它！特别是在启动敏感操作之前，检查调用者身份和你将要处理的数据。

## 最小权限原则

这类测试包括检查不同应用程序组件的权限，并确保它们具有正常功能所需的最小权限。这包括检查文件、缓存文件和`SharedPrferences`的可见性和可访问性权限。检查它们是否真的需要`MODE_WORLD_READABLE`或`MODE_WORLD_WRITABLE`权限。

检查你的应用程序请求的权限。例如，如果你不需要精确的位置访问权限，只需请求粗略的位置权限，如果你只需要读取短信，就不要请求读取和写入短信的权限。随着消费者对移动领域安全问题的认识不断提高，如果应用程序请求的权限没有意义，他们可能会对你的应用程序产生怀疑。对于浏览图书的应用程序来说，访问用户联系人列表和设备摄像头是没有意义的。

## 管理责任

了解你所在领域的规则和法规。涉及责任诉讼是一件麻烦的事，最好避免。另外，如果使用专门处理这些问题的第三方工具和服务是有意义的，那么请务必使用它们。如果你的应用程序收集用户数据，请确保你已经从用户那里获得了适当的同意，并且你收集的所有内容都已列出。例如，加州在线隐私保护法案规定，如果一个应用程序在加州收集信息，那么它应该被公开。

让我们以一个处理支付的应用程序为例。不要试图自己开发，而应使用现有的支付解决方案，如 PayPal。支付处理涉及用户的资金，有诸如 PCI-DSS 这样的指导方针来规定如何使用这些功能。

同样，与其设计和开发自家的安全算法和协议，不如使用经过时间和行业测试的安全套件和库。

了解你的应用程序在支持的国家将如何被使用。不同的国家有不同的规则和法规。个人识别信息（PII）的定义也有所不同。

## 清理

首先，不要记录敏感信息。在将应用程序发布到野外之前，确保关闭调试。从文件、cookies 和缓存中清理所有敏感信息；即，清零内存。

## 易用性与安全性的权衡

平衡易用性和安全性是一门棘手且微妙的艺术。应用程序可能为了方便而持久保存用户名、密码和会话令牌，但这也会使安全性降低。如果你的应用程序中有记住用户身份的功能，要权衡便利性和安全性。你可能决定限制会话长度，以及限制保持 cookies 和令牌存活的时间。

## 认证方案

这里的问题是，你是想要验证设备还是用户？设备可能会丢失或被盗。基于设备特性如 IMEI、IMSI 或 UDID 来识别用户可能不是一个很好的验证方案。这些会导致远程擦除和重置。你可能需要评估基于生物特征的验证机制或双因素验证方案来验证用户。

## 以黑客的思维思考

以黑客的思维去测试，想象他们会如何尝试攻击你的应用程序。利用互联网上已有的工具和漏洞。使用黑客的工具进行测试可以揭示黑客在试图破解你的应用程序时能看到什么，能得到什么信息。有一些工具，比如 Fiddler （[www.fiddler2.com](http://www.fiddler2.com)），你可以用来监控应用程序的网络流量。重要的是要记住，混淆代码并不是安全。

## 谨慎集成

无论是与硬件（内部和外部）还是第三方应用程序集成，都要小心谨慎。

如果应用程序使用了某些硬件组件，如摄像头、蓝牙、NFC 芯片、加速度计、麦克风或 GPS，那么测试它们的安全性也很重要。任何硬件的缺陷都可能影响应用程序的整体安全性。

同样，第三方库中的错误可能导致应用程序受到威胁。在与这样的外部库集成时，要求查看他们的测试结果，在线查找并寻求推荐。

# 安全测试资源

本节重点介绍可以创造性地用于测试应用程序安全的工具、技术和其他资源。

## OWASP

**OWASP**（**开放网络应用安全项目**）是一个致力于移动安全的组织。它们在移动安全领域提供工具和研究。查看它们的网站 [`www.owasp.org`](https://www.owasp.org)。这是寻找与安全相关问题的好地方，为开源贡献，创新并参与移动安全讨论。OWASP 每年都会整理一份十大安全漏洞列表，并挑战社区去解决这些问题。

## 安卓工具

Android 提供了一系列可以创造性地用于测试应用程序的工具。除了测试，这些工具还可以帮助开发者调试他们的应用程序。

### Android 调试桥

**Android 调试桥**（**ADB**）可用于日志、内存检查等多种用途。你可以在开发者网站上查看 ADK 提供的完整功能列表。下方的截图展示了一些 ADB 的使用示例：

![Android 调试桥](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_04.jpg)

之前的截图展示了使用`adb logcat`命令的示例日志。

### 设置设备

为了设置用于监控 Web 应用程序的高级设置，你可以开启高级功能，以便在渗透测试期间获取更多数据。

![设置设备](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_05.jpg)

之前的截图显示了如何启用 JavaScript 和插件来检查信息泄露。

### SQlite3

使用 SQLite3 工具，用户可以探索它创建的数据库以及一些与平台捆绑的其他数据库。

SQLite 工具允许用户查询数据库并检查数据库中的值。这种数据库的查询和检查可以指出诸如以明文存储 PII 等问题。

### Dalvik 调试监控服务

**Dalvik 调试监控服务**（**DDMS**）是 Android 框架提供的另一个重要工具。DDMS 提供了如端口转发、屏幕截图、线程和堆信息、`logcat`进程、以及无线电状态信息、来电和短信欺骗、位置数据欺骗等功能。下方的截图展示了 DDMS 的窗口。你可以在 Android 开发者网站上查看这些功能的具体详情。

![Dalvik 调试监控服务](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_06.jpg)

还有一些其他第三方工具，如由 iSecPartners 开发的 Intent Sniffer 和 Manifest Explorer（[`www.isecpartners.com`](https://www.isecpartners.com)）。其他 Linux 工具如`strace`和`procrank`也可以使用。你可以使用下面章节讨论的 BusyBox 来实现这一目的。

## BusyBox

BusyBox 被称为嵌入式 Linux 的瑞士军刀，提供了许多 Unix 工具，如`vi`、`whoami`、`watchdog`等。这些工具可以在不 root 手机的情况下用于测试。在 Android 上安装 BusyBox 非常简单。只需从[www.busybox.net](http://www.busybox.net)下载即可。

![BusyBox](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_07.jpg)

如前一个截图所示，`busybox`可以轻松地推送并安装。安装后，可以轻松执行 Linux 命令。

## 反编译 APK

反编译 APK 并阅读其内容相对简单。进行这项练习可以帮助你理解黑客将如何接近你的 APK。

APK 文件实际上只是一个 ZIP 文件，将 APK 文件重命名为 ZIP 文件后，你可以使用任何 ZIP 文件浏览器打开它。这些文件位于`/data/app`目录下。你可以使用`adb pull`命令将其拉到你的机器上。在其中，你可以看到清单文件、资源、资产以及其他文件。

![APK 反编译](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_08.jpg)

接下来，使用 Android 提供的`dexdump`工具，可以转储`/data/dalvik-cache`目录下的类。

![APK 反编译](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_09.jpg)

举个例子，要将`data@app@com.example.example1-1.apk@classes.dex`转储到一个名为`dump`的文件中，需要使用的命令是：

```kt
dexdump –d –f –h data@app@com.example.example1-1.apk@classes .dex > dump

```

以下是在转储文件中收集的数据类型的截图：

![APK 反编译](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603OT_09_10.jpg)

这个转储将以跳转语句的形式出现，难以阅读。可以使用如`baksmali`或`dedexer`这样的 DEX 反编译器，使这些文件更具可读性。

# 总结

安全测试是一个相对较新的领域。模式和测试策略仍在发展中，安全已成为识别应用弱点、提高应用质量的重要基准。在本章中，我们将之前所有章节的学习成果汇集起来，用它来定义应用程序的测试用例。这只是一个开始，你应该根据你的使用情况，定义你认为合适的测试用例。

我们首先概述了测试的基本原理。然后，我们讨论了围绕六个安全支柱设计的测试用例。我们讨论了一些示例测试用例，这些用例应该为你测试应用程序提供了一个基础。最后，我们讨论了你可以用于以安全为重点的测试资源和工具，以此结束了这一章节。

现在让我们走向本书的最后一章，看看在 Android 领域有哪些新的挑战在考验我们的安全基础知识。


# 第十章：展望未来

恭喜你阅读到了最后一章！那么让我们在这一章中找些乐趣，尝试预测未来。

移动是一个相对较新的领域。它正处于实验阶段，一些技术和用例取得了成功，而其他技术可能没有得到预期的那么多的关注。本章的重点是研究移动领域内一些新技术和用例。

本章分为多个部分，每部分讨论了在移动领域对某些技术或用例的实验。我们将从移动商务的讨论开始，重点关注产品发现、支付和利用移动设备进行销售点的操作。接下来将讨论近距离技术，如 NFC、RFID 和蓝牙。接下来的部分将谈论移动设备在医疗保健和身份验证方面的应用。在最后一节中，我们将从安全的角度讨论硬件方面的最新进展。

# 移动商务

消费者行为正在改变商务模式。如今，商务已不再仅仅是到商家或商店选购产品并付款的简单行为。如下所示，随着新技术的出现，移动商务包括使用地理围栏进行产品发现、店内和在线研究、通过自助扫描和自助结账进行支付、与朋友分享购买内容，以及管理账户。我们也看到在线和离线商务之间的界限越来越模糊。

![移动商务](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_01.jpg)

在接下来的几节中，我们将从安全的角度讨论商务的不同组成部分。

## 使用移动设备进行产品发现

产品发现是寻找产品的过程。商家使用不同的机制，要么吸引顾客到实体店，要么鼓励他们在线购买。产品发现还包括如购物清单、比较购物和有关产品的信息等功能，这些都有助于消费者购买产品。移动设备非常适合这种用例，因为消费者可以实时获取产品信息并检查产品的可用性。

移动领域的一些示例应用包括条形码扫描、基于位置的购物、有针对性的广告、用户进入零售店时所获得的积分和优惠、创建购物清单并在消费者接近拥有购物清单商品的商店时提醒他们，以及将会员卡存储在钱包中的能力。

从安全的角度来看，最大的挑战是隐私问题。针对性的广告和地理围栏是基于对用户数据及其购物模式的分析。应用程序开发者在使用和收集用户数据及偏好时，应了解相关法律法规，并在使用或共享数据时遵守这些法律法规。在几乎所有情况下，收集信息之前都需要用户同意。此同意声明应包括正在收集的内容以及是否将与第三方共享。在添加新功能或更新或扩展现有功能时，请注意更新此用户同意。

## 移动支付

支付是移动商务中最大的组成部分。在任何支付用例中，都有三个主要实体：消费者（也称为买家）、卖家或商家以及支持支付的基础设施层。

### 配置

消费者可能正在使用移动设备搜索并支付产品，商家可能正在使用移动设备，或者消费者和商家可能都在使用移动设备。理想情况下，在交互期间这三个实体都应该连接。这是完全连接的情况，到目前为止，这是支付的最安全渠道。用户从 eBay 的移动网站购买商品是一个完全连接的例子，如下面的图所示：

![配置](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_02.jpg)

然而，在某些情况下，它们可能会断开连接。当消费者和商家都连接到基础设施，但彼此之间并未连接时，这就是以基础设施为中心的连接性案例。一个例子是地理围栏，当用户靠近商店时，他们会收到商店的优惠券。在这种情况下，商店和用户都在与基础设施对话（第三方或运营商），但彼此之间并未交流。另一个案例是用户通过使用销售点终端的设备结账。在这种情况下，用户将设备用作身份验证机制，但不一定连接到基础设施层。这是以商家为中心的连接性案例，商家连接到消费者和基础设施，但消费者断开了连接。还有一种情况是，消费者同时与基础设施和商家对话，但商家断开了连接。例如，当用户从自动售货机购买苏打水时，售货机可能会在特定时间间隔与后端同步，否则可能会断开连接。以下图示了部分连接配置：

![配置](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_03.jpg)

在部分连接中，基本的 security 挑战是端到端的安全问题。由于在任何时候都只有三个连接中的两个，客户端或服务器端的任何陈旧状态都很难被检测到。然后，还有客户端-商家身份验证、通信认证和隐私问题，如下面的图所示：

![配置](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_04.jpg)

然后还有一种断开连接的情况，即商家和消费者相互交流，但没有人与基础设施层交流。在这种情况下，维护设备的完整性是一个挑战。以消费者在销售点终端尝试使用优惠券为例。

消费者可能会继续多次使用优惠券，而无法与服务器同步以更新优惠券状态的**PoS**（**销售点**）终端将无法检测到欺诈行为。同样，客户端证书可能已经过期或被撤销，但商家设备将不会意识到这一点。如果你的应用程序被设置为在这样的场景下工作，那么离线应该只有有限的功能集。涉及 PII 或金钱的情况最好是完全连接或至少是部分连接的情况。

作为一名应用程序开发者，应该了解你的用例是如何工作的。如果你的应用程序可以在部分或无连接的情况下工作，那么在处理支付时你需要采取额外的安全措施。

### PCI 标准

**支付卡行业**（**PCI**）是一个独立组织，致力于提高支付用例中安全性的意识。他们开发了一套通用的支付标准，以确保用户安全不受损害。PCI **PTS**（**PIN 交易安全**）适用于接受支付的附加设备；PCI **P2PE**（**端到端加密**）适用于基于硬件的安全，而 PCI **DSS**（**数据安全标准**）适用于安全管理、政策、程序、网络架构、软件设计以及其他关键保护措施。最新的版本是 2.0，它帮助组织有效地保护用户数据。它有六个核心目标，作为十二个核心要求实施。这些在以下图表中列举：

![PCI 标准](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_05.jpg)

作为处理支付的应用程序开发者，应该了解 DSS。支付是复杂的，以安全的方式正确处理支付本身就是一项挑战。因此，你可能希望使用现有的支付提供商，例如 PayPal。

关于 PCI 的更多信息可以在他们的网站 [pcisecuritystandards.org](http://pcisecuritystandards.org) 上找到。

### 销售点

移动销售点（PoS）是随着移动设备的普及和本章前面讨论的邻近技术的使用而变得可行的一种应用。你的移动设备本质上充当销售点终端，可以管理你的账本和当天的所有交易。像 PayPal 和 Square 这样的公司提供的解决方案使用手机音频插孔来接入刷卡设备。该设备读取信用卡详细信息，并以加密形式将其发送到设备上。其他解决方案还包括移动销售点终端。

作为应用开发者，最好是与现有解决方案集成，而不是试图重新发明轮子。但是，在选择解决方案之前，记得要问一些问题。首先，你需要询问解决方案提供商是否采取了适当的安全措施来加密数据。请注意 PCI DSS 和 PCI PTN，正如我们在前面的章节中讨论的那样。处理、存储或传输信用卡号码的零售商必须符合 PCI DSS 标准，否则他们可能会失去处理信用卡支付的能力。由于不同国家之间的信用卡基础设施存在差异，必须采用不同的技术来读取信用卡/借记卡。例如，在欧洲，芯片和密码技术是标准，因此你的 PoS 支付提供商应该在各个领域都有解决方案。你可能希望选择一个提供商，通过它可以管理你的信用卡以及支票、现金和其他形式的支付。

![销售点](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_06.jpg)

前一个图展示了一些移动销售点解决方案的例子。第一张图片是北美地区的 PayPal 卡片阅读器及其管理的所有支付模式的应用程序。

![销售点](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_07.jpg)

前面的图片是 PayPal 在欧洲使用的密码和芯片解决方案，它通过使用蓝牙工作。

![销售点](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_08.jpg)

上图是另一个移动销售点的例子。通常由快递员和销售代表使用。

# 近距离技术

近距离技术在几英寸或厘米的范围内工作。这些技术包括**近场通信**（**NFC**）、蓝牙和**射频识别**（**RFID**）。这些技术中的大多数已经存在了一段时间，但移动设备的普及为它们带来了许多新的使用场景。这些技术现在被用于移动支付、不同设备的配对、识别和认证。

蓝牙现在已经成为大多数手机的标准。这是一项将设备配对的好技术。随着市场上出现如眼镜和手表等设备，这可能是将它们连接在一起的技术。

NFC 和 RFID 都通过产生在一定频率上调制的电磁场来工作。由于这些标签是全球可读的，当它们被用作标签或识别机制时，这些标签会带来隐私风险。第一部支持 NFC 的 Android 手机，Nexus S，在 2010 年推出。Android SDK 附带了使用 NFC 标签的 API。

由于操作范围有限，近距离技术被错误地认为是安全的。然而，事实并非如此。快速搜索将揭示所有情况下的攻击场景。数据调制、数据干扰和隐私是与这些技术相关的一些风险。

# 社交网络

目前应用商店中存在着大量的社交网络应用，并且每天都有新的使用案例在测试中。这些应用程序让朋友、熟人、邻居、同事以及有特殊兴趣的人们能够分享、协作，并基本上保持相互之间的联系。一些成功的例子包括 Facebook、Twitter、Pinterest、Google Hangout 和 LinkedIn。

社交网络作为将实体联系在一起的网络的图形。图中的任何不良节点都有可能对其他节点进行垃圾信息攻击或感染。在下图中，节点 A 和 B 之间的消息被拦截并替换为垃圾信息。这将导致所有连接到 B 的节点被感染。这种情况会持续，如您所想，会迅速在节点间传播：

![社交网络](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_09.jpg)

社交网络应用最大的挑战是隐私问题。首先，用户必须注意他们与联系人分享了什么。在大多数情况下，用户使用的是他们的真实姓名和其他私人信息。

其次，用户需要意识到垃圾信息和恶意软件的存在。不是每个人都是你的朋友。你的朋友们玩的游戏并不都是由好人编写的。也没有必要点击你关注的人分享的所有链接。

第三，应用开发者必须注意他们如何存储和处理用户的敏感信息。第一道防线是明确询问用户他们想分享什么以及与谁分享。这种用户同意可以保护开发者免受责任问题的困扰。其次，他们必须根据用户偏好定义适当的访问控制。第三，他们必须保证用户的详细信息和个人识别信息（PII）在静态存储和传输过程中都是安全的。

社交网络网站的另一个问题是身份盗窃。恶意用户很容易通过使用他人的身份来创建账户。

# 医疗保健

开发医疗保健的移动应用程序是另一个非常注重安全的使用案例。在医疗保健使用案例中，开发者需要处理用户身份识别、电子病历、实验室检测和处方药物。泄露这些信息可能会影响患者的健康。

移动设备在医疗保健方面可以发挥巨大作用，因为它们非常个人化，我们始终随身携带。因此，提醒我们按时服药、就诊、为医生和患者记笔记的应用程序、即时通知实验室结果以及提醒处方药物需要重新配药的应用程序都是重要且有用的。

在紧急情况下，移动设备也可以被用来帮助患病的人，用户可以通过移动设备实时分享视频并实时与医生交谈以获得帮助。

医疗保健开发的另一方面是在嵌入式设备中使用 Android 平台，例如扫描仪、放射学、X 光机、机器人手术和超声波设备。

在医疗保健中准确识别一个人至关重要。还要记住一个重要的安全规则：信任但要验证。因此，你识别了一个人，但想再确认一次以确信。访问控制和个人识别信息（PII）的安全存储和传输同样重要。

了解医疗保健领域的标准和规定，例如**健康保险携带和责任法案**（**HIPAA**）。

# 认证

认证是识别实体的行为。在我们的案例中，认证通常与识别一个人有关。当前的认证方法是使用用户名和密码。由于密码复杂，在小设备上输入困难，因此通常使用电话号码和个人识别码（PIN）来认证用户。

## 双因素认证

当前最常见的方法是双因素认证。这是基于这样的理论：为了唯一识别一个人，该人应提供以下三个标识符中的两个：

+   用户拥有的东西；这包括数字签名、安全令牌、电话、标签等。

+   用户知道的东西；这包括密码、秘密、PIN 或只有用户才应知道的问题的答案。

+   用户自身的东西；例如视网膜扫描、指纹和面部识别。

双因素认证的一个例子是使用用户名/密码或电话/PIN 登录，然后输入发送到用户设备的短信中的秘密代码。另一个例子可能是输入用户名和密码，然后回答如下图像所示的挑战问题：

![双因素认证](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_10.jpg)

在 Android 上实现双因素认证很容易。谷歌认证器通过使用短信或语音通话来实现双因素认证。

## 生物识别

生物识别认证是使用用户的生物学属性来识别用户。这些包括使用指纹、面部识别、视网膜扫描和虹膜扫描。基于虹膜扫描，印度实施了世界上最大的识别系统，称为 Aadhar。这个雄心勃勃的项目将使用所有五岁及以上印度公民的人口和生物识别信息为他们提供唯一的编号。查看**印度唯一身份认证机构**（**UIDAI**）的网站，网址为 [www.uidai.gov.in](http://www.uidai.gov.in)。

安卓上有些应用程序使用生物识别作为关键。使用此类应用程序时的重要考虑因素是确保用户识别规格没有存储在设备上。其次，如果这些信息存储在服务器上，它们是如何传输和存储的？第三，你如何访问这些信息？

### 提示

生物识别技术与可以轻松更改密码或更新 RSA 安全令牌的双因素认证不同。生物识别技术是个人信息，泄露这些信息会带来巨大风险。

有两种场景会使用生物识别。在第一种情况下，通过使用一些生物学属性（如指纹）来验证用户。这会与设备中存储的副本进行比对。使用面部登录手机就是验证的一个例子，如下所示：

![生物识别](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_11.jpg)

第二种情况是识别，其中生物识别身份与数据库中存储的身份进行比对以找到匹配项。印度正在实施的生物识别身份识别系统就是一个例子。下图说明了这个过程：

![生物识别](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_12.jpg)

# 硬件方面的进步

移动操作系统已经取得了长足的进步。当我开始从事移动设备工作时，我们使用的是功能仅限于打电话和基本工具（如计算器和显示时间和日期的小部件）的糖果棒形状的手机。为了支持移动设备的高级用例，必须在硬件本身构建安全性。我将在以下各节中讨论这方面的一些努力。

## 硬件安全模块

硬件安全模块，也称为安全元件，是嵌入硬件中的一块硬件（芯片），用于存储加密密钥和其他敏感信息。这个想法是提供一个隔离的、防篡改的环境来存储 PII（个人识别信息）。在某些情况下，安全元件也可以随设备携带。安全元件的例子包括由移动网络运营商控制的增强型 SIM 卡、嵌入设备本身的芯片，或带有特殊电路的微型 SD 卡。许多 Android 手机都配备了安全元件。

在某些情况下，安全模块还可以作为安全加速器工作。这些加速器除了存储密钥外，还在硬件中执行加密功能，如加密、解密、散列和随机数生成。这大大减轻了 CPU 的负担，从而提高了性能。

为了让开发者能够使用安全元件，必须通过 API 将其暴露出来。Android 的**安全元件评估工具包**（**SEEK**）就是朝这个方向迈出的一步。基于开放的移动 API，这套被称为智能卡 API 的 API 的目标是提供一种机制，让应用程序能够与嵌入式安全元件、SIM 卡或其他设备加密模块进行通信。更多信息可以在[code.google.com/p/seek-for-android](http://code.google.com/p/seek-for-android)上查看。以下来自[code.google.com](http://code.google.com)的图片非常有效地说明了 SEEK 的概念：

![硬件安全模块](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_13.jpg)

基于 Android 的权限机制，智能卡 API 需要一种特殊权限，称为 `android.permission.SMARTCARD`，以便应用程序访问这些 API。智能卡 API 远程进程注册了智能卡唯一的 UID/GID。请注意，这种安全机制在已获得根权限的设备上不再起作用。`GoogleOtpAuthenticator` 是使用双因素认证在智能卡 API 上实现的。

## TrustZone

由 ARM 开发，现在与 GlobalPlatforms 合作，TrustZone 技术是设备的安全解决方案。它基于系统芯片，TrustZone 为应用程序（如支付、内容流和管理、访问控制以及其他 PII）提供了一个可信执行环境。TrustZone 的酷炫功能是每个应用程序都在其自己的封闭环境中运行，完全与其他应用程序隔离。

你可能想访问[www.arm.com/products/processors/technologies/trustzone.php](http://www.arm.com/products/processors/technologies/trustzone.php)网站了解详细信息。以下来自前述网站的画面展示了这项技术的高级视图。许多移动处理器，例如德州仪器和 Nvidia 的 Tegra 核心，都是基于 TrustZone 技术构建的。

![TrustZone](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_14.jpg)

如前图所示，通过虚拟化，处理器被划分为两个虚拟域：一个用于正常模式，另一个用于执行敏感过程的安全模式。通过使用监控模式，进程可以从一个模式过渡到另一个模式。所有敏感代码、数据和资源都远离设备上的正常操作系统环境、软件和内存进行处理。这种隔离由 SoC 架构强制执行，因此它对软件和探测攻击具有高度鲁棒性。

## 移动可信模块

2010 年，**可信计算组**（**TCG**）发布了**移动可信模块**（**MTM**）1.0 版本。TCG 是一个国际标准化机构，与会员合作开发标准和规范。MTM 的目标是将现有的 TCG 技术适应于移动和嵌入式使用。

可信计算基于硬件信任根，被称为**可信平台模块**（**TPM**）。它检测恶意软件并检查系统的完整性。这种能力被称为可信平台模块。TPM 的安全始于启动过程。硬件信任根（通常是一个密钥）烧录在处理器本身中。启动安全建立在这个信任根上。启动软件的逐步阶段通过加密验证，以确保设备只执行正确、授权的软件。

访问他们的网站 [www.trustedcomputinggroup.org](http://www.trustedcomputinggroup.org)。这对于内核开发者来说更为相关，但对于任何人来说都是一个非常有趣的阅读。

# 应用程序架构

现在有三种编写应用程序的方法：原生、移动网络和混合。

原生应用特定于一个平台，并且使用该平台的本地语言编写。这些应用使用操作系统制造商提供的本地工具和 SDK。这些应用性能更好，并且可以使用本地功能和 API 进行安全数据存储。以下图示说明了原生应用和混合应用的工作原理：

![应用架构](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_15.jpg)

移动网页应用是用网页技术编写的，比如 HTML5、CSS、PHP、JavaScript 和 ASP.net。这些应用跨平台，一旦编写完成，就可以在任何拥有浏览器的平台上运行。它们提供了集中更新的便利，但也继承了所有浏览器的漏洞。在编写移动网页应用时，要警惕浏览器漏洞。浏览器代码对所有人来说都很容易获取。此外，URL 漏洞也是这类应用的风险，因为应用程序并不驻留在设备上，只能通过有效的 URL 访问。以下是说明移动网页应用工作原理的图示：

![应用架构](https://github.com/OpenDocCN/freelearn-android-pt2-zh/raw/master/docs/andr-app-sec-ess/img/5603_10_16.jpg)

编写应用的第三种方式是开发混合应用。这种应用结合了原生应用和移动网页应用的优势。应用使用网页技术编写一次。用户需要像安装原生应用一样安装该应用，并且它使用设备的浏览器引擎在原生环境中运行。这样，应用可以在离线模式下运行，可以访问设备功能，并且开发者可以针对多个平台。

选择哪种架构的决定取决于你的使用场景。原生应用程序比混合型或移动网页应用更安全，它们在速度和用户体验方面的表现也更好。另一方面，混合型和移动网页应用通过使用网页技术，开发起来更容易、更快速，并且跨平台。

# 概述

本章重点介绍了即将到来的使用场景和技术，以及它们与移动安全的一般关系。我们讨论了移动商务、近场技术、移动医疗安全以及身份验证。我们以硬件领域安全增强的视角结束了本章。正如你所注意到的，移动领域正在发生很多事情，我认为在事情稳定下来之前，这种情况还会持续一段时间。

通过本章，我们已到达本书的结尾。希望你在本书中学到了一些新知识，并且和我一样享受这段旅程。
