# 安卓取证学习手册（一）

> 原文：[`zh.annas-archive.org/md5/2056B6A0FCF4F0573C8075022809CB01`](https://zh.annas-archive.org/md5/2056B6A0FCF4F0573C8075022809CB01)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 前言

《学习 Android 取证》使用免费开源工具向您展示如何从 Android 设备中取证恢复数据。鼓励从初学者到专家的所有人都按照逐步说明进行学习，以了解如何获取和检查证据，并深入了解 Android 取证过程。商业取证工具通常会给取证人员一个按钮要按（通常称为“查找证据”按钮）。本书揭示了这些工具实际上在做什么，让您更深入地了解它们的工作原理。商业取证工具还经常无法从第三方应用程序中恢复数据；有太多的应用程序可用，无法编写一个覆盖所有应用程序的工具。本书向您展示如何手动分析十多个流行应用程序。它教授了理解数据的技术和程序，这些可以应用于几乎任何其他应用程序的分析。

# 本书涵盖的内容

第一章，“介绍 Android 取证”，介绍了移动取证，一般方法和面临的挑战。本章还概述了 Android 架构，安全功能，引导过程等。

第二章，“建立 Android 取证环境”，涵盖了建立取证设置以检查 Android 设备的步骤。本章还解释了在 Android 设备上使用 ADB 命令。

第三章，“了解 Android 设备上的数据存储”，详细解释了设备中存储的数据类型，存储位置，存储方式以及存储在其中的文件系统的详细信息。

第四章，“从 Android 设备逻辑提取数据”，涵盖了使用免费和开源工具的各种逻辑数据提取技术。涵盖的逻辑方法包括 ADB pull，ADB 备份，ADB dumpsys 信息和 SIM 卡提取。还涵盖了绕过设备锁屏的方法。

第五章，“从 Android 设备中物理提取数据”，演示了各种物理数据提取技术。物理方法包括 dd 和 nanddump，以及使用 netcat 将数据写入取证人员的计算机。还涵盖了 RAM 和 SD 卡镜像。

第六章，“从 Android 设备中恢复已删除数据”，概述了从 Android 设备中恢复已删除数据的过程。本章解释了从 SD 卡和手机内部存储中恢复已删除数据的程序。

第七章，“Android 应用程序取证分析”，涵盖了 Android 应用程序的取证分析，流行应用程序使用的数据混淆方法，Android 应用程序的逆向工程以及所需的方法。

第八章，“Android 取证工具概述”，介绍了在取证分析 Android 设备过程中有用的各种开源和商业工具。

# 本书所需内容

本书涵盖了 Android 设备上的各种取证方法和技术。内容组织得让任何用户都能够检查 Android 设备并进行取证调查。不需要先修知识，因为所有主题都有详细解释，从基础到深入。对移动平台，尤其是 Android 的了解肯定会是一个优势。在可能的情况下，详细解释了使用工具执行各种取证活动所需的步骤。

# 本书的受众

本书适用于在 Android 平台上进行移动取证的初学者或基础经验的取证员。对于计算机安全专业人士、研究人员以及希望更深入了解 Android 移动内部的任何人来说，本书也将非常有用。最后，对于那些试图从 Android 设备中恢复意外删除的数据（照片、联系人、短信等）的人来说，本书也会派上用场。

# 约定

在本书中，您将找到一些区分不同信息类型的文本样式。以下是一些样式的示例及其含义的解释。

文本中的代码词、数据库表名、文件夹名、文件名、文件扩展名、路径名、虚拟 URL、用户输入和 Twitter 句柄显示如下："在 Android 4.4 之前，`/system` 下的所有应用程序都被平等对待。"

代码块设置如下：

```kt
<manifest  package="com.example.rohit">

  <uses-permission android:name="android.permission.INTERNET" />

</manifest>
```

任何命令行输入或输出都以以下方式编写：

```kt
shell@android:/ $ cat default.prop
cat default.prop
#
# ADDITIONAL_DEFAULT_PROPERTIES
#
ro.secure=1
ro.allow.mock.location=0
ro.debuggable=0
persist.sys.usb.config=mtp

```

**新术语** 和 **重要单词** 以粗体显示。您在屏幕上看到的单词，例如菜单或对话框中的单词，会以这种方式出现在文本中："在 Android 设备中，通过导航到 **设置** | **开发者选项** 通常可以找到此选项。"

### 注

警告或重要说明会出现在这样的框中。

### 提示

提示和技巧会以这种方式出现。


# 第一章：介绍 Android 取证

移动取证是数字取证的一个分支，在当今数字时代正在发展。Android 取证涉及通过各种技术从 Android 设备中提取、恢复和分析数据。然而，在我们深入了解如何提取数据之前，有必要对平台和其他基本知识有清晰的理解。在本章中，我们将涵盖以下主题：

+   移动取证

+   移动取证方法

+   Android 架构

+   Android 安全

+   Android 硬件组件

+   Android 启动过程

今天的世界正经历着前所未有的技术创新。在移动设备领域，这种增长几乎是指数级的。技术研究和咨询公司 Gartner 在 2014 年 6 月发布的预测中预测，手机出货量很快将突破 24 亿部。这一统计数据反映了移动设备的空前增长。手机不仅数量增加，而且在功能上也变得更加复杂。

以下截图引用自[`en.wikipedia.org/wiki/File:Mobile_phone_subscribers_1997-2014_ITU.svg`](http://en.wikipedia.org/wiki/File:Mobile_phone_subscribers_1997-2014_ITU.svg)显示了 1997 年至 2014 年每 100 名居民的移动电话用户数量的增长图：

![介绍 Android 取证](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00250.jpeg)

1997-2014 年每 100 名居民的移动电话用户

在移动电话中，智能手机已经成为常态。这些设备的计算能力和数据存储的改进使我们能够执行各种活动。我们越来越依赖这些移动设备来进行大部分活动。除了执行常规任务，如打电话，发送短信等，这些设备还支持其他活动，如发送电子邮件，上网，录制视频，创建和存储文件，使用全球定位系统（GPS）服务识别位置，管理业务任务等等。换句话说，移动设备现在是敏感个人信息的存储库，包含大量用户数据。很多时候，设备上的数据比设备本身更有价值。例如，从设备上拨打的电话可能对执法机构来说是有价值的信息。移动取证在解决高调案件中发挥了关键作用，例如 2010 年时代广场汽车爆炸未遂和波士顿马拉松爆炸案，这再次证实了移动取证在许多政府和执法案件中的日益重要的作用。

# 移动取证

移动设备取证是数字取证的一个分支，涉及在取证上的可靠条件下从移动设备中提取、恢复和分析数字证据或数据。简而言之，它涉及访问存储在设备上的数据，包括短信、联系人、通话记录、照片、视频、文件、应用程序文件、浏览历史等，并使用各种取证技术恢复从设备中删除的数据。如果要在法庭上承认证据并保持证据的完整性，从设备中恢复或访问详细信息必须是取证上的可靠。如果证据必须在法庭上承认，原始设备不被篡改是很重要的。

### 注

“取证上的可靠性”这个术语经常在数字取证社区中使用，以澄清特定取证技术或方法的正确使用。移动取证，尤其是 Android 取证，正在快速发展，因为它在市场研究公司 IDC 的市场份额达到了 84%。

正如 Eoghan Casey 在他的书《数字取证与调查》中所解释的那样，取证的可靠性不仅仅是保持原始证据不变。甚至使用硬件写保护器从硬盘获取数据的例行任务也可能会导致改变（例如，使硬盘的隐藏区域可访问）。取证的可靠性的关键之一是文档记录。记录设备从一开始的处理方式非常重要。因此，如果获取过程保留了原始数据并且其真实性和完整性可以得到验证，那么调查可以被认为是取证上可靠的。证据完整性检查确保证据在收集时没有被篡改。完整性检查是通过比较收集时证据的数字指纹与当前状态下证据的数字指纹来进行的。

由于几个原因，移动取证的需求正在增长。一些突出的原因包括：

+   使用手机存储个人信息

+   增加使用手机进行在线活动

+   手机在多起犯罪中的使用

特定设备上的移动取证主要取决于底层操作系统。因此，我们有不同的领域，如 Android 取证、iOS 取证、Blackberry 取证等。

# 移动取证的方法

一旦从设备中提取数据，根据底层案例使用不同的分析方法。由于每个调查都是独特的，不可能为所有案例制定一个单一的明确程序。然而，整个过程可以分为以下图表中显示的五个阶段：

![移动取证的方法](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00251.jpeg)

移动取证的阶段

以下部分详细讨论了每个阶段：

## 调查准备

当收到检查请求时，这个阶段开始。它涉及准备所有需要记录保管链、所有权信息、设备型号、用途、请求者寻求的信息等的文件和表格。保管链是指按时间顺序记录或纸质追踪，显示物理或电子证据的扣押、保管、控制、转移、分析和处置。根据请求者提交的细节，对每次检查的目标有清晰的理解是很重要的。

## 扣押和隔离

在进行取证分析时，处理设备的方式是重要的一步。通常使用防静电袋来运输证据，这些袋子设计用来保护电子元件免受静电产生的损坏。一旦设备被扣押，就应该注意确保我们的行动不会导致设备上的任何数据修改。同时，也不应错过任何可以帮助调查的机会。

在处理 Android 设备时需要考虑的一些要点如下：

+   随着用户对安全和隐私意识的增强，大多数设备现在都启用了屏幕锁定。在扣押时，如果有机会这样做，禁用密码。有些设备在禁用锁屏选项时不要求用户重新输入密码。

+   如果设备已解锁，尝试更改设备的设置以允许更大的访问权限。可以考虑以下设置来实现这一点：

+   **启用 USB 调试**：启用此选项通过**Android 调试桥**（**adb**）连接为设备提供更大的访问权限。我们将在第二章*设置 Android 取证环境*中详细介绍 adb 连接。这将极大地帮助取证调查员在数据提取过程中。在 Android 设备中，此选项通常位于**设置** | **开发者选项**下，如下面的截图所示。从 4.2 开始的较新的 Android 版本中，开发者选项默认是隐藏的。要启用它们，转到**设置** | **关于手机**，然后点击**版本号**7 次。

+   **启用保持唤醒设置**：启用此选项并充电将使设备保持唤醒，这意味着它不会被锁定。在 Android 设备中，此选项通常位于**设置** | **开发者选项**下，如下面的截图所示：![扣押和隔离](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00252.jpeg)

保持唤醒和 USB 调试选项

+   **增加屏幕超时**：这是设备解锁后保持活动的时间。根据设备型号，这个时间可以设置为最长 30 分钟。在大多数设备中，它可以在**设置** | **显示** | **屏幕超时**下找到，如下面的截图所示：

### 注意

请注意，访问此项目的位置在不同版本和型号的 Android 手机上会有所变化。

![扣押和隔离](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00253.jpeg)

Android 设备上的屏幕超时选项

在移动取证中，保护扣押的设备非常重要，以便我们与证据的互动（或攻击者试图远程与设备互动）不会改变证据。在计算机取证中，我们有软件和硬件写入阻断器可以执行此功能。但是在移动取证中，由于我们需要与设备互动以提取数据，这些写入阻断器就没有任何用处。另一个重要方面是我们还需要防止设备与无线电网络互动。如前所述，攻击者很有可能发出远程擦除命令，删除设备上的所有数据，包括电子邮件、应用程序、照片、联系人和其他文件。

**Android 设备管理器**（**ADM**）和其他几个第三方应用程序允许远程擦除或锁定手机。这可以通过登录配置在移动设备上的 Google 帐户来完成。使用这个软件，攻击者也可以定位设备，这可能构成安全风险。出于所有这些原因，将设备与所有通信来源隔离开非常重要。

### 提示

您是否考虑过不需要互联网访问的远程擦除选项？**移动设备管理**（**MDM**）软件通过发送短信提供了远程擦除功能。将设备与所有通信选项隔离开非常重要。

将设备与网络隔离，如果可以访问设备，我们可以将设备置于**飞行模式**。飞行模式会禁用设备的无线传输功能，如蜂窝无线电、Wi-Fi 和蓝牙。然而，这并不总是可能，因为大多数设备都被锁定屏幕。另外，由于现在飞机上有 Wi-Fi，一些设备现在允许在飞行模式下使用 Wi-Fi。因此，另一个解决方案是使用法拉第袋或射频隔离盒，因为两者都可以有效地阻断手机的信号。但是，这些隔离方法的一个问题是一旦它们被使用，就很难使用手机，因为你无法透过它们来使用触摸屏或键盘。因此，法拉第帐篷和房间存在，如下面的截图所示（摘自[`www.technicalprotection.co.uk/`](http://www.technicalprotection.co.uk/)），但价格昂贵。

![扣押和隔离](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00254.jpeg)

金字塔形法拉第帐篷

即使采取了所有这些预防措施，某些自动功能，如闹钟可能会触发。如果遇到这种情况，必须妥善记录。

## 获取

获取阶段指的是从设备中提取数据。由于移动设备固有的安全功能，提取数据并不总是直截了当的。根据设备的操作系统、制造商和型号，决定提取方法。以下类型的获取方法可用于从设备中提取数据：

+   **手动获取**：这是所有获取方法中最简单的。检查员使用手机的用户界面进行浏览和调查。这里不需要特殊工具或技术，但限制在于只能提取通过正常用户界面可见的文件和数据。通过其他方法提取的数据也可以使用这种方法进行验证。

+   **逻辑获取**：这也被称为逻辑提取。这通常指的是从逻辑存储器（如文件系统分区）中提取文件。这包括从手机中获取文本消息、通话记录、图片等数据类型。逻辑提取技术是通过使用原始设备制造商的 API 来将手机内容与计算机同步。这种技术通常涉及提取以下证据：

+   通话记录

+   短信

+   MMS

+   浏览器历史记录

+   人员

+   联系人方式

+   联系人扩展

+   联系人分组

+   联系人电话

+   联系人设置

+   外部图像媒体（元数据）

+   外部图像缩略图媒体（元数据）

+   外部媒体、音频和其他（元数据）

+   外部视频（元数据）

+   MMSParts（包括通过 MMS 发送的完整图像）

+   位置详细信息（GPS 数据）

+   互联网活动

+   组织

+   安装的所有应用程序列表，以及它们的版本

+   社交网络应用程序的数据，如 WhatsApp、Skype、Facebook 等。

+   **文件系统获取**：这是一个逻辑过程，通常指的是从移动设备中提取完整的文件系统。文件系统获取有时可以帮助恢复从设备中删除的内容（存储在 SQLite 文件中）。

+   **物理获取**：这涉及制作整个闪存的逐位拷贝。使用这种方法提取的数据通常是原始数据（十六进制转储），然后可以进一步解析以获取文件系统信息或人类可读数据。由于所有调查都是在这个镜像上进行的，这个过程还确保原始证据没有被改变。

## 检查和分析

在这个阶段，使用不同的软件工具从内存镜像中提取数据。除了这些工具，调查员还需要使用十六进制编辑器的帮助，因为工具并不总是能提取所有数据。没有单一的工具可以在所有情况下使用。因此，检查和分析需要对各种文件系统、文件头等有扎实的知识。

## 报告

在整个过程中应该记录检查的文档，记录每个阶段所做的工作。检查员可能记录以下几点：

+   检查开始的日期和时间

+   手机的物理状态

+   收到手机时的状态（开/关）

+   手机的制造商、型号和操作系统

+   手机和各个组件的图片

+   调查中使用的工具

+   检查期间记录的数据

从移动设备提取的数据应清晰地呈现给接收方，以便可以将其导入其他软件进行进一步分析。在民事或刑事案件中，尽可能收集数据的图片，因为它们对陪审团有视觉上的吸引力。

# 移动取证中的挑战

随着 Android 设备的使用增加以及它们支持的通信平台的广泛，对取证检查的需求自然增长。在处理移动设备时，取证分析师面临着许多挑战。以下几点阐明了当今移动取证所面临的一些挑战：

+   防止设备上的数据被更改：取证中要记住的基本规则之一是不要修改证据。换句话说，应用于设备的取证技术不应更改设备上的数据。但是，对于移动取证来说，这是不切实际的，因为简单地打开设备可能也会更改设备上存在的某些状态变量。移动设备上始终运行着后台进程，突然从一种状态转换到另一种状态可能导致数据的丢失或修改。因此，取证分析师有可能故意或无意地更改数据。除此之外，攻击者有可能远程更改或删除设备上的内容。由于手机使用不同的通信渠道（蜂窝、Wi-Fi、蓝牙、红外线等），通过它们进行通信的可能性应该被消除。远程数据擦除等功能会使攻击者能够通过发送短信或简单地按下一个发送擦除请求的按钮来远程擦除整个设备。与计算机取证不同，移动设备取证需要更多的工作，不仅仅是将设备与网络隔离。

+   操作系统和设备型号的广泛范围：市场上提供的广泛移动操作系统使得取证分析师的工作变得更加困难。尽管 Android 是移动世界中最主要的操作系统，但在调查中经常会遇到运行其他操作系统的移动设备，包括 iOS、Blackberry、Windows 等。此外，对于给定的操作系统，有数百万种不同的移动设备，它们在操作系统版本、硬件和其他各种功能上都有所不同。例如，在 Android 操作系统中，大约有 10 个版本，而对于每个版本，不同制造商都进行了不同的定制。根据制造商，获取取证证据的方法也会改变。为了保持竞争力，制造商们发布新型号和更新如此迅速，以至于很难跟踪所有这些变化。有时在同一操作系统中，数据存储选项和文件结构也会发生变化，使情况变得更加困难。没有单一工具可以在所有可用类型的移动操作系统上运行。因此，取证分析师必须及时了解所有最新的变化和技术。

+   固有的安全功能：随着“隐私”概念日益重要，移动制造商正朝着在设备上实施强大的安全控制的方向发展，这使得获取数据的过程变得更加复杂。例如，如果设备受到密码保护，取证调查员必须首先找到一种绕过密码的方法。同样，一些最新设备上实施的全盘加密机制阻止执法机构和取证分析师访问设备上的信息。苹果的 iPhone 默认使用设备内置的硬件密钥对设备上的所有数据进行加密。取证人员很难使用暴力破解等技术来破解这些加密机制。

+   法律问题：移动设备可能涉及跨越全球并跨越地理边界的犯罪。为了解决这些跨司法管辖范围的问题，取证人员需要了解犯罪的性质以及地区法律。

# Android 架构

在我们继续讨论 Android 取证的内部之前，本部分将向您介绍 Android 作为操作系统的基本概念，并涵盖需要理解的各种基本概念，以便在取证领域获得经验。

任何操作系统（桌面或移动）都负责管理系统资源，并提供一种让应用程序与硬件或物理组件进行通信以完成某些任务的方式。Android 操作系统也不例外。它为移动电话提供动力，管理内存和进程，执行安全性，处理网络问题等。Android 是开源的，大部分代码都是根据 Apache 2.0 许可发布的。实际上，这意味着手机设备制造商可以自由访问它，修改它，并根据任何设备的要求使用该软件。这是其受欢迎的主要原因之一。

Android 操作系统由一系列层次堆叠而成。通过查看这些层次是什么以及它们的作用，可以更好地理解 Android 架构。以下图表引用自[`elinux.org/images/c/c2/Android-system-architecture.jpg`](http://elinux.org/images/c/c2/Android-system-architecture.jpg)，显示了 Android 软件堆栈中涉及的各个层次：

![Android 架构](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00255.jpeg)

Android 架构

Android 架构以软件堆栈的形式存在，包括内核、库、运行环境、应用程序、中间件和服务。堆栈的每一层（以及每一层内的元素）都以一种集成的方式存在，为移动设备提供了最佳的执行环境。接下来的部分将重点介绍 Android 堆栈的不同层次，从底层的 Linux 内核开始。

## Linux 内核

Android 操作系统是建立在 Linux 内核之上的，谷歌对其进行了一些架构上的改变。选择 Linux 是因为它是一个可移植的平台，可以在不同的硬件上轻松编译。Linux 内核位于软件堆栈的底部，并在设备硬件和上层之间提供了一定程度的抽象。它还充当了设备上软件和硬件之间的抽象层。为了更好地理解这一点，可以考虑一下使用相机按钮拍照的情况。当您在移动设备上按下相机按钮拍照时，实际上会发生什么？在某个时刻，硬件指令，比如*按下按钮*，必须转换为软件指令，比如*拍照并将其存储在相册中*。内核包含可以促进这一过程的驱动程序。当检测到相机按钮点击时，指令会传递到内核中相应的驱动程序，该驱动程序向相机硬件发送必要的命令，类似于在键盘上按键时发生的情况。简而言之，内核中的驱动程序控制着底层硬件。如前图所示，内核包含与 Wi-Fi、蓝牙、USB、音频、显示等相关的驱动程序。

Android 的所有核心功能，如进程管理、内存管理、安全性和网络，都由 Linux 内核管理。在安全性和进程管理方面，Linux 是一个经过验证的平台。Android 利用现有的 Linux 开源操作系统构建了其生态系统的坚实基础。每个 Android 版本都有一个不同版本的底层 Linux 内核。截至 2014 年 9 月，当前的 Android 版本 4.2 是建立在 Linux 内核 3.4 或更新版本之上的，但具体的内核版本取决于实际的 Android 设备和芯片组。

## 库

在 Linux 内核之上是 Android 的本地库。借助这些库，设备可以处理不同类型的数据。例如，媒体框架库支持音频、视频和图片格式的录制和播放。这些库是用 C 或 C++编程语言编写的，并且特定于特定的硬件。Surface Manager、媒体框架、SQLite、WebKit、OpenGL 等都是一些最重要的本地库。

## 达尔维克虚拟机

Android 应用程序是使用 Java 编程语言编写的。选择 Java 的主要原因是因为它是一种众所周知的语言，拥有庞大的开发者基础。Android 希望利用这个现有的开发者社区，而不是提出一种新的语言。

### 注意

这后来促使 Oracle 对 Google 提起诉讼，声称其侵犯了其版权和专利。但陪审团最终宣布 Google 没有侵犯 Oracle 的专利，审判法官裁定 Google 使用的 Java API 结构不受版权保护。

当 Java 程序编译时，我们得到字节码。**Java 虚拟机**（虚拟机是一个充当操作系统的应用程序）可以执行这个字节码。在 Android 的情况下，这个 Java 字节码进一步被 dex 编译器转换为**达尔维克**字节码。这个达尔维克字节码然后被输入到**达尔维克虚拟机**（**DVM**）中，它可以读取和使用这个代码。因此，Java 编译器的`.class`文件使用 dx 工具转换为`.dex`文件。达尔维克字节码是一种适用于低内存和低处理环境的优化字节码。另外，需要注意的是，JVM 的字节码由一个或多个`.class`文件组成，取决于应用程序中存在的 Java 文件的数量，但达尔维克字节码只由一个`.dex`文件组成。每个 Android 应用程序都运行自己的 DVM 实例。以下图表显示了 Java 应用程序和 Android 应用程序的程序编译之间的差异。

![达尔维克虚拟机](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00256.jpeg)

JVM 与 DVM

自 Android 5.0 以来，Dalvik 已被**Android 运行时**（**ART**）取代为平台默认。ART 在 Android 4.4 上作为实验性功能引入。Dalvik 使用**即时**（**JIT**）编译，每次启动应用程序时都会编译字节码。然而，ART 使用**预编译**（**AOT**）编译，在安装应用程序时执行。这大大减少了移动设备的处理器使用率，因为在应用程序运行期间的整体编译减少了。

## 应用程序框架

Android 应用程序是通过 Android 应用程序框架运行和管理的。它负责执行许多关键功能，如资源管理、处理呼叫等。Android 框架包括以下关键服务，引用自[`fp.edu.gva.es/av/pluginfile.php/745396/mod_imscp/content/2/1_overview_of_the_android_architecture.html`](http://fp.edu.gva.es/av/pluginfile.php/745396/mod_imscp/content/2/1_overview_of_the_android_architecture.html)：

+   **活动管理器**：此服务控制应用程序生命周期和活动堆栈的所有方面。

+   **内容提供者**：此服务允许应用程序与其他应用程序发布和共享数据。

+   **资源管理器**：此服务提供对非代码嵌入资源的访问，如字符串、颜色设置和用户界面布局。

+   **通知管理器**：此服务允许应用程序向用户显示警报和通知。

+   **视图系统**：此服务提供一组可扩展的视图，用于创建应用程序用户界面。

+   **包管理器**：应用程序可以通过该系统找到有关设备上当前安装的其他应用程序的信息。

+   **电话管理器**：此服务向应用程序提供有关设备上可用的电话服务的信息，如状态和订阅者信息。

+   **位置管理器**：此服务提供对位置服务的访问，允许应用程序接收有关位置更改的更新。

## 应用程序层

Android 堆栈中的最顶层是应用程序（称为**应用**），这些是用户直接交互的程序。以下讨论了两种类型的应用程序：

+   系统应用程序：这些是预装在手机上并随手机一起发货的应用程序。默认浏览器、电子邮件客户端、联系人等应用程序都是系统应用程序的示例。这些应用程序无法被用户卸载或更改，因为它们在生产设备上是只读的。这些通常存在于`/system`目录中。直到 Android 4.4，所有存在于`/system`下的应用程序都被平等对待。但从 Android 4.4 开始，安装在`/system/priv-app/`中的应用程序被视为特权应用程序，并且只有特权应用程序被授予具有签名或系统保护级别的权限。

+   **用户安装的应用程序**：这些是用户从各种分发平台（如 Google Play）下载并安装的应用程序。Google Play 是 Android 操作系统的官方应用商店，用户可以浏览和下载应用程序。根据 2014 年 12 月 AppBrain 的统计数据，Play 商店中大约有 1,418,453 个 Android 应用程序。这些应用程序目前位于`/data`目录中。有关它们之间如何执行安全性的更多信息将在以下部分中讨论。

# Android 安全性

作为一个平台，Android 的架构中内置了某些功能，以确保用户、应用程序和数据的安全性。尽管它们有助于保护数据，但这些安全功能有时会阻止调查人员访问必要的数据。因此，从法医学的角度来看，首先要了解固有的安全功能，以便清楚地了解在正常情况下可以或不可以访问的内容。所包含的安全功能和服务旨在实现三个目标：

+   保护用户数据

+   保护系统资源

+   确保一个应用程序不能访问另一个应用程序的数据

接下来的部分将概述 Android 操作系统中的关键安全功能。

## 通过 Linux 内核在操作系统级别上的安全性

Android 操作系统是建立在 Linux 内核之上的。在过去的几年里，Linux 已经发展成为一个受到许多全球公司信任的安全操作系统。今天，大多数关键任务的系统和服务器都在 Linux 上运行，因为它的安全性。通过将 Linux 内核置于其平台的核心位置，Android 试图确保在操作系统级别上的安全性。此外，Android 还在 Linux 中构建了许多特定的代码，以包括与移动环境相关的某些功能。随着每个 Android 版本的发布，内核版本也发生了变化。以下表格显示了 Android 版本和相应的 Linux 内核版本：

| Android 版本 | Linux 内核版本 |
| --- | --- |
| 1.0 | 2.6.25 |
| 1.5 | 2.6.27 |
| 1.6 | 2.6.29 |
| 2.2 | 2.6.32 |
| 2.3 | 2.6.35 |
| 3.0 | 2.6.36 |
| 4.0 | 3.0.1 |
| 4.1 | 3.0.31 |
| 4.2 | 3.4.0 |
| 4.3 | 3.4.39 |
| 4.4 | 3.8 |

> *各种 Android 版本中使用的 Linux 内核*

Linux 内核为 Android 提供了以下关键安全功能：

+   基于用户的权限模型

+   进程隔离

+   可扩展的安全 IPC 机制

### 权限模型

Android 为各个应用程序实现了权限模型。应用程序必须声明它们需要哪些权限（在清单文件中）。当应用程序安装时，Android 会向用户呈现列表，以便他们可以查看列表以允许或不允许安装：

![权限模型](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00257.jpeg)

Android 中的示例权限模型

与桌面环境不同，这提供了一个机会，让用户提前知道应用程序正在寻求访问哪些资源。换句话说，用户必须获得许可才能访问设备上的任何关键资源。通过查看请求的权限，用户更加了解安装应用程序所涉及的风险。但大多数用户并不阅读这些内容，只是授予了很多权限，使设备暴露于恶意活动之中。

### 注意

不可能安装具有少量或减少权限的 Android 应用程序。您只能安装具有所有权限或拒绝的应用程序。

如前所述，开发人员必须在名为`AndroidManifest.xml`的文件中声明权限。例如，如果应用程序需要访问互联网，则可以使用以下代码在`AndroidManifest.xml`文件中指定`INTERNET`权限：

```kt
<manifest  package="com.example.rohit">

  <uses-permission android:name="android.permission.INTERNET" />

</manifest>
```

Android 权限分为四个级别，如下所示：

| 权限类型 | 描述 |
| --- | --- |
| 普通 | 这是默认值。这些是低风险权限，不会对其他应用程序、系统或用户造成风险。在安装过程中，此权限会自动授予应用程序，无需用户批准。 |
| 危险 | 这些是可能对系统和其他应用程序造成伤害的权限。因此，在安装过程中需要用户批准。 |
| 签名 | 如果请求的应用程序与声明/创建权限的应用程序使用相同的证书，则会自动授予这些权限。此级别旨在允许套件中的应用程序或其他相关应用程序共享数据。 |
| 签名/系统 | 系统仅授予 Android 系统镜像中的应用程序，或者与声明权限的应用程序使用相同证书的应用程序。 |

### 应用程序隔离

为了将应用程序相互隔离，Android 利用了 Linux 基于用户的保护模型。在 Linux 系统中，每个用户被分配一个唯一的用户 ID（UID），并且用户被隔离开来，以便一个用户不会访问另一个用户的数据。特定用户下的所有资源都以相同的权限运行。同样，每个 Android 应用程序都被分配一个 UID，并作为一个单独的进程运行。这意味着，即使安装的应用程序尝试执行一些恶意操作，它也只能在其上下文中以及具有的权限内执行。

这种应用程序隔离是在内核级别完成的。应用程序和系统之间在进程级别的安全性是通过标准的 Linux 设施来确保的，例如分配给应用程序的用户和组 ID。这在下面的截图中显示，引用自[`www.ibm.com/developerworks/library/x-androidsecurity/`](http://www.ibm.com/developerworks/library/x-androidsecurity/)。

![应用程序隔离](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00258.jpeg)

具有不同 UID 的不同进程上的两个应用程序

默认情况下，应用程序无法读取或访问其他应用程序的数据，并且对操作系统的访问权限有限。例如，如果应用程序 A 尝试读取应用程序 B 的数据，操作系统会阻止这种操作，因为应用程序 A 没有适当的权限。由于应用程序沙箱机制是在内核级别实现的，因此适用于本机应用程序和操作系统应用程序。因此，操作系统库、应用程序框架、应用程序运行时以及所有应用程序都在应用程序沙箱中运行。绕过这个沙箱机制将需要破坏 Linux 内核的安全性。

### Android 中的 SELinux

从 Android 4.3 开始，Android 安全模型支持**安全增强型 Linux**（**SELinux**）。Android 安全基于自由访问控制，这意味着应用程序可以请求权限，用户可以授予或拒绝这些权限。因此，恶意软件可以通过获取权限在手机上制造混乱。但 SE Android 使用**强制访问控制**（**MAC**），确保应用程序在隔离的环境中运行。因此，即使用户安装了恶意应用程序，恶意软件也无法访问操作系统并损坏设备。SELinux 用于强制执行 MAC，包括以 root 权限运行的进程。

SELinux 遵循*默认拒绝*的原则。任何未明确允许的操作都将被拒绝。SELinux 可以在两种全局模式下运行：**宽容模式**，其中权限拒绝被记录但不被执行，和**强制模式**，其中拒绝既被记录又被执行。根据谷歌的文档，在 Android 5.0 棒棒糖版本中，Android 将全面执行 SELinux。这是在 4.3 版本的宽容发布和 4.4 版本的部分执行的基础上构建的。简而言之，Android 正在从对一组关键域（`installd`、`netd`、`vold`和`zygote`）的执行转变为对所有内容（超过 60 个域）的执行。

### 应用程序签名

所有 Android 应用程序在安装到设备上之前都需要使用证书进行数字签名。使用证书的主要目的是识别应用程序的作者。这些证书不需要由证书颁发机构签名，Android 应用程序通常使用自签名证书。应用程序开发人员持有证书的私钥。使用相同的私钥，开发人员可以为其应用程序提供更新并在应用程序之间共享数据。在调试模式下，开发人员可以使用 Android SDK 工具生成的调试证书对应用程序进行签名。您可以在调试模式下运行和调试应用程序，但应用程序无法分发。要分发应用程序，应用程序需要使用您自己的证书进行签名。在此过程中使用的密钥库和私钥需要由开发人员保护，因为它们对推送更新至关重要。以下截图显示了在导出应用程序时显示的密钥库选择选项：

![应用程序签名](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00259.jpeg)

导出 Android 应用程序时的密钥库选择

### 安全的进程间通信

如上所述，应用程序的沙盒化是通过在不同的进程中以不同的 Linux 身份运行应用程序来实现的。系统服务在单独的进程中运行，并具有更多的权限。因此，为了在这些进程之间组织数据和信号，需要一个**进程间通信**（**IPC**）框架。在 Android 中，这是通过使用**Binder**机制实现的。

Android 中的 Binder 框架提供了组织各种进程间通信所需的能力。Android 应用程序组件，如意图和内容提供程序，也是建立在这个 Binder 框架之上的。使用这个框架，可以执行各种操作，比如调用远程对象的方法，就像它们是本地的一样，同步和异步方法调用，在进程之间发送文件描述符等等。假设**进程'A'**中的应用程序想要使用**进程'B'**中运行的服务暴露的某些行为。在这种情况下，**进程'A'**是客户端，**进程'B'**是服务。使用 Binder 的通信模型如下图所示：

![安全的进程间通信](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00260.jpeg)

Binder 通信模型

使用 Binder 框架进行的进程间通信都是通过`/dev/binder` Linux 内核驱动程序进行的。对这个设备驱动程序的权限被设置为全局可读可写。因此，任何应用程序都可以向这个设备驱动程序写入和读取。客户端和服务器之间的所有通信都是通过客户端的**代理**和服务器端的**存根**进行的。代理和存根负责发送和接收通过 Binder 驱动程序发送的数据和命令。

使用 Binder 机制公开的每个服务（也称为 Binder 服务）都被分配一个**令牌**。这个令牌是一个 32 位的值，在系统中的所有进程中是唯一的。客户端可以在发现这个值后开始与服务进行交互。这是通过 Binder 的**上下文管理器**来实现的。基本上，上下文管理器充当名称服务，使用该服务的名称提供服务的句柄。为了使这个过程工作，每个服务必须向上下文管理器注册。因此，客户端只需要知道一个服务的名称来进行通信。名称由上下文管理器解析，客户端接收后用于与服务进行通信。Binder 驱动程序向每个事务添加了发送方进程的 UID 和 PID 值。正如前面讨论的，系统中的每个应用程序都有自己的 UID，这个值用于识别调用方。调用方可以检查获得的值，并决定是否应完成事务。因此，Binder 令牌作为安全令牌起作用，因为它在所有进程中是唯一的，从而强制执行安全性。

## Android 硬件组件

Android 兼容各种硬件组件。由于 Linux 内核的存在，这变得很容易，因为 Linux 支持各种硬件。这使制造商有很大的灵活性，他们可以根据自己的需求设计，而不必担心兼容性。这给取证分析人员在调查过程中带来了重大挑战。因此，了解硬件组件和设备类型将极大地帮助理解 Android 取证。

### 核心组件

设备中的组件从一个制造商到另一个制造商，以及从一个型号到另一个型号都会有所变化。然而，大多数移动设备中都会找到一些组件。以下部分概述了 Android 设备中常见的组件。

#### 中央处理单元

中央处理单元（**CPU**），也称为处理器，负责执行移动设备上发生的一切。它告诉设备要做什么以及如何做。其性能是根据它每秒可以完成的任务数来衡量的，称为**周期**。例如，1 GHz 处理器可以每秒处理十亿个周期。处理器的容量越大，手机的性能就越流畅。

在处理智能手机时，我们会遇到以下术语——ARM、x86（英特尔）、MIPS、Cortex、A5、A7 或 A9。ARM 是一家授权其架构（品牌 Cortex）的公司，每年推出不同型号，如上述的 A 系列（A5、A7 和 A9）。基于这些架构，芯片制造商发布自己系列的芯片组（骁龙、Exynos 等），用于移动设备。最新的智能手机由双核、四核甚至八核处理器驱动。

#### 基带处理器

今天的智能手机支持各种蜂窝协议，包括 GSM、3G、4G 和 4G LTE。这些协议很复杂，需要大量的 CPU 功率来处理数据，生成数据包并将其传输到网络提供商。为了处理这个过程，智能手机现在使用一个基带调制解调器，这是一个单独的芯片，包含在智能手机中，与主处理器通信。这些基带调制解调器有自己的处理器，称为基带处理器，并运行自己的操作系统。基带处理器管理几个无线电控制功能，如信号生成、调制、编码，以及频率转移。它也可以管理信号的传输。

基带处理器通常位于与 CPU 相同的电路板上，但由单独的无线电电子组件组成。

#### 内存

Android 手机，就像普通计算机一样，使用两种主要类型的内存——**随机存取存储器**（**RAM**）和**只读存储器**（**ROM**）。尽管大多数用户对这些概念很熟悉，但在移动设备上存在一些混淆。

RAM 是易失性的，这意味着其内容在断电时被擦除。RAM 非常快速访问，主要用于软件应用程序的运行时内存（包括设备的操作系统和任何应用程序）。换句话说，它被系统用来加载和执行操作系统和其他应用程序。因此，可以同时运行的应用程序和进程的数量取决于 RAM 的大小。

ROM（通常称为 Android ROM）是非易失性的，这意味着即使断电也会保留其内容。Android ROM 包含引导加载程序、操作系统、所有下载的应用程序及其数据、设置等。

请注意，用于引导加载程序的内存部分通常是锁定的，只能通过固件升级进行更改。其余部分的内存被一些制造商称为用户内存。存储在这里的每个应用程序的数据对其他应用程序是不可访问的。一旦这个内存被填满，设备就会变慢。RAM 和 Android ROM 被制造成一个称为**多芯片封装**（**MCP**）的单一组件。

#### SD 卡

SD 卡对于移动取证具有重要意义，因为经常存储在其中的数据可能是重要的证据。许多 Android 设备都有一个可移动的存储卡，通常称为他们的**安全数字**（**SD**）卡。这与苹果的 iPhone 形成对比，后者没有任何 SD 卡的规定。SD 卡是非易失性的，这意味着即使断电也会存储数据。SD 卡使用闪存存储器，一种**可擦可编程只读存储器**（**EEPROM**）类型，它以大块而不是单个字节进行擦除和写入。大多数多媒体数据和大文件都存储在 SD 卡中。为了与其他设备互操作，SD 卡实现了一些通信协议和规范。

在一些移动设备中，虽然存在 SD 卡接口，但部分内置 NAND 存储器（非易失性）被划分出来用于创建模拟 SD 卡。这基本上意味着 SD 卡是不可移动的。因此，取证分析人员需要检查他们是否正在处理实际的 SD 卡还是模拟 SD 卡。SD 存储卡有几种不同的尺寸。Mini-SD 卡和 Micro-SD 卡与原始 SD 存储卡具有相同的基础技术，但尺寸更小。

#### 显示屏

移动电话屏幕在过去几年里取得了巨大进步。以下是对一些广泛使用的移动屏幕类型的简要描述，如[`www.in.techradar.com/news/phone-and-communications/mobile-phones/Best-phone-screen-display-tech-explained/articleshow/38997644.cms`](http://www.in.techradar.com/news/phone-and-communications/mobile-phones/Best-phone-screen-display-tech-explained/articleshow/38997644.cms)所述。

薄膜晶体管液晶显示屏（TFT LCD）是移动电话中最常见的屏幕类型。这些屏幕下面有一盏灯，透过像素发光，使它们可见。

有机活性矩阵有机发光二极管（AMOLED）是一种基于有机化合物的技术，以其出色的图像质量和低功耗而闻名。与 LCD 屏幕不同，AMOLED 显示屏不需要背光；每个像素都会产生自己的光，因此使用这种显示屏的手机可能会更薄。

#### 电池

电池是移动电话的生命线，也是现代智能手机的主要关注点之一。您使用设备及其组件越多，电池消耗就越多。移动电话使用以下不同类型的电池：

+   锂离子（Li-ion）：这些电池是手机中最常用的电池，因为它们轻便易携。它们以高能量密度和低维护而闻名。然而，与其他电池类型相比，它们的制造成本较高。

+   聚合物锂电池（Li-Polymer）：这些电池具有锂离子电池的所有特性，但具有超薄的几何形状和简化的包装。它们是最新的，只在少数移动设备中找到。

+   镍镉（NiCd）：这些电池是旧技术电池，容易出现记忆效应。因此，电池的总容量和寿命会减少。除此之外，镍镉电池由对环境不友好的有毒材料制成。

+   镍氢（NiMH）：这些电池与镍镉电池相同，但可以容纳更多能量，运行时间更长，约为 30%至 40%。它们仍然会出现记忆效应，但相对于镍镉电池来说较少。它们在手机中被广泛使用，而且价格也比较实惠。

可以通过查看电池本体上的详细信息来找到电池类型。例如，以下是锂离子电池的图像：

![电池](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00261.jpeg)

锂离子电池

大多数 SD 卡位于电池后面。在取证分析中，访问 SD 卡需要取出电池，这将关闭设备。这可能会产生某些影响，将在后面的章节中详细讨论。

除了上述描述的组件外，以下是一些其他众所周知的组件：

+   全球定位系统

+   Wi-Fi

+   近场通信

+   蓝牙

+   相机

+   键盘

+   USB

+   加速度计和陀螺仪

+   扬声器

+   麦克风

## Android 启动过程

了解 Android 设备的启动过程将帮助我们理解涉及与设备在各个层面交互的其他取证技术。当 Android 设备首次上电时，会执行一系列步骤，帮助设备将必要的固件、操作系统、应用程序数据等加载到内存中。以下信息编译自原始文章，发表在[`www.androidenea.com/2009/06/android-boot-process-from-power-on.html`](http://www.androidenea.com/2009/06/android-boot-process-from-power-on.html)。

Android 启动过程涉及的步骤顺序如下：

1.  启动 ROM 代码执行

1.  引导加载程序

1.  Linux 内核

1.  init 进程

1.  Zygote 和 Dalvik

1.  系统服务器

我们将详细研究这些步骤中的每一个。

### 启动 ROM 代码执行

在设备上电之前，设备 CPU 将处于未初始化状态。一旦 Android 设备上电，执行就会从启动 ROM 代码开始。这个启动 ROM 代码是特定于设备使用的 CPU 的。如下图所示，这个阶段包括两个步骤：

1.  当启动 ROM 代码执行时，它会初始化设备硬件并尝试检测引导介质。因此，启动 ROM 代码会扫描直到找到引导介质。这类似于计算机引导过程中的 BIOS 功能。

1.  一旦引导序列建立，初始引导加载程序就会被复制到内部 RAM。之后，执行会转移到加载到 RAM 中的代码。![启动 ROM 代码执行](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00262.jpeg)

Android 启动过程：启动 ROM 代码执行

### 引导加载程序

引导加载程序是在操作系统开始运行之前执行的程序片段。引导加载程序存在于台式计算机、笔记本电脑和移动设备中。在 Android 引导加载程序中，有两个阶段——**初始程序加载**（**IPL**）和**第二程序加载**（**SPL**）。如下图所示，这涉及到三个步骤，如下所述：

1.  IPL 处理检测和设置外部 RAM。

1.  一旦外部 RAM 可用，SPL 就会被复制到 RAM 中，并且执行会转移到它。SPL 负责加载 Android 操作系统。它还提供对其他引导模式（如 fastboot、recovery 等）的访问。它启动了几个硬件组件，如控制台、显示、键盘和文件系统、虚拟内存和其他功能。

1.  之后，SPL 会尝试寻找 Linux 内核。它会从引导介质加载并将其复制到 RAM 中。一旦引导加载程序完成了这个过程，它就会将执行转移到内核。![引导加载程序](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00263.jpeg)

Android 启动过程：引导加载程序

### Linux 内核

Linux 内核是 Android 操作系统的核心，负责进程管理、内存管理和设备安全。内核加载后，它会挂载**根文件系统**（**rootfs**），并提供对系统和用户数据的访问，如下所述：

1.  当内存管理单元和缓存已经初始化后，系统可以使用虚拟内存并启动用户空间进程。

1.  内核将在 rootfs 中寻找 init 进程，并将其作为初始用户空间进程启动。![Linux 内核](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00264.jpeg)

Android 启动过程：内核

### init 进程

init 是第一个启动的进程，也是所有其他进程的根进程。

1.  init 进程将寻找一个名为`init.rc`的脚本，描述系统服务、文件系统和需要设置的其他参数。

+   `init`进程可以在`<android source>/system/core/init`路径下找到。

+   `init.rc`文件可以在源树中找到，路径为`<android source>/system/core/rootdir/init.rc`。

### 提示

有关 Android 文件层次结构的更多细节将在第三章中进行介绍，*了解 Android 设备上的数据存储*。

1.  `init`进程将解析`init.rc`脚本并启动系统服务进程。在这个阶段，您将在设备屏幕上看到 Android 标志。![init 进程](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00265.jpeg)

Android 启动过程：init 进程

### Zygote 和 Dalvik

**Zygote**是设备启动后创建的第一个 init 进程之一。它初始化 Dalvik 虚拟机，并尝试创建多个实例以支持每个 Android 进程。正如前面的部分所讨论的，Dalvik 虚拟机是执行用 Java 编写的 Android 应用程序的虚拟机。

Zygote 有助于在虚拟机之间使用共享代码，从而有助于节省内存并减轻系统负担。之后，应用程序可以通过请求新的 Dalvik 虚拟机来运行。Zygote 为 zygote 连接注册了一个服务器套接字，并预加载了某些类和资源。有关 Zygote 加载过程的更清晰解释，请参见[`www.kpbird.com/2012/11/in-depth-android-boot-sequence-process.html`](http://www.kpbird.com/2012/11/in-depth-android-boot-sequence-process.html)。如下所述：

+   `Load ZygoteInitclass`: 此类加载`ZygoteInit`类。源代码：`<Android Source>/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java`。

+   `registerZygoteSocket()`: 为 zygote 命令连接注册服务器套接字。

+   `preloadClasses()`: 这是一个简单的文本文件，其中包含需要预加载的类的列表将在此处执行。此文件可以在`<Android Source>/frameworks/base`中看到。

+   `preloadResources()`: 这处理本机主题和布局。所有包括`android.R`文件的内容都将使用此方法加载。![Zygote 和 Dalvik](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00266.jpeg)

Android 启动过程：Zygote

### 系统服务器

设备的所有核心功能，如电话、网络和其他重要功能，都是由系统服务器启动的，如下图所示：

![系统服务器](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00267.jpeg)

Android 启动过程：系统服务器

在此过程中启动以下核心服务：

+   启动电源管理器

+   创建 Activity Manager

+   启动电话注册表

+   启动包管理器

+   将 Activity Manager 服务设置为系统进程

+   启动上下文管理器

+   启动系统上下文提供程序

+   启动电池服务

+   启动闹钟管理器

+   启动传感器服务

+   启动窗口管理器

+   启动蓝牙服务

+   启动挂载服务

系统发送一个名为`ACTION_BOOT_COMPLETED`的广播动作，通知所有依赖进程引导过程已经完成。之后，设备显示主屏幕，并准备与用户交互。Android 系统现在已经完全运行，并准备与用户交互。

正如前面所解释的，许多制造商在其设备上使用 Android 操作系统。这些设备制造商大多根据其硬件和其他要求定制操作系统。因此，当发布新版本的 Android 时，这些设备制造商必须将他们的定制软件和调整移植到最新版本。

## 摘要

了解 Android 架构及其安全模型对于正确理解 Android 取证至关重要。Android 操作系统中固有的安全功能，如应用程序沙箱、权限模型等，保护 Android 设备免受各种威胁，并在调查过程中也作为取证专家的障碍。通过获得这些 Android 内部知识，我们将在下一章更多地讨论设备上存储了什么类型的数据以及它是如何存储的。


# 第二章：设置 Android 法庭环境

在开始任何法庭审查之前，建立一个已经建立的法庭环境是至关重要的。法庭分析师需要始终完全控制工作站。本章将带您了解建立法庭设置以检查 Android 设备所必需的一切。在本章中，我们将涵盖以下主题：

+   在工作站上安装必要的软件

+   从工作站连接和访问 Android 设备

+   在设备上使用 ADB 命令

+   对 Android 设备进行 Root

# Android 法庭设置

在开始任何调查之前，建立一个声音和良好控制的法庭环境是至关重要的。从一个新的和**法庭无菌**的计算机开始。一个法庭无菌的计算机是一个可以防止交叉污染的潜力，不会引入不需要的数据，并且没有病毒和其他恶意软件的计算机。这是为了确保机器上的软件不会干扰当前的调查。安装基本软件，比如以下这些；它们是连接设备和进行分析所必需的：

+   Android SDK

+   移动驱动程序

+   MS Office 软件包

+   用于分析的工具

# Android SDK

重要的是我们从 Android SDK 开始讨论。Android **软件开发工具包**（**SDK**）帮助开发人员构建、测试和调试在 Android 上运行的应用程序。它包括软件库、API、模拟器、参考资料和许多其他工具。这些工具不仅帮助创建 Android 应用程序，还提供文档和实用程序，这些对 Android 设备的法庭分析非常有帮助。对 Android SDK 有扎实的了解可以帮助您了解设备的细节。这反过来将在调查中帮助您。

在法庭审查期间，SDK 帮助我们连接设备并访问设备上的数据。SDK 在大多数环境中都受支持，包括 Windows、Linux 和 OS X。可以从[`developer.android.com/sdk/index.html`](http://developer.android.com/sdk/index.html)免费下载。

## 安装 Android SDK

谷歌现在只提供 Android Studio 和 SDK 工具作为下载选项。Android Studio 包含 Android IDE，SDK 工具，Android 5.0（棒棒糖）平台，带有谷歌 API 的 Android 5.0 系统映像，以及其他新引入的功能。然而，对于法庭实验室的设置，仅下载 SDK 工具包就足够了。以下是在 Windows 8 机器上安装 Android SDK 的逐步过程：

1.  在开始安装 Android SDK 之前，请确保系统已安装**Java 开发工具包**（**JDK**），因为 Android SDK 依赖于 Java SE 开发工具包。JDK 可以从[`www.oracle.com/technetwork/java/javase/downloads/index.html`](http://www.oracle.com/technetwork/java/javase/downloads/index.html)下载。根据您的操作系统选择正确的下载。

1.  从[`developer.android.com/sdk/index.html`](http://developer.android.com/sdk/index.html)下载最新版本的 SDK 工具包。建议下载`.exe`版本的软件包。

1.  运行在步骤 2 中下载的安装程序文件。将出现一个向导窗口，如下截图所示。然后，点击**下一步**。![Installing the Android SDK](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00268.jpeg)

Android SDK 设置向导

1.  设置将自动检测系统上是否安装了 Java，并选择安装 Java 的路径。

1.  选择安装位置并记住以备将来使用。在本例中，我们将其安装在`C:\Program Files (x86)`。在 32 位操作系统的情况下，默认位置将是`C:\Program Files`。所有必要的文件将被提取到这个位置，如下截图所示：![Installing the Android SDK](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00269.jpeg)

Android SDK 工具安装

1.  安装完成后，打开`C:\Program Files (x86)\Android\android-sdk`目录，并双击`SDK Manager.exe`。确保选择 Android SDK 平台工具和任何一个 Android 的发布平台版本，如下面的屏幕截图所示。有些项目会自动选择。例如，Google USB 驱动程序在 Windows 上与 Android 设备一起使用时是必需的，并且默认已选择。接受许可证条款，然后点击**安装**按钮进行安装：![安装 Android SDK](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00270.jpeg)

Android 软件包安装

前面过程的最后一步需要一些时间来完成。完成后，Android SDK 安装就完成了。现在可以通过指向可执行文件来更新系统的环境变量（路径）。

### 注意

仅 2MB 大小的最小 ADB 和 fastboot 工具可在 XDA 论坛（[`forum.xda-developers.com/showthread.php?t=2317790`](http://forum.xda-developers.com/showthread.php?t=2317790)）上免费获得，无需安装完整的 Android SDK。这个工具是一个 Windows 安装程序，可以快速轻松地安装最新版本的 ADB 和 fastboot。

## Android 虚拟设备

安装了 Android SDK 后，您可以创建一个**Android 虚拟设备**（**AVD**），这是一个在工作站上运行的**模拟器**。开发人员在创建新应用程序时通常会使用模拟器。然而，在取证调查中，模拟器也被认为是有帮助的。它允许调查人员了解某些应用程序的行为以及应用程序的安装如何影响设备。另一个优点是您可以设计一个具有所需版本的模拟器。这在处理运行较旧版本 Android 的设备时特别有帮助。此外，AVD 默认带有 root 权限。

以下步骤将指导您在工作站上创建 AVD：

1.  打开命令提示符（`cmd.exe`）。要从命令行启动 AVD 管理器，请导航到 SDK 安装的路径，并按照以下所示使用`avd`选项调用 android 工具：

```kt
C:\Program Files (x86)\Android\android-sdk\tools>android avd

```

这将自动打开 AVD 管理器，如下面的屏幕截图所示。AVD 管理器也可以使用图形 AVD 管理器启动。要启动它，请导航到 SDK 安装的位置，并双击`AVD Manager`。

![Android 虚拟设备](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00271.jpeg)

Android 虚拟设备管理器

1.  在**AVD 管理器**窗口中单击**创建**以创建新的虚拟设备。单击**编辑**以更改现有虚拟设备的配置，如下面的屏幕截图所示：![Android 虚拟设备](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00272.jpeg)

AVD 详细信息

1.  根据以下信息输入必要的详细信息：

+   **AVD 名称**：为虚拟设备提供任何名称，例如`MyAVD`。

+   **设备**：根据屏幕大小从可用选项中选择任何设备。

+   **目标**：此选项可帮助您选择设备的平台。请注意，只有在 SDK 安装期间选择并安装的那些版本才会显示在此处供您选择。平台版本可以根据所占设备的操作系统进行选择。例如，我们选择了 Android 4.4.2 平台。

+   **硬件**：您可以选择硬件功能来自定义模拟器，例如内部存储器的大小，SD 卡等。再次，可以根据所占设备的详细信息选择屏幕分辨率、硬件等详细信息。

1.  完成后，**AVD 管理器**屏幕将显示新创建的 AVD 列在**Android 虚拟设备**选项卡下。选择 AVD 并单击**启动**。然后，单击**启动**。

1.  模拟器将自动启动。这可能需要几分钟，具体取决于工作站的 CPU 和 RAM。以下是 AVD 成功启动后的截图：![Android 虚拟设备](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00273.jpeg)

安卓模拟器

模拟器可用于配置电子邮件帐户、安装应用程序、浏览互联网、发送短信等。取证分析师和安全工程师可以通过利用模拟器并检查网络、文件系统和数据遗物来学习关于安卓及其运行方式的大量知识。在模拟器上工作时创建的数据存储在您的主目录中，名为.android 的文件夹中。例如，在我们的示例中，我们之前创建的`MyAVD`模拟器的详细信息存储在`C:\Users\Rohit\.android\avd\MyAVD.avd`中。在此目录下有几个文件，以下是取证分析师感兴趣的一些文件：

+   `cache.img`：这是`/cache`分区的磁盘映像。

+   `sdcard.img`：这是 SD 卡分区的磁盘映像。

+   `Userdata-qemu.img`：这是`/data`分区的磁盘映像。`/data`分区包含有关设备用户的宝贵信息。

+   `config.ini`：这是存储 AVD 本地目录中硬件选项的配置文件。

+   `emulator-user.ini`：此文件包含可以重置窗口位置的值。

+   `Androidtool.cfg`：此文件可用于手动设置 Android SDK 的代理设置。

# 连接并从工作站访问安卓设备

为了从安卓设备中提取信息，首先需要将其连接到工作站。如前所述，应注意确保工作站在法庭上是无菌的，并且仅用于调查目的。无菌的工作站是指具有适当构建并且没有病毒和其他恶意软件的工作站。当设备连接到计算机时，可以对设备进行更改。因此，法庭鉴定人员必须始终控制设备。在移动取证领域，使用写保护机制可能并不是很有帮助，因为它们会阻止成功获取设备。这是因为在获取过程中，需要向设备发送某些命令以提取必要的数据。

## 识别设备电缆

可以使用设备的物理 USB 接口将安卓设备连接到工作站。这个物理 USB 接口允许设备与计算机连接、共享数据并充电。USB 接口可能会因制造商和设备而异。有不同类型，如迷你 USB、微型 USB 和其他专有格式。以下是最常用连接器类型的简要描述：

| 连接器类型 | 描述 |
| --- | --- |
| --- | --- |
| Mini—A USB | 大约 7 x 3 毫米大小，其中一长边的两个角被抬起。 |
| Micro—B USB | 大约 6 x 1.5 毫米大小，两个角被切掉形成梯形。 |
| 同轴 | 它有一个圆形孔，中间竖立着一个针。有不同尺寸，直径从 2 到 5 毫米不等。这种类型广泛用于诺基亚手机。 |
| D 亚迷你 | 它呈矩形，两个圆角。矩形的长度不等，但高度始终为 1.5 到 2 毫米。这种类型主要由三星和 LG 设备使用。 |

因此，获取的第一步是确定需要什么类型的设备电缆。

## 安装设备驱动程序

只有在电脑上安装了必要的设备驱动程序时，移动设备才能与电脑通信。如果没有必要的驱动程序，电脑可能无法识别和使用连接的设备。由于安卓可能会被制造商修改和定制，没有一个通用的驱动程序适用于所有的安卓设备。每个制造商都有自己的专有驱动程序，并随手机一起分发。因此，识别需要安装的特定设备驱动程序是很重要的。当然，一些安卓取证工具包带有一些通用驱动程序或一组最常用的驱动程序。它们可能无法与所有型号的安卓手机一起使用。一些 Windows 操作系统能够在设备插入后自动检测并安装驱动程序，但往往情况并非如此。每个制造商的设备驱动程序可以在他们各自的网站上找到。

## 访问设备

安装必要的设备驱动程序后，使用 USB 电缆直接将安卓设备连接到电脑以访问它是很重要的。使用正宗的制造商特定电缆很重要，因为通用电缆可能无法正常使用某些设备。此外，调查人员可能会遇到某些驱动程序问题。一些设备可能不兼容 USB 3.0，这可能导致驱动程序安装失败。在这种情况下，建议尝试切换到 USB 2.0 端口。一旦设备连接，它将出现为一个新的驱动器，你可以访问外部存储上的文件。一些旧的安卓设备可能无法访问，除非在设备上启用了**连接存储到 PC**选项（转到**设置** | **USB 工具**）。在这种情况下，连接设备后，需要选择**打开 USB 存储**选项，如下图所示：

![访问设备](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00274.jpeg)

USB 大容量存储连接

这是因为旧的安卓设备需要 USB 大容量存储模式来在电脑和设备之间传输文件。最新的安卓设备使用**媒体传输协议**（**MTP**）或**图片传输协议**（**PTP**），因为 USB 大容量存储协议存在一些问题。使用 USB 大容量存储，驱动器会完全向电脑开放，就像它是一个内部驱动器一样。

然而，问题在于访问存储的设备需要对其进行独占访问。换句话说，当设备驱动连接到电脑时，必须断开与设备上运行的安卓操作系统的连接才能工作。因此，当连接到电脑时，存储在 SD 卡或 USB 存储上的任何文件或应用将无法使用。在 MTP 中，安卓设备不会将其整个存储暴露给 Windows。相反，当你将设备连接到电脑时，电脑会查询设备，设备会以文件和目录列表的形式回应。如果电脑需要下载文件，它会向设备发送文件请求，设备会通过连接发送文件。PTP 也类似于 MTP，通常被数码相机使用。在这种模式下，安卓设备将与支持 PTP 而不支持 MTP 的数码相机应用程序一起工作。在最新的设备上，你可以通过转到**设置** | **存储** | **USB 计算机连接**来选择 MTP 或 PTP 选项。

### 提示

在一些安卓设备上，只有在连接设备到电脑后才能提供选择 MTP 和 PTP 协议的选项。设备连接后，留意屏幕顶部的通知栏，你会看到一个 USB 符号出现。下拉通知栏，你会找到在 MTP 和 PTP 之间切换的选项。

如下截图所示，只有在将设备连接到计算机并拉下通知栏后，才会显示**MTP**和**PTP**选项：

![访问设备](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00275.jpeg)

Android 设备中的 USB PC 连接

在某些 Android 设备（尤其是 HTC）的情况下，连接 USB 电缆时，设备可能会暴露多个功能。例如，如下截图所示，当 HTC 设备连接到工作站时，会显示一个包含四个选项的菜单：

![访问设备](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00276.jpeg)

HTC 设备上的磁盘驱动器选项

默认选择是**仅充电**。选择**磁盘驱动器**选项时，它将被挂载为磁盘驱动器。当设备被挂载为磁盘驱动器时，您将能够访问设备上的 SD 卡。

从法庭的角度来看，SD 卡具有重要价值，因为它可能包含对调查重要的文件。大多数与多媒体相关的图像和大文件都存储在这个外部存储设备中。SD 卡通常使用 FAT16 文件系统格式化，但您可能也会遇到一些使用 FAT32 和其他文件系统的 SD 卡。正如在第一章中讨论的那样，*介绍 Android 取证*，请注意，大多数最近的设备都具有模拟 SD 卡功能，该功能使用设备的 NAND 闪存创建一个不可移动的 SD 卡。因此，可以通过这种方式访问外部存储中的所有敏感文件。但是，存储在`/data/data`下的核心应用程序数据将保留在设备上，无法通过这种方式访问。

# Android 调试桥

在 Android 取证中，**Android 调试桥**（**ADB**）起着非常关键的作用。它位于`<sdk_path>/platform-tools`。要使用 ADB，需要启用**USB 调试**选项。在三星手机上，可以通过转到**设置** | **开发者**选项来访问此选项；如下截图所示：

![Android 调试桥](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00277.jpeg)

Android 中的 USB 调试选项

然而，并非所有设备都是如此，因为不同的设备具有不同的环境和配置功能。有时，检查人员可能需要使用某些技术来访问一些设备上的开发者选项。这些技术是特定于设备的，需要根据设备类型和型号由取证分析师进行研究和确定。

### 注意

在某些设备上，**开发者选项**菜单是隐藏的，可以通过点击**构建号**字段（导航到**设置** | **关于设备**）*七*次来打开。

选择**USB 调试**选项后，设备将在后台运行**adb 守护程序**（**adbd**），并将不断寻找 USB 连接。该守护程序通常在非特权 shell 用户帐户下运行，因此不提供对内部应用程序数据的访问。但是，在 rooted 手机上，adbd 将在 root 帐户下运行，因此可以访问整个数据。在安装了 Android SDK 的工作站上，adbd 将作为后台进程运行。此外，在同一工作站上，将运行一个客户端程序，可以通过发出`adb`命令来调用。我们将在接下来的章节中看到这一点。当启动 adb 客户端时，首先检查 adbd 是否已经运行。如果没有，它将启动一个新的进程来启动 abdb。这些守护程序通过它们的本地主机在端口 5555 到 5585 之间进行通信。偶数端口与设备的控制台通信，而奇数端口用于 adb 连接。adb 客户端程序通过端口 5037 与本地 adbd 通信。

## 使用 adb 访问设备

如前所述，adb 是一个强大的工具，允许您与 Android 设备通信。我们现在将看一下如何使用 adb 并访问通常无法正常访问的设备的某些部分。重要的是要注意，通过 adb 收集的数据可能会或可能不会被法庭接受为证据。这将取决于各国的法律。以下部分列出了一些常用的 adb 命令，它们的含义以及在逻辑顺序中的用法。

### 检测连接的设备

将设备连接到工作站后，在发出其他 adb 命令之前，了解 Android 设备是否正确连接到 adb 服务器是有帮助的。这可以使用`adb.exe` devices 命令来完成，该命令列出连接到计算机的所有设备，如下命令所示。如果模拟器正在运行，它也会列出模拟器：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe devices
List of devices attached
4df16ac5115e4e04        device

```

### 注意

请记住，如果没有安装必要的驱动程序，那么前述命令将显示空白消息。如果遇到这种情况，请从制造商处下载必要的驱动程序并安装它们。

如前述命令所示，输出包含设备的序列号，后跟连接状态。序列号是 ADB 用于识别每个 Android 设备的唯一字符串。连接状态的可能值及其含义在以下行中解释：

+   `offline`：实例未连接到 adb 或未响应。

+   `device`：实例已连接到 adb 服务器。

+   `no device`：没有连接的设备。

### 将命令定向到特定设备

如果有多个设备连接到系统，您必须在发出命令时指定目标设备。例如，考虑以下情况：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe devices
List of devices attached
4df16ac5115e4e04        device
7f1c864544456o6e    device

```

如前述命令行输出所示，有两个设备连接到工作站。在这种情况下，`adb`需要与`-s`选项一起使用，以向您选择的设备发出命令：

```kt
adb shell -s4df16ac5115e4e04

```

类似地，`-d`命令可用于将`adb`命令定向到唯一连接的 USB 设备，`-e`命令可用于将`adb`命令定向到唯一运行的模拟器实例。

### 发出 shell 命令

如第一章中所述，*介绍 Android 取证*，Android 运行在 Linux 内核上，并提供了访问 shell 的方法。使用 ADB，您可以访问一个 shell，在 Android 设备上运行多个命令。对于不熟悉 Linux 环境的人来说，Linux shell 是指一个特殊的程序，允许您通过键盘输入某些命令与其交互。shell 将执行命令并显示它们的输出。

有关 Linux 环境中工作原理的更多详细信息已在本章的*Rooting Android 设备*部分中提供。`adb` shell 命令可用于进入远程 shell，如下命令行输出所示。一旦进入 shell，您可以执行大多数 Linux 命令：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe shell
shell@android:/ $

```

执行命令后，观察到 shell 提示显示给用户。在这个 shell 提示中，可以在设备上执行命令。例如，如下命令行所示，`ls`命令可用于查看目录中的所有文件：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe shell
shell@android:/ $ ls
ls
acct
cache
config
d
data
default.prop
dev
efs
etc
factory
fstab.smdk4x12

```

以下部分解释了一些在与 Android 设备交互时非常有用的广泛使用的 Linux 命令。

### 基本的 Linux 命令

我们现在将看一些 Linux 命令及其在 Android 设备上的使用：

+   `ls`：ls 命令（无选项）列出当前目录中存在的文件和目录。使用`-l`选项，它还显示它们的大小，修改日期和时间，文件所有者及其权限等，如下命令行输出所示：

```kt
shell@android:/ $ ls -l
ls -l
drwxr-xr-x root     root              2015-01-17 10:13 acct
drwxrwx--- system   cache             2014-05-31 14:55 cache
dr-x------ root     root              2015-01-17 10:13 config
lrwxrwxrwx root     root              2015-01-17 10:13 d -> /sys/kernel/debug
drwxrwx--x system   system            2015-01-17 10:13 data
-rw-r--r-- root     root          116 1970-01-01 05:30 default.prop
drwxr-xr-x root     root              2015-01-17 10:13 dev
drwxrwx--x radio    system            2013-08-13 09:34 efs
lrwxrwxrwx root     root              2015-01-17 10:13 etc -> /system/etc

```

同样，以下是可以与 `ls` 命令一起使用的一些选项。根据需求，调查人员可以使用其中一个或多个选项来查看详细信息：

| 选项 | 描述 |
| --- | --- |
| `a` | 列出隐藏文件 |
| `c` | 根据时间戳显示文件 |
| `d` | 仅显示目录 |
| `n` | 显示长格式列表，包括 GID 和 UID 号码 |
| `R` | 同时显示子目录 |
| `t` | 根据时间戳显示文件 |
| `u` | 显示文件访问时间 |

+   `cat`：cat 命令读取一个或多个文件并将它们打印到标准输出，如下面的命令行所示：

```kt
shell@android:/ $ cat default.prop
cat default.prop
#
# ADDITIONAL_DEFAULT_PROPERTIES
#
ro.secure=1
ro.allow.mock.location=0
ro.debuggable=0
persist.sys.usb.config=mtp

```

`>` 运算符可用于将多个文件合并为一个。`>>` 运算符可用于追加到现有文件中。

+   `cd`：`cd` 命令用于从一个目录切换到另一个目录。在从一个文件夹导航到另一个文件夹时使用。以下示例显示了用于切换到系统文件夹的命令：

```kt
shell@android:/ $ cd /system
cd /system
shell@android:/system $

```

+   `cp`：`cp` 命令可用于将文件从一个位置复制到另一个位置。该命令的语法如下：

```kt
$ cp [options] <source><destination>

```

+   `chmod`：`chmod` 命令用于更改文件系统对象（文件和目录）的访问权限。它也可以更改特殊模式标志。该命令的语法如下：

```kt
$ chmod [option] mode files

```

例如，对文件执行 `chmod 777` 可以让所有人都有读取、写入和执行的权限。

+   `dd`：`dd` 命令用于复制文件，根据操作数进行转换和格式化。在 Android 中，`dd` 命令可用于创建 Android 设备的逐位图像。有关成像的更多细节在第五章中有所涵盖，*从 Android 设备物理上提取数据*。以下是需要与此命令一起使用的语法：

```kt
dd if=/test/file of=/sdcard/sample.image

```

+   `rm`：`rm` 命令可用于删除文件或目录。以下是该命令的语法：

```kt
rm file_name

```

+   `grep`：`grep` 命令用于搜索特定模式的文件或输出。以下示例显示了在 `default.prop` 文件中搜索单词 `secure`：

```kt
 shell@android:/ # cat default.prop | grep secure
ro.secure=1

```

+   `pwd`：`pwd` 命令显示当前工作目录。例如，以下命令行输出显示当前工作目录为 `/system`：

```kt
shell@android:/system $ pwd
pwd
/system

```

+   `mkdir`：`mkdir` 命令用于创建新目录。该命令的语法如下：

```kt
mkdir [options] directories

```

+   `exit`：`exit` 命令可用于退出当前所在的 shell。只需在 shell 中输入 `exit` 即可退出。

### 安装应用程序

在取证分析过程中，可能会有需要在设备上安装一些应用程序以提取一些数据的情况。为此，您可以使用 `adb.exe install` 命令。除此命令之外，如下面的命令行输出所示，您需要指定要安装的 `.apk` 文件的路径：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe install C:\rohit\test.apk
4311 KB/s (13855934 bytes in 3.138s)
 pkg: /data/local/tmp/test.apk
Success

```

但是，需要注意的是，在法庭上可能不接受安装第三方应用程序。因此，在设备上安装任何第三方应用程序之前，取证调查人员需要谨慎。

### 从设备中提取数据

您可以使用 `adb pull` 命令将 Android 设备上的文件拉取到本地工作站。以下是使用此命令的语法：

```kt
adb pull <remote><local>

```

在这里，`<remote>` 指的是 Android 设备上文件的路径，`<local>` 指的是需要存储文件的本地工作站位置。例如，以下命令行输出显示了从 Android 设备中将 `Sample.png` 文件拉取到计算机上的 `temp` 文件夹中：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe pull /sdcard/Pictures/MyFolder/Sample.png C:\temp
1475 KB/s (145039 bytes in 0.096s)

```

然而，在普通的 Android 手机上，您将无法使用`adb pull`命令下载所有文件，因为操作系统强制执行的固有安全功能。例如，在未经 root 的 Android 设备上，无法以这种方式访问`/data/data`文件夹中的文件。有关此主题的更多详细信息已在第四章中进行了介绍，*从 Android 设备逻辑提取数据*。

### 将数据推送到设备

您可以使用`adb push`命令将文件从本地工作站复制到 Android 设备。以下是使用此命令的语法：

```kt
adb push <local><remote>

```

这里，`<local>`指的是本地工作站上文件的位置，`<remote>`指的是 Android 设备上需要存储文件的路径。例如，以下命令行输出显示了从计算机复制到 Android 设备的`Pictures`文件夹中的`test.png`文件：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe push C:\temp\test.png /sdcard/Pictures
2950 KB/s (145039 bytes in 0.048s)

```

您只能将文件推送到用户帐户具有特权的文件夹。

### 重新启动 adb 服务器

在某些情况下，您可能需要终止 adb 服务器进程，然后重新启动它。例如，如果 adb 不响应命令。这可能会解决问题。

要停止 adb 服务器，请使用`kill-server`命令。然后，您可以通过发出任何其他 adb 命令来重新启动服务器。

### 查看日志数据

在 Android 中，`logcat`命令提供了一种查看系统调试输出的方式。来自各种应用程序和系统部分的日志被收集在一系列循环缓冲区中，然后可以通过此命令查看和过滤：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe logcat
--------- beginning of /dev/log/main

I/InputReader( 2841): Touch event's action is 0x0 (deviceType=0) [pCnt=1, s=0.40234 ]

I/InputDispatcher( 2841): Delivering touch to current input target: action: 0x0

I/InputDispatcher( 2841): Delivering touch to current input target: action: 0x0

I/InputDispatcher( 2841): Delivering touch to current input target: action: 0x0
...
I/SecCamera-JNI-Java( 2841): stopPreview

V/SecCamera-JNI-Cpp( 2841): release camera

V/SecCamera-JNI-Cpp( 2841): release
...
D/STATUSBAR-BatteryController( 3162): onReceive() - ACTION_BATTERY_CHANGED

D/STATUSBAR-BatteryController( 3162): onReceive() - level:48

D/STATUSBAR-BatteryController( 3162): onReceive() - plugged:2

D/STATUSBAR-BatteryController( 3162): onReceive() - BATTERY_STATUS_CHARGING:

```

这里显示的日志消息只是一个示例消息。在调查过程中，需要仔细分析日志，以收集有关位置详细信息、日期/时间信息、应用程序详细信息等的信息。每个日志都以消息类型指示器开头，如下表所述：

| 消息类型 | 描述 |
| --- | --- |
| `V` | 冗长 |
| `D` | 调试 |
| `I` | 信息 |
| `W` | 警告 |
| `E` | 错误 |
| `F` | 致命 |
| `S` | 静默 |

`logcat`命令也可用于查看完整的蜂窝无线电调试，如下面的命令行输出所示：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe shell logcat –b radio –v time

03-22 17:06:22.155 E/RIL     (12513): RX: 01
03-22 17:06:22.155 D/RILJ    ( 2815): [UNSL]< UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED
03-22 17:06:22.155 D/RILJ    ( 2815): [7100]> OPERATOR
03-22 17:06:22.155 D/RILJ    ( 2815): [7101]> DATA_REGISTRATION_STATE
03-22 17:06:22.155 E/RIL     (12513): TX: Time: 1095039892 / 164875824
03-22 17:06:22.155 E/RIL     (12513): TX: M:IPC_NET_CMD S:IPC_NET_SERVING_NETWORK T:IPC_CMD_GET
 l:7 m:5e a:0
03-22 17:06:22.160 D/RILJ    ( 2815): [7102]> VOICE_REGISTRATION_STATE
03-22 17:06:22.160 D/RILJ    ( 2815): [7103]> QUERY_NETWORK_SELECTION_MODE
03-22 17:06:22.160 E/RIL     (12513): RX: Time: 1095039894 / 164875826
03-22 17:06:22.160 E/RIL     (12513): RX: M:IPC_NET_CMD S:IPC_NET_SERVING_NETWORK T:IPC_CMD_RES
P l:12 m:ff a:5e
03-22 17:06:22.160 E/RIL     (12513): RX: 02 02 04 34 30 34 34 39 23 19 79
03-22 17:06:22.160 D/RILJ    ( 2815): [7100]< OPERATOR {Airtel, Airtel, 40449}
03-22 17:06:22.170 E/RIL     (12513): TX: Time: 1095039906 / 164875839
03-22 17:06:22.170 E/RIL     (12513): TX: M:IPC_NET_CMD S:IPC_NET_REGIST T:IPC_CMD_GET l:9 m:5f
 a:0
03-22 17:06:22.170 E/RIL     (12513): TX: FF 03
03-22 17:06:22.175 E/RIL     (12513): RX: Time: 1095039909 / 164875841
03-22 17:06:22.175 E/RIL     (12513): RX: M:IPC_NET_CMD S:IPC_NET_REGIST T:IPC_CMD_RESP l:12 m:
ff a:5f
03-22 17:06:22.175 E/RIL     (12513): RX: 04 03 02 0B 19 79 E1 4A 2E 01 00
03-22 17:06:22.175 E/RIL     (12513): TX: Time: 1095039909 / 164875841
03-22 17:06:22.175 E/RIL     (12513): TX: M:IPC_NET_CMD S:IPC_NET_REGIST T:IPC_CMD_GET l:9 m:60...

```

# Rooting Android

"Rooting"是一个在 Android 设备方面经常听到的词。作为法医检查员，深入了解这一点至关重要。这将帮助您获得了解设备内部所需的知识。这也将帮助您在调查过程中遇到的几个问题上获得专业知识。Rooting Android 手机已经成为一种常见现象，在调查过程中经常遇到 rooted 手机。此外，根据情况和要提取的数据，检查员本身必须 root 设备才能提取某些数据。以下各节讨论了 rooting Android 设备和其他相关概念。

## 什么是 rooting？

要了解 rooting，了解类 Unix 系统的工作原理至关重要。Linux 和其他类 Unix 系统所基于的原始 Unix 操作系统从一开始就被设计为多用户系统。这主要是因为个人计算机尚不存在，因此有必要有一种机制来分离和保护各个用户的资源，同时允许他们同时使用系统。但是，为了执行特权任务，例如授予和撤销普通用户的权限，访问关键系统文件以修复或升级系统等，有必要拥有具有超级用户访问权限的系统管理员帐户。因此，我们有两种类型的帐户：普通用户帐户，权限较少，以及超级用户或根帐户，具有所有权限。

因此，root 是默认情况下具有对 Linux 或其他类 Unix 操作系统上的所有命令和文件的访问权限的用户名或帐户。它也被称为根帐户、根用户和超级用户。因此，在 Linux 中，根用户有权启动或停止任何系统服务，编辑或删除任何文件，更改其他用户的权限等。您已经了解到 Android 使用 Linux 内核，因此，Linux 中的大多数概念也适用于 Android。然而，当您购买 Android 手机时，通常不允许您以根用户身份登录。对 Android 手机进行 root 操作就是为了在设备上获得这种根访问权限，以执行通常不允许在设备上执行的操作。

理解 root 和**越狱**之间的区别也很重要，因为它们经常被错误地认为是相同的。越狱运行 Apple iOS 的设备允许您删除苹果设置的某些限制和限制。例如，苹果不允许我们在设备上安装未签名的应用程序。因此，通过越狱，您可以安装未经苹果批准的应用程序。相比之下，Android 允许应用程序的侧载。越狱手机涉及同时绕过多个安全限制。因此，在设备上获得根访问权限只是越狱设备的一个方面。

## 为什么要 root？

许多人进行 root 操作的目标是克服运营商和硬件制造商对 Android 设备设置的限制。通过对 Android 设备进行 root 操作，您可以更改或替换系统应用程序和设置，运行需要管理员级权限的专门应用程序，或执行通常对普通 Android 用户不可访问的操作。这些操作包括卸载默认应用程序（特别是随手机附带的垃圾应用程序）。root 操作也是为了进行极端定制；例如，可以下载和安装新的定制 ROM。然而，从取证分析的角度来看，进行 root 操作的主要原因是获得对通常无法访问的系统部分的访问权限。大多数公共 root 工具将导致永久 root，即使在重新启动设备后更改仍然存在。在临时 root 的情况下，设备重新启动后更改将丢失。在取证案例中应始终首选临时 root。

如第一章*介绍 Android 取证*中所解释的，在 Linux 系统中，每个用户被分配一个**唯一用户 ID**（**UID**），用户被隔离开，以便一个用户无法访问另一个用户的数据。同样，在 Android 中，每个应用程序被分配一个 UID，并作为一个单独的进程运行。应用程序 UID 通常按安装顺序分配，从 10001 开始。这些 ID 存储在`/data/system`中的`packages.xml`文件中。除了存储 UID，该文件还存储了每个程序的 Android 权限，如其清单文件中所述。

每个应用程序的私有数据存储在`/data/data`位置，只能被该应用程序访问。因此，在调查过程中，无法访问该位置的数据。然而，对手机进行 root 操作将允许您访问任何位置的数据。需要记住的是，对手机进行 root 操作有几个影响，如下所述：

+   **安全风险**：对手机进行 root 操作可能会使设备面临安全风险。例如，想象一下一个恶意应用程序，它可以访问整个操作系统以及设备上安装的所有其他应用程序的数据。

+   **设备变砖**: 如果 root 操作没有正确进行，可能会导致设备变砖。"变砖"是一个常用词，用于描述无法以任何方式打开的死机手机。

+   **使您的保修失效**：根据制造商和运营商的不同，对设备进行 Root 操作可能会使您的保修失效，因为这会使设备面临多种威胁。

+   法医学意义：对 Android 设备进行 Root 操作将允许调查人员访问更多的数据，但这涉及对设备的某些部分进行修改。因此，只有在绝对必要的情况下才应对设备进行 Root 操作。

## 恢复和快速启动

在处理 Root 过程之前，有必要了解 Android 中的引导加载程序、恢复和快速启动模式。以下部分将详细解释这些内容。

### 恢复模式

Android 手机可以看作是一个具有三个主要分区的设备：引导加载程序、Android ROM 和恢复。引导加载程序位于第一个分区中，是手机开机时运行的第一个程序。这个引导加载程序的主要工作是处理低级硬件初始化并将设备引导到其他分区。它通常默认加载 Android 分区，通常称为 Android ROM。Android ROM 包含运行设备所必需的所有操作系统文件。恢复分区，通常称为原生恢复，用于删除所有用户数据和文件或执行系统更新。

这两种操作都可以从正在运行的 Android 系统开始，也可以通过手动进入恢复模式进行。例如，当您在手机上进行恢复出厂设置时，恢复会启动并擦除文件和数据。同样，通过更新，手机会启动到恢复模式以安装直接写入 Android ROM 分区的最新更新。因此，恢复模式是您在设备上安装任何官方更新时看到的屏幕。

#### 访问恢复模式

恢复映像存储在恢复分区上，它由一个带有硬件按钮控制的 Linux 映像组成。可以通过两种方式访问恢复模式：

+   通过在设备启动时按下某些组合键（通常是在启动过程中按住音量+、音量-和电源按钮）

+   通过向已启动的 Android 系统发出 adb reboot recovery 命令

以下是 Android 设备上原生恢复模式的屏幕截图：

![访问恢复模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00278.jpeg)

Android 原生恢复

原生 Android 恢复意图上功能非常有限。它有重新启动系统、从 adb 和 SD 卡应用更新、恢复出厂设置等选项。然而，自定义恢复提供了更多选项。

#### 自定义恢复

自定义恢复是第三方恢复环境。将这个恢复环境刷入设备将默认的原生恢复环境替换为第三方定制的恢复环境。这些是自定义恢复中包含的最常见功能：

+   完整备份和恢复功能（如 NANDroid）

+   允许未签名的更新包或允许带有自定义密钥的签名包

+   选择性地挂载设备分区和 SD 卡

+   提供 USB 大容量存储访问 SD 卡或数据分区

+   提供完整的 ADB 访问，ADB 守护程序以 root 身份运行

+   功能齐全的 BusyBox 二进制文件（Busybox 是一个包含强大命令行工具的单个二进制可执行文件集合）

+   今天市场上有几种自定义恢复映像可用，例如 ClockworkMod 恢复、TeamWin 恢复项目等。以下屏幕截图显示了 ClockworkMod 恢复 v6.0.2.5 提供的选项：

![自定义恢复](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00279.jpeg)

ClockworkMod 恢复

### 快速启动模式

Fastboot 是一种协议，可用于在设备上重新刷写分区。它是随 Android SDK 一起提供的工具之一。它是恢复模式的替代方案，可用于安装和更新，有时也可用于解锁引导加载程序。在快速启动模式下，可以通过 USB 连接从计算机修改文件系统映像。因此，这是安装恢复映像并在某些情况下启动的一种方式。一旦手机启动到快速启动模式，就可以在内部存储器中刷写图像文件。例如，可以通过 ROM Manager 应用程序以这种方式刷写之前讨论过的自定义恢复映像，如 ClockworkMod 恢复。刷写 ClockworkMod 恢复的最简单方法之一是通过 ROM Manager 应用程序。安装在已 root 的 Android 设备上后，该应用程序提供了**Flash ClockworkMod Recovery**选项来安装恢复：

![快速启动模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00280.jpeg)

从 ROM Manager 应用程序刷入 ClockworkMod 恢复

## 已锁定和未锁定的引导加载程序

引导加载程序可以是已锁定或未锁定的。已锁定的引导加载程序不允许您通过在引导加载程序级别实施限制来对设备的固件进行修改。这通常是通过加密签名验证来完成的。因此，无法向设备刷写未签名代码。换句话说，为了运行任何恢复映像或自己的操作系统，必须首先解锁引导加载程序。解锁引导加载程序可能会导致严重的安全问题。

如果设备丢失或被盗，攻击者只需上传自定义的 Android 引导映像或刷写自定义恢复映像，就可以恢复设备上的所有数据。因此，攻击者可以完全访问设备上包含的数据。因此，在解锁已锁定的引导加载程序时，手机会执行恢厂数据重置，以便擦除所有数据。因此，只有在绝对必要时才执行此操作非常重要。一些设备有官方解锁的方法。对于这些设备，可以将设备放入快速启动模式并运行`fastboot oem unlock`命令来解锁引导加载程序并完全擦除 Android 设备。

一些其他制造商通过不同的方式提供解锁，例如通过他们的网站等。下面的屏幕截图显示了 HTC 网站提供支持以解锁 HTC 设备：

![已锁定和未锁定的引导加载程序](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00281.jpeg)

提供支持解锁引导加载程序的 HTC 网站

## 如何获取 root 权限

本节讨论如何处理已锁定和未锁定的引导加载程序。在具有未锁定引导加载程序的设备上获得 root 访问权限非常容易，而在具有已锁定引导加载程序的设备上获得 root 访问权限则不那么直接。以下各节将详细解释这一点。

### 解锁引导加载程序

在类 Unix 系统中，超级用户是用于系统管理的特殊用户帐户，并具有访问和修改操作系统中所有文件的特权。获取 root 权限的过程主要涉及将**超级用户**（**su**）二进制文件复制到当前进程路径中的位置（`/system/xbin/su`），并使用`chmod`命令授予其可执行权限。因此，这里的第一步是解锁引导加载程序。如在*已锁定和未锁定的引导加载程序*部分中所解释的，根据所涉及的设备，可以通过快速启动模式或遵循特定供应商的引导加载程序解锁过程来完成引导加载程序的解锁。su 二进制文件通常伴随着一个 Android 应用程序，例如 Superuser，每当应用程序请求 root 访问权限时都会提供一个图形提示，如下面的屏幕截图所示：

![解锁引导加载程序](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00282.jpeg)

超级用户请求

一旦引导加载程序被解锁，您就可以对设备进行所有所需的更改。因此，可以通过多种方式复制 su 二进制文件并授予其可执行权限。最常见的方法是启动自定义恢复镜像。这使我们能够将 su 二进制文件复制到系统分区并通过自定义更新包设置适当的权限。

在解锁的引导加载程序设备上，按照以下步骤对设备进行 root：

1.  从[`www.clockworkmod.com/rommanager`](http://www.clockworkmod.com/rommanager)下载自定义恢复镜像，并从[`superuserdownload.com/`](http://superuserdownload.com/)下载 su 更新包。自定义恢复镜像可以是任何支持您的设备的镜像。同样，su 更新包可以是 SuperSU、SuperUser 或您选择的任何其他包。

1.  将自定义恢复镜像和 su 更新包都复制到 Android 设备的 SD 卡上。

1.  接下来，将设备放入快速启动模式。

1.  打开命令提示符，并输入以下命令：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools> fastboot boot recovery.img

```

1.  在上述命令中，`recovery.img`是您下载的恢复镜像。

1.  从“恢复”菜单中，选择“应用更新 zip 文件”选项，并浏览到设备上 su 二进制更新包所在的位置。

### 提示

自 Android 4.1 版本以来，引入了一个名为 sideload 模式的新功能。此功能允许我们通过 ADB 在不事先复制到设备的情况下应用更新 zip。要进行 sideload 更新，请运行`adb sideload su-package.zip`命令，其中`su-package.zip`是计算机上更新包的文件名。

或者，您还可以修改工厂镜像以添加 su 二进制文件。这可以通过解包一个 ext4 格式的系统镜像，添加 su 二进制文件，然后重新打包来完成。如果刷入此镜像，它将包含 su 二进制文件，并且设备将被 root。

### 注意

Rooting 是一个高度特定于设备的过程。因此，在对任何 Android 设备应用这些技术之前，取证调查员需要谨慎。

### 解锁引导加载程序的 root

当引导加载程序被锁定且无法通过任何可用手段解锁时，对设备进行 root 需要我们找到一个可以被利用的安全漏洞。然而，在此之前，重要的是要确定引导加载程序锁的类型。这可能会因制造商和软件版本而异。对于一些手机，可能不允许快速启动访问，但仍可以使用制造商的专有刷机协议进行刷机，比如三星 ODIN。一些设备仅对选定的分区强制执行签名验证，比如引导和恢复。因此，可能无法引导到自定义恢复模式。但是，您仍然可以修改工厂镜像以包含 su 二进制文件，就像前面部分所述的那样。

如果无法通过任何手段解锁引导加载程序，那么唯一的选择就是找到设备上允许我们利用并添加 su 二进制文件的一些漏洞。漏洞可能存在于 Android 内核、以 root 身份运行的进程或其他问题中。这是设备特定的，需要在尝试任何设备之前进行广泛的研究。以下是在对 Android 设备进行 root 时使用的一些常见漏洞利用：

+   psneuter

+   asroot

+   Exploid

+   GingerBreak

+   RageAgainstTheCage

+   飞

+   Levitator

+   zergRush

+   mempodroid

+   Razr 刀片

# 已 root 设备上的 ADB

我们已经看到了如何使用 ADB 工具与设备进行交互并在设备上执行某些命令。然而，在普通 Android 手机上，某些位置，比如`/data/data`，是无法访问的。例如，当您尝试在普通设备上访问`/data/data`时，会出现以下命令行输出：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe shell
shell@android:/ $ cd /data/data
cd /data/data
shell@android:/data/data $ ls
ls
opendir failed, Permission denied

```

这是因为所有应用的私有数据都存储在这个文件夹中。因此，安卓强制执行了安全性。只有 root 用户才能访问这个位置。因此，在已 root 设备上，您将能够看到该位置下的所有数据，就像以下命令中所示：

```kt
C:\Program Files (x86)\Android\android-sdk\platform-tools>adb.exe shell
shell@android:/ # ls /data/data
ls /data/data
android.googleSearch.googleSearchWidget
com.android.MtpApplication
com.android.Preconfig
com.android.apps.tag
com.android.backupconfirm
com.android.bluetooth
com.android.browser
com.android.calendar
com.android.certinstaller
com.android.chrome
com.android.clipboardsaveservice
com.android.contacts
com.android.defcontainer
com.android.email
com.android.exchange
com.android.facelock
com.android.htmlviewer
com.android.inputdevices
com.android.keychain
com.android.mms

```

如前述命令所示，现在可以通过导航到相应的文件夹轻松地看到所有应用程序的私人数据。因此，对于已 Root 的设备上的 ADB 工具非常强大，并允许审查员访问设备上安装的所有应用程序的数据。只要设备没有图案或 PIN 保护，或者已注册到具有 RSA 密钥的机器上，这是可能的。

### 注意

有时，即使在 Root 手机上，您也会看到权限被拒绝的消息。在这种情况下，在执行 adb shell 命令后，尝试输入超级用户模式，输入`su`。如果启用了 Root，您将看到`#`而不需要密码。

# 总结

设置一个适当的取证环境是在对安卓设备进行调查之前至关重要的。安卓 SDK 的安装是必要的，以便使用其中附带的 ADB 等工具。使用 ADB，审查员可以与设备通信，查看设备上的文件夹，并提取数据并将数据复制到设备上。然而，并非所有文件夹都可以以这种方式在普通手机上访问。这是因为设备的安全执行阻止审查员查看包含私人数据的位置。对设备进行 Root 解决了这个问题，因为它提供了对设备上所有数据的无限访问。对于已解锁引导加载程序的设备，对其进行 Root 是直截了当的，而对于已锁定引导加载程序的设备，则涉及利用一些安全漏洞。

有了对访问设备的了解，您现在将在第三章中学习有关数据在安卓设备上的组织以及许多其他细节，*了解安卓设备上的数据存储*。


# 第三章：了解 Android 设备上的数据存储

取证分析的主要目的是从设备中提取必要的数据。因此，为了有效的取证分析，了解存储在设备上的数据类型、存储位置、存储方式以及存储数据的文件系统的细节至关重要。这些知识对于取证分析人员来说非常重要，可以帮助他们做出明智的决定，确定在哪里寻找数据以及可以用来提取数据的技术。在本章中，我们将涵盖以下主题：

+   Android 分区布局和文件层次结构

+   设备上的应用程序数据存储

+   Android 文件系统概述

# Android 分区布局

分区是设备持久存储内存中的逻辑存储单元。分区允许您将可用空间逻辑地划分为可以独立访问的部分。

## Android 中的常见分区

分区布局在不同厂商和版本之间有所不同。然而，一些分区存在于所有 Android 设备中。以下部分解释了大多数 Android 设备中发现的一些常见分区。

### 引导加载程序

这个分区存储手机的引导加载程序。这个程序负责在手机启动时初始化低级硬件。因此，它负责引导 Android 内核和引导到其他引导模式，比如恢复模式、下载模式等。

### 引导

顾名思义，这个分区包含了手机启动所需的信息和文件。它包含了内核和 RAM 磁盘。因此，没有这个分区，手机无法启动其进程。

### 恢复

恢复分区允许设备通过恢复控制台启动，通过该控制台执行诸如手机更新和其他维护操作等活动。为此，存储了一个最小的 Android 引导映像。这个引导映像作为一个保险措施。

### 用户数据

这个分区通常被称为数据分区，是设备的应用程序数据的内部存储。大部分用户数据都存储在这里，这也是我们的大部分取证证据所在。它还存储了所有应用程序数据和标准通信。

### 系统

除了内核和 RAM 磁盘之外的所有主要组件都在这里。Android 系统映像包含了 Android 框架、库、系统二进制文件和预安装的应用程序。没有这个分区，设备无法启动到正常模式。

### 缓存

这个分区用于存储频繁访问的数据和各种其他文件，比如恢复日志和通过蜂窝网络下载的更新包。

### 无线电

具有电话功能的设备在这个分区中存储了基带映像，负责各种电话活动。

## 识别分区布局

对于给定的 Android 设备，分区布局可以通过多种方式确定。`/proc`目录下的`partitions`文件给出了设备上所有分区的详细信息。以下截图显示了`partitions`文件的内容：

![识别分区布局](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00283.jpeg)

Android 中的分区文件

前面截图中的条目只显示了块名称。要获取这些块与它们的逻辑功能的映射，请检查`/dev/block/platform/dw_mmc`目录下的`by-name`目录的内容。以下截图显示了该目录的内容：

![识别分区布局](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00284.jpeg)

块到它们的逻辑功能的映射

如前所示，分区布局中存在各种分区，如系统、用户数据等。

# Android 文件层次结构

为了对任何系统（桌面或移动）进行取证分析，了解底层文件层次结构是很重要的。对 Android 如何在文件和文件夹中组织数据有基本的了解，有助于取证分析人员将研究范围缩小到特定位置。如果你熟悉类 Unix 系统，你会很好地理解 Android 中的文件层次结构。在 Linux 中，文件层次结构是一个单一的树，树的顶部被表示为`/`。这被称为**根**。这与在驱动器中组织文件的概念（如 Windows）不同。无论文件系统是本地还是远程，它都会存在于根下。Android 文件层次结构是这个现有 Linux 层次结构的定制版本。根据设备制造商和底层 Linux 版本，这个层次结构的结构可能会有一些微不足道的变化。要查看完整的文件层次结构，你需要有 root 访问权限。下面的截图显示了 Android 设备上的文件层次结构：

![Android 文件层次结构](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00285.jpeg)

Android 根目录下的文件夹

## 目录概述

接下来的部分将概述 Android 设备文件层次结构中存在的目录。

### acct

这是 acct cgroup（控制组）的挂载点，用于用户账户。

### 缓存

这是 Android 存储频繁访问的数据和应用组件的目录（`/cache`）。清除缓存不会影响个人数据，只是删除其中的现有数据。这个文件夹中还有另一个名为`lost+found`的目录。这个目录在文件系统损坏的情况下（例如不正确地移除 SD 卡而没有卸载等）会保存恢复的文件（如果有的话）。缓存可能包含取证相关的证据，例如图片、浏览历史和其他应用数据。

### d

这是一个符号链接到`/sys/kernel/debug`。这个文件夹用于挂载 debugfs 文件系统和调试内核。

### 数据

这是包含每个应用程序数据的分区。用户的大部分数据，例如联系人、短信、拨打的号码等，都存储在这个文件夹中。从取证的角度来看，这个文件夹非常重要，因为它包含有价值的数据。下面的截图显示了这个分区中存在的文件夹：

![data](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00286.jpeg)

Android 设备数据分区的内容

接下来的部分将简要解释`data`文件夹下其他重要子目录的内容。

#### dalvik-cache

如第一章*介绍 Android 取证*中所讨论的，Android 应用程序包含优化过的 Java 字节码的`.dex`文件。当应用程序安装在 Android 设备上时，对应的`.dex`文件会进行一些修改，并创建一个名为`.odex`文件（优化的`.dex`文件）。然后将其缓存到`/data/dalvik-cache`目录中，以便在每次加载`application.log`时不必执行优化过程。

这个文件夹包含一些日志，根据具体需求，在检查过程中可能会有用。例如，下面的截图显示了一个名为`recovery_log.txt`的日志文件，其中包含有关恢复日志的详细信息：

![dalvik-cache](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00287.jpeg)

recovery_log.txt 文件输出

#### data

`/data/data`分区包含所有应用程序的私有数据。用户的大部分数据存储在这个文件夹中。从取证的角度来看，这个文件夹非常重要，因为它包含有价值的数据。这个分区在*内部存储*部分有详细介绍。

### dev

这个目录包含所有设备的特殊设备文件。这是 tempfs 文件系统的挂载点。这个文件系统定义了应用程序可用的设备。

### init

正如在第一章中所讨论的，*介绍 Android 取证*，在启动 Android 内核时，将执行 init 程序。此程序位于此文件夹下。

### mnt

此目录用作所有文件系统、内部和外部 SD 卡等的挂载点。以下屏幕截图显示了此目录中的挂载点：

![mnt](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00288.jpeg)

### proc

这是 procfs 文件系统的挂载点，提供对内核数据结构的访问。几个程序使用`/proc`作为其信息的来源。它包含有关进程的有用信息的文件。例如，如下屏幕截图所示，`/proc`下的`meminfo`提供有关内存分配的信息：

![proc](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00289.jpeg)

Android 中 proc 文件夹下的 meminfo 文件

### root

这是 root 账户的主目录。只有在设备被 root 后才能访问此文件夹。

### sbin

这包含了一些重要守护进程的二进制文件。从取证角度来看，这并不是很重要。

### misc

正如名称所示，此文件夹包含有关杂项设置的信息。这些设置主要定义状态，即开/关。有关硬件设置、USB 设置等信息可以从此文件夹中访问。

### sdcard

这是包含设备 SD 卡上数据的分区。请注意，此 SD 卡可以是可移动存储或不可移动存储。您手机上具有`WRITE_EXTERNAL_STORAGE`权限的任何应用程序都可以在此位置创建文件或文件夹。大多数手机上都有一些默认文件夹，如`android_secure`、`Android`、`DCIM`、`media`等。以下屏幕截图显示了`/sdcard`位置的内容：

![sdcard](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00290.jpeg)

Android 设备的 sdcard 分区的内容

**数码相机图像**（**DCIM**）是数码相机、智能手机、平板电脑和相关固态设备的默认目录结构。一些平板电脑有一个指向相同位置的`photos`文件夹。在`DCIM`中，您会找到您拍摄的照片、视频和缩略图（缓存）文件。照片存储在`/DCIM/Camera`中。

Android 开发者参考解释了一些公共存储目录，这些目录与特定程序没有特定的关联。以下是这些文件夹的快速概述：

+   `音乐：`媒体扫描器将此处找到的所有媒体分类为用户音乐。

+   `播客：`媒体扫描器将此处找到的所有媒体分类为播客。

+   `铃声：`此处的媒体文件被分类为铃声。

+   `闹钟：`此处的媒体文件被分类为闹钟。

+   `通知：`此位置下的媒体文件用于通知声音。

+   `图片：`除了用相机拍摄的照片外，所有照片都存储在此文件夹中。

+   `电影：`除了用相机拍摄的电影外，所有电影都存储在此文件夹中。

+   `下载：`各种下载存储在此文件夹中。

### system

此目录包含库、系统二进制文件和其他与系统相关的文件。与手机一起预装的应用程序也存在于此分区中。以下屏幕截图显示了 Android 设备上系统分区中的文件：

![system](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00291.jpeg)

Android 设备系统分区的内容

以下是`/system`分区中一些有趣的文件和文件夹，对取证调查员很有兴趣。

#### build.prop

该文件包含了给定设备的所有构建属性和设置。对于取证分析师来说，该文件提供了有关设备型号、制造商、Android 版本以及许多其他细节的概述。可以通过发出`cat`命令来查看此文件的内容，如下面的屏幕截图所示：

![build.prop](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00292.jpeg)

build.prop 文件输出

如前面的输出所示，您可以通过查看此文件内容来找出产品型号、CPU 详细信息和安卓版本。在已 root 的设备上，调整`build.prop`文件可能会导致多个系统设置的更改。

#### 应用程序

此文件夹包含系统应用程序和预安装的应用程序。这被挂载为只读，以防止任何更改。以下屏幕截图显示了此文件夹中存在的各种与系统相关的应用程序：

![app](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00293.jpeg)

/system/app 分区下的系统应用程序

除了 APK 文件，您可能还注意到了前面输出中的`.odex`文件。在安卓中，应用程序以`.apk`扩展名的包形式存在。这些 APK 包含`.odex`文件，其假定的功能是节省空间。`.odex`文件是应用程序的某些部分在引导前进行优化的集合。

#### 框架

此文件夹包含 Android 框架的源代码。在此分区中，您可以找到关键服务的实现，例如具有包和活动管理器的系统服务器。还在这里完成了 Java 应用程序 API 和本地库之间的大部分映射。

### ueventd.goldfish.rc 和 ueventd.rc

这些文件包含了`/dev`目录的配置规则。

总之，这是来自[`wiki.robotz.com/index.php/Android_File_System`](http://wiki.robotz.com/index.php/Android_File_System)的 Android 文件树参考的屏幕截图：

![ueventd.goldfish.rc 和 ueventd.rc](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00294.jpeg)

安卓文件树

# 设备上的应用程序数据存储

安卓设备通过应用程序存储了大量敏感数据。尽管我们之前将应用程序分类为系统和用户安装的应用程序，但这里有一个更详细的划分：

+   随安卓一起提供的应用程序

+   由制造商安装的应用程序

+   由无线运营商安装的应用程序

+   用户安装的应用程序

所有这些在设备上存储了不同类型的数据。应用程序数据通常包含了与调查相关的大量信息。以下是可能在安卓设备上找到的数据的样本列表：

+   短信

+   MMS

+   聊天消息

+   备份

+   电子邮件

+   通话记录

+   联系人

+   图片

+   视频

+   浏览器历史

+   GPS 数据

+   下载的文件或文档

+   属于已安装应用程序的数据（Facebook、Twitter 和其他社交媒体应用程序）

+   日历约会

属于不同应用程序的数据可以存储在内部或外部。在外部存储（SD 卡）的情况下，数据可以存储在任何位置。但是，在内部存储的情况下，位置是预定义的。具体来说，设备上所有应用程序（无论是系统应用程序还是用户安装的应用程序）的内部数据都会自动保存在`/data/data`子目录中，以包名称命名。例如，默认的安卓电子邮件应用程序的包名为`com.android.email`，内部数据存储在`/data/data/com.android.email`中。我们将在接下来的部分详细讨论这一点，但现在，这些知识足以理解以下细节。

安卓为开发人员提供了一些选项来将数据存储到设备上。可以使用的选项取决于要存储的基础数据。属于应用程序的数据可以存储在以下位置之一：

+   共享首选项

+   内部存储

+   外部存储

+   SQLite 数据库

+   网络

以下各节提供了关于每个选项的清晰解释。

## 共享首选项

此位置提供了一个框架，用于以`.xml`格式存储原始数据类型的键值对。原始数据类型包括布尔值、浮点数、整数、长整数和字符串。字符串以**通用字符集转换格式-8**（**UTF-8**）格式存储。这些文件通常存储在应用程序的`/data/data/<package_name>/shared_prefs`路径中。例如，安卓电子邮件应用程序的`shared_prefs`文件夹包含少于六个`.xml`文件，如下屏幕截图所示：

![共享偏好设置](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00295.jpeg)

Android 电子邮件应用的`shared_prefs`文件夹的内容

如第二章中所述，可以使用`cat`命令查看这些文件的内容。以下截图显示了`com.android.email_preferences.xml`文件的内容：

![共享偏好设置](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00296.jpeg)

Android 电子邮件应用的共享偏好设置文件内容

如前面的截图所示，数据存储在名称-值对中。也许在前面的`.xml`文件中，`account_name`、`account_password`、`recent_messages`是取证调查中一些有趣的参数。许多应用程序使用共享偏好设置来存储敏感数据，因为它很轻量级。因此，在取证调查中，它们可以成为信息的关键来源。

## 内部存储

这些文件存储在内部存储中。这些文件通常位于应用程序的`/data/data`子目录中。存储在这里的数据是私有的，其他应用程序无法访问。甚至设备所有者也无法查看这些文件（除非他们具有 root 访问权限）。但是，根据需求，开发人员可以允许其他进程修改和更新这些文件。

以下截图显示了存储在`/data/data`目录中的应用程序及其包名称的详细信息：

![内部存储](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00297.jpeg)

Android 中`/data/data`文件夹的内容

每个应用程序的内部数据都存储在它们各自的文件夹中。例如，以下截图显示了 Android 设备上 Twitter 应用程序的内部存储：

![内部存储](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00298.jpeg)

Android Twitter 应用的内部存储

通常，大多数应用程序都会创建`databases`、`lib`、`shared_pref`、`cache`文件夹。以下表格提供了这些文件夹的简要描述：

| 子目录 | 描述 |
| --- | --- |
| shared_prefs | 共享偏好设置的 XML 文件 |
| lib | 应用程序所需的自定义库文件 |
| files | 开发人员保存的文件 |
| cache | 应用程序缓存的文件 |
| databases | SQLite 和日志文件 |

除了这些文件夹之外，还有一些是应用程序开发人员创建的自定义文件夹。`databases`文件夹包含了在取证调查中有帮助的关键数据。如下截图所示，该文件夹中的数据存储在 SQLite 文件中：

![内部存储](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00299.jpeg)

Android 浏览器应用的 databases 文件夹中存在的 SQLite 文件

可以使用 SQLite Browser 等工具查看这些数据。有关如何提取数据的更多详细信息在第四章中有详细介绍，*从 Android 设备逻辑提取数据*。

## 外部存储

应用程序还可以将文件存储在外部存储中。外部存储可以是可移动介质，如 SD 卡，也可以是手机自带的不可移动存储。对于可移动 SD 卡，只需将 SD 卡取出并插入到其他设备中，数据就可以在其他设备上使用。SD 卡通常采用 FAT32 文件系统格式，但越来越多地使用其他文件系统，如 EXT3 和 EXT4。与内部存储不同，外部存储没有严格的安全执行。换句话说，存储在这里的数据是公开的，其他应用程序可以访问，前提是请求的应用程序具有必要的权限。

例如，前面讨论的 Twitter 应用程序还在 SD 卡的`/Android/data`位置存储了某些文件。应用程序加载的大文件，如图像和视频，通常存储在外部存储中，以便更快地检索。

## SQLite 数据库

SQLite 是许多移动系统中常见的流行数据库格式，用于结构化数据存储。SQLite 是开源的，与许多其他数据库不同，它体积小且功能丰富。Android 通过专用 API 支持 SQLite，因此开发人员可以利用它。SQLite 数据库是取证数据的丰富来源。应用程序使用的 SQLite 文件通常存储在`/data/data/<ApplicationPackageName>/databases`目录下。例如，在 Android 电子邮件应用程序的情况下，以下截图显示了其`databases`文件夹中存在的 SQLite 文件。我们将在接下来的部分更详细地检查这些文件。从取证的角度来看，它们非常有价值，因为它们经常存储应用程序处理的许多重要数据。`databases`文件夹的内容如下截图所示：

![SQLite 数据库](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00300.jpeg)

Android 电子邮件应用程序的数据库文件夹

## 网络

您可以使用网络来存储和检索您自己的基于 Web 的服务上的数据。要进行网络操作，可以使用`java.net.*`和`android.net.*`包中的类。这些包为开发人员提供了与网络、Web 服务器等交互所必需的低级 API。

# Android 文件系统概述

在 Android 取证中，了解文件系统非常重要，因为它帮助我们了解数据的存储和检索方式。对文件系统属性和结构的了解在取证分析过程中将会很有用。文件系统是指数据从卷中存储、组织和检索的方式。基本安装可能基于一个分成多个分区的卷；在这里，每个分区可以由不同的文件系统管理。微软 Windows 用户大多熟悉 FAT32 或 NTFS 文件系统，而 Linux 用户更熟悉 EXT2 或 EXT4 文件系统。就像在 Linux 中一样，Android 也使用挂载点而不是驱动器（如`C:`或`E:`）。每个文件系统定义了自己的规则来管理卷上的文件。根据这些规则，每个文件系统提供了不同的文件检索速度、安全性、大小等。Linux 使用多个文件系统，Android 也是如此。从取证的角度来看，了解 Android 使用的文件系统，并识别对调查具有重要意义的文件系统是很重要的。例如，存储用户数据的文件系统对我们来说是首要关注的，而不是用于引导设备的文件系统。

如前所述，Linux 被认为支持大量的文件系统。系统使用的这些文件系统不是通过驱动器名称访问的，而是合并成一个单一的分层树结构，将这些文件系统表示为一个实体。每当挂载新的文件系统时，它就被添加到这个单一的文件系统树中。

### 注意

在 Linux 中，挂载是将附加文件系统连接到计算机当前可访问的文件系统的行为。

因此，文件系统被挂载到一个目录上，而此文件系统中的文件现在是该目录的内容。这个目录被称为**挂载点**。无论文件系统存在于本地设备还是远程设备上都没有区别。一切都集成到以根目录开始的单一文件层次结构中。每个文件系统都有一个单独的内核模块，该模块使用**虚拟文件系统**（**VFS**）注册它支持的操作。VFS 允许不同的应用以统一的方式访问不同的文件系统。通过将实现与抽象分离，添加新的文件系统变成了编写另一个内核模块的事情。这些模块要么是内核的一部分，要么是按需动态加载的。Android 内核带有一系列文件系统的子集，从**日志文件系统**（**JFS**）到 Amiga 文件系统。当文件系统被挂载时，内核会处理所有后台工作。

### 注意

上述信息引用自[`trikandroid.hol.es/page/100/`](http://trikandroid.hol.es/page/100/)。

## 在 Android 设备上查看文件系统

通过检查`proc`文件夹中存在的`filesystems`文件的内容，可以确定 Android 内核支持的文件系统。可以使用以下命令查看此文件的内容：

```kt
shell@Android:/ $ cat /proc/filesystems
cat /proc/filesystems
nodev sysfs
nodev rootfs
nodev bdev
nodev proc
nodev cgroup
nodev tmpfs
nodev binfmt_misc
nodev debugfs
nodev sockfs
nodev usbfs
nodev pipefs
nodev anon_inodefs
nodev devpts
ext2
ext3
ext4
nodev ramfs
vfat
msdos
nodev ecryptfs
nodev fuse
fuseblk
nodev fusectl
exfat

```

在前面的输出中，由`nodev`属性引导的文件系统未挂载到设备上。

## 常见的 Android 文件系统

Android 中存在的文件系统可以分为三个主要类别，如下所示：

+   闪存文件系统

+   基于媒体的文件系统

+   伪文件系统

### 闪存文件系统

闪存存储器是一种可以按块擦除和重新编程的不断供电的非易失性存储器。由于闪存存储器的特殊特性，需要特殊的文件系统来覆盖介质并处理某些块的长擦除时间。虽然不同的 Android 设备支持的文件系统各不相同，但常见的闪存文件系统如下：

+   **扩展文件分配表**（**exFAT**）：这种文件系统是微软专有的，针对闪存驱动器进行了优化。由于许可要求，它不是标准 Linux 内核的一部分。然而，一些制造商提供对这种文件系统的支持。

+   **闪存友好文件系统**（**F2FS**）：这种文件系统是三星推出的开源文件系统。基本意图是构建一个考虑基于 NAND 闪存的存储设备特性的文件系统。

+   **日志闪存文件系统版本 2**（**JFFS2**）：这种文件系统是 Android 中使用的一种日志结构文件系统。JFFS2 是**Android 开源项目**（**AOSP**）自冰淇淋三明治版本以来的默认闪存文件系统。诸如 LogFS、UBIFS、YAFFS 等文件系统已经被开发作为 JFFS2 的替代品。

+   **另一个闪存文件系统版本 2**（**YAFFS2**）：这种文件系统是一个开源的、单线程的文件系统，于 2002 年发布。它主要设计用于在处理 NAND 闪存时快速。YAFFS2 利用 OOB。这在取证获取过程中通常无法正确捕获或解码，使分析变得困难。YAFFS2 曾经是最受欢迎的版本，并且仍然广泛用于 Android 设备。YAFFS2 是一个日志结构文件系统。即使在突然断电的情况下也能保证数据完整性。2010 年，有一项声明称在 Gingerbread 之后的版本中，设备将从 YAFFS2 转移到 EXT4。目前，YAFFS2 在较新的内核版本中不受支持，但某些手机制造商可能仍然继续支持它。

+   RFS（鲁棒文件系统）：这种类型的文件系统支持三星设备上的 NAND 闪存。RFS 可以总结为启用了事务日志的 FAT16（或 FAT32）文件系统。许多用户抱怨三星应该坚持使用 EXT4。RFS 已知会导致 Android 功能减慢的延迟时间。

### 基于媒体的文件系统

除了之前讨论的闪存文件系统，Android 设备通常支持以下基于媒体的文件系统：

+   扩展文件系统（EXT2/EXT3/EXT4）：这个文件系统是 1992 年专门为 Linux 内核引入的。这是最早的文件系统之一，使用了虚拟文件系统。EXT2、EXT3 和 EXT4 是后续的版本。日志记录是 EXT3 相对于 EXT2 的主要优势。使用 EXT3 时，在意外关机的情况下，无需验证文件系统。第四个扩展文件系统 EXT4 在实现双核处理器的移动设备中变得重要。YAFFS2 文件系统在双核系统上存在瓶颈。在 Android 的 Gingerbread 版本中，YAFFS 文件系统被替换为 EXT4。

+   FAT（文件分配表）：这些文件系统，如 FAT12、FAT16 和 FAT32，都受到 MSDOS 驱动程序的支持。

+   VFAT（虚拟文件分配表）：这个文件系统是 FAT16 和 FAT32 文件系统的扩展。大多数 Android 设备支持微软的 FAT32 文件系统。它被几乎所有主要操作系统支持，包括 Windows、Linux 和 Mac OS。这使得这些系统可以轻松地读取、修改和删除 Android 设备上 FAT32 部分的文件。大多数外部 SD 卡都是使用 FAT32 文件系统格式化的。

### 伪文件系统

除此之外，还有一些伪文件系统，可以被视为文件的逻辑分组。以下是在 Android 设备中发现的一些重要的伪文件系统：

+   cgroup（控制组）：这种伪文件系统提供了一种访问和定义多个内核参数的方式。存在许多不同的进程控制组。如下命令行输出所示，可以在`/proc/cgroups`文件中看到组的列表：![伪文件系统](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00301.jpeg)

cgroups 文件输出

Android 设备使用这种文件系统来跟踪它们的任务。它们负责聚合任务并跟踪它们。

+   rootfs：这种类型的文件系统是 Android 的主要组成部分之一，包含了启动设备所需的所有信息。当设备启动引导过程时，它需要访问许多核心文件，因此会挂载根文件系统。这个文件系统被挂载在`/`（根目录）下。因此，这是所有其他文件系统逐渐挂载的文件系统。如果这个文件系统损坏，设备将无法启动。

+   procfs：这种类型的文件系统包含有关内核数据结构、进程和其他系统相关信息的信息，存储在`/proc`目录中。例如，`/proc/filesystems`文件显示设备上可用文件系统的列表。以下命令显示了设备 CPU 的所有信息：

```kt
shell@Android:/ $ cat /proc/cpuinfo
cat /proc/cpuinfo
Processor : ARMv7 Processor rev 0 (v7l)
processor : 0
BogoMIPS : 1592.52
processor : 3
BogoMIPS : 2786.91
Features : swp half thumb fastmult vfp edsp neon vfpv3 tls
CPU implementer : 0x41
CPU architecture: 7
CPU variant : 0x3
CPU part : 0xc09
CPU revision : 0
Chip revision : 0011
Hardware : SMDK4x12
Revision : 000c
Serial : ****************

```

+   sysfs：这种类型的文件系统挂载了包含设备配置信息的`/sys`文件夹。以下输出显示了 Android 设备中`sys`目录中的各种文件夹：

```kt
shell@Android:/ $ cd /sys
cd /sys
shell@Android:/sys $ ls
ls
block
bus
class
dev
devices
firmware
fs
kernel
module
power

```

由于这些文件夹中的数据大多与配置相关，这对于法医调查人员通常并不重要。然而，在某些情况下，我们可能需要检查手机上是否启用了特定设置。在这种情况下，分析这个文件夹可能是有用的。请注意，每个文件夹都包含大量文件。通过法医获取捕获这些数据是确保在检查过程中不会更改这些数据的最佳方法。

+   **tmpfs**：这种类型的文件系统是设备上的临时存储设施，它将文件存储在 RAM（易失性内存）中。这通常挂载在`/dev`目录上。使用 RAM 的主要优势是其更快的访问和检索。然而，一旦设备重新启动或关闭，这些数据将不再可访问。因此，对于法医调查人员来说，重要的是在设备重新启动之前检查 RAM 中的数据或提取数据。

您可以使用`mount`命令来查看设备上可用的不同分区及其文件系统，如下所示：

```kt
shell@Android:/sdcard $ mount
mount
rootfs / rootfs rw 0 0
tmpfs /dev tmpfs rw,nosuid,relatime,mode=755 0 0
devpts /dev/pts devpts rw,relatime,mode=600,ptmxmode=000 0 0
proc /proc proc rw,relatime 0 0
sysfs /sys sysfs rw,relatime 0 0
tmpfs /mnt/asec tmpfs rw,relatime,mode=755,gid=1000 0 0
tmpfs /mnt/obb tmpfs rw,relatime,mode=755,gid=1000 0 0
/dev/block/nandd /system ext4 rw,nodev,noatime,user_xattr,barrier=0,data=ordered 0 0
/dev/block/nande /data ext4 rw,nosuid,nodev,noatime,user_xattr,barrier=0,journal_checksum,data=or dered,noauto_da_alloc 0 0
/dev/block/nandh /cache ext4 rw,nosuid,nodev,noatime,user_xattr,barrier=0,journal_checksum,data=or dered,noauto_da_alloc 0 0
/dev/block/vold/93:64 /mnt/sdcard vfat rw,dirsync,nosuid,nodev,noexec,relatime,uid=1000,gid=1015,fmask=0702, dmask=0702,allow_utime=0020,codepage=cp437,iocharset=ascii,shortname= mixed,utf8,errors=remount-ro 0 0
/dev/block/vold/93:64 /mnt/secure/asec vfat rw,dirsync,nosuid,nodev,noexec,relatime,uid=1000,gid=1015,fmask=0702, dmask=0702,allow_utime=0020,codepage=cp437,iocharset=ascii,shortname= mixed,utf8,errors=remount-ro 0 0
tmpfs /mnt/sdcard/.Android_secure tmpfs ro,relatime,size=0k,mode=000 0 0
/dev/block/dm-0 /mnt/asec/com.kiloo.subwaysurf-1 vfat ro,dirsync,nosuid,nodev,relatime,uid=1000,fmask=0222,dmask=0222,codep age=cp437,iocharset=ascii, shortname=mixed,utf8,errors=remount-ro 0 0

```

正如前面的命令行输出所示，不同的分区有不同的文件系统，并且它们被相应地挂载。

# 总结

对安卓的分区布局、文件系统和重要位置有充分的了解，将有助于法医调查人员在从设备中提取数据的过程中。安卓设备上的用户数据位置包含了大量对任何法医调查至关重要的用户信息。然而，大多数这些文件可能只能在已获取 root 权限的手机上访问（特别是`/data/data`位置的文件）。您还了解了安卓的数据存储选项、安卓使用的各种文件系统及其重要性。

有了这些知识，您现在将学习如何在接下来的章节中从安卓设备中逻辑和物理地提取数据。


# 第四章：从安卓设备逻辑提取数据

本章将尽可能使用免费和开源工具来覆盖逻辑数据提取。本章大部分内容将使用之前在第二章中讨论过的 ADB 方法。

在本章结束时，读者应该熟悉以下内容：

+   逻辑提取的含义

+   逻辑提取可以期望得到的数据

+   有和没有 Root 权限时可用的数据

+   手动 ADB 数据提取

+   ADB 备份提取

+   ADB dumpsys 信息

+   如何绕过安卓锁屏

+   SIM 卡提取

# 逻辑提取概述

在数字取证中，逻辑提取一词通常用于指不恢复已删除数据的提取，或者不包括证据的完整比特对比拷贝。然而，在第一章中定义的更正确的逻辑提取的定义是任何需要与基本操作系统通信的方法。由于与操作系统的交互，取证员无法确定他们已经恢复了所有可能的数据；操作系统正在选择允许取证员访问哪些数据。

在传统计算机取证中，逻辑提取类似于复制和粘贴文件夹以从系统中提取数据；这个过程只会复制用户可以访问和看到的文件。如果被复制的文件夹中存在任何隐藏或已删除的文件，它们将不会出现在粘贴版本的文件夹中。

然而，移动取证中逻辑提取和物理提取之间的界限要比传统计算机取证模糊得多。例如，由于 SQLite 数据库的普遍使用，可以经常从移动设备的逻辑提取中恢复已删除的数据。此外，几乎每次移动设备的提取都需要与安卓操作系统进行某种形式的交互；没有简单的等同于拔出硬盘并在不启动硬盘的情况下对其进行成像的操作。对于我们的目的，我们将逻辑提取定义为获取用户可见的数据的过程，并且可能包括已标记为删除的数据。

## 哪些数据可以逻辑恢复？

在大多数情况下，任何和所有用户数据都可以通过逻辑方式恢复：

+   联系人

+   通话记录

+   短信/彩信

+   应用程序数据

+   系统日志和信息

这些数据的大部分存储在 SQLite 数据库中，因此甚至可以通过逻辑提取恢复大量已删除的数据。

### Root 权限

在法庭上分析安卓设备时，限制因素通常不是所寻找的数据类型，而是检查员是否有能力访问数据。在第二章中已经广泛涵盖了 Root 访问权限，但这一点很重要，值得重复。上述所有存储在内部闪存存储器上的数据都是受保护的，需要 Root 访问权限才能读取。例外情况是存储在 SD 卡上的应用程序数据，这将在本书后面讨论。

没有 root 权限，法医检查员无法简单地从数据分区复制信息。检查员将不得不找到某种方法来提升他们的权限，以便访问联系人、通话记录、短信/彩信和应用程序数据。这些方法通常带有许多风险，例如可能破坏或“砖化”设备（使其无法启动），并且可能会改变设备上的数据以获得永久性。这些方法通常因设备而异，并且没有通用的、一键式的方法可以获得对每个设备的 root 权限。商业移动法医工具，如**MicroSystemation XRY**和**Cellebrite UFED**，具有内置功能，可以临时和安全地 root 许多设备，但不涵盖所有 Android 设备的广泛范围。

在本章中，我们将注意到每种技术所需的 root 权限。

### 注意

是否对设备进行 root 处理应根据您所在地区的操作程序和法院意见做出决定。通过 root 获取的证据的法律接受程度因司法管辖区而异。

# 手动 ADB 数据提取

ADB 的`pull`命令可用于直接从设备上将单个文件或整个目录拉到法医检查员的计算机上。这种方法对于小型、有针对性的检查特别有用。例如，在严格涉及短信的调查中，检查员可以选择只拉取相关文件。

## USB 调试

ADB 环境的设置在本书中已经讨论过。然而，受检设备也必须正确配置。USB 调试是法医检查员的计算机与设备通信的实际方法。**USB 调试**选项位于**设置**菜单中的**开发者选项**下。然而，从 Android 4.2 开始，开发者选项菜单是隐藏的；要显示它，用户必须转到**设置** | **关于手机**，然后点击**版本号**字段*七*次。屏幕上会出现一个对话框，上面写着**您现在是开发者！**此时，**开发者选项**在**设置**菜单中可用；只需打开此菜单并选择**启用 USB 调试**。

除了 USB 调试，检查员的计算机上还必须安装正确的驱动程序。通常可以在制造商的网站上或[www.xda-developers.com](http://www.xda-developers.com)上找到。如果在计算机上安装了商业法医工具，则可能已经安装了适当的驱动程序。

### 提示

另一个很好的资源是可以免费下载的通用 ADB 驱动程序，网址为[`drivers.softpedia.com/get/MOBILES/Clockworkmod/Clockworkmod-Universal-Android-ADB-Driver.shtml`](http://drivers.softpedia.com/get/MOBILES/Clockworkmod/Clockworkmod-Universal-Android-ADB-Driver.shtml)。

在 Android 4.2.2 之前，启用**USB 调试**是与设备通过 ADB 通信的唯一要求。在 Android 4.2.2 中，Google 添加了**安全 USB 调试**选项。**安全 USB 调试**选项增加了在设备屏幕上选择连接到计算机的额外要求；这可以防止来自不受信任计算机的 ADB 访问被锁定的设备：

![USB 调试](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00302.jpeg)

RSA 指纹对话框

如果选择了**始终允许此计算机**，设备将存储计算机的 RSA 密钥，并且在将来连接到该计算机时，提示将不会出现，即使设备被锁定。

### 提示

根据设备和操作系统版本的不同，可能可以规避**安全 USB 调试**保护。在[`labs.mwrinfosecurity.com/advisories/2014/07/03/android-4-4-2-secure-usb-debugging-bypass/`](https://labs.mwrinfosecurity.com/advisories/2014/07/03/android-4-4-2-secure-usb-debugging-bypass/)上找到更多信息。

还可以通过使用先前获得授权访问设备的计算机来绕过**安全 USB 调试**，这将在本章后面的 Android Lollipop 部分中讨论。

一旦**USB 调试**已启用并且**安全 USB 调试**检查通过（取决于 Android 版本），设备就准备好进行检查了。要验证设备是否已连接并准备使用 ADB，执行以下命令：

```kt
adb devices

```

如果没有显示任何设备，请确保**USB 调试**已启用，并且已安装正确的设备驱动程序：

![USB 调试](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00303.jpeg)

如果设备状态为`离线`或`未授权`，则需要在屏幕上选择**安全 USB 调试**提示：

![USB 调试](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00304.jpeg)

如果一切正常运行，设备状态应显示为`设备`：

![USB 调试](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00305.jpeg)

### 使用 ADB shell 来确定设备是否已 root

确定设备是否已 root 的最简单方法是使用 ADB shell。这将在设备上打开一个 shell，取证人员可以在自己的计算机上访问该 shell；这意味着在 shell 中运行的任何命令都将在设备上执行。一旦**USB 调试**已启用并且**安全 USB 调试**已绕过（或者从恢复模式中，如本章后面讨论的），在本地计算机上打开终端并运行：

```kt
adb shell

```

shell 将以`$`或`#`的方式出现：

![使用 ADB shell 来确定设备是否已 root](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00306.jpeg)

在 Linux 系统中，`#`符号用于表示根用户，`$`符号表示非根用户。如果 shell 返回显示`#`，则 shell 具有根访问权限：

![使用 ADB shell 来确定设备是否已 root](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00307.jpeg)

在一些已 root 的设备上可能需要进一步的步骤。如果 shell 返回`$`，尝试运行`su`命令：

```kt
su

```

如果设备上安装了 su 二进制文件，通常是 root 过程的一部分，这将提升 shell 的权限到 root，如果 shell 没有以 root 权限打开的话。

### 提示

一些旧设备会自动以 root 身份运行 shell；仅仅打开 ADB shell 可能就足以给取证人员 root 访问权限。

## ADB pull

如第二章*设置 Android 取证环境*中讨论的，ADB `pull`命令用于将文件从设备传输到本地工作站。ADB `pull`命令的格式为：

```kt
adb pull [-p] [-a] <remote> [<local>]

```

可选的`-p`标志显示传输的进度，而可选的`-a`标志将复制文件的时间戳和模式。`<remote>`参数是设备上文件的确切路径。可选的`<local>`参数是文件将被写入到取证人员计算机上的路径。如果没有指定本地路径，文件将被写入到当前工作目录。要查看 ADB `pull`命令的样子，运行以下命令：

```kt
adb pull –p /data/data/com.android.providers.telephony/databases/mmssms.db C:/Users/Cases/Case_0001

```

此命令将从设备中拉取短信数据库文件，并将其写入到案例的目录中。再次注意，设备必须已 root 才能正常工作；否则，输出将只显示拉取了`0`个文件。在我们的案例中，获得以下输出：

![ADB pull](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00308.jpeg)

前面的输出显示文件大小为`1020400`字节。由于我们的命令，`mmssms.db`数据库现在位于`Case_0001`文件夹中：

![ADB pull](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00309.jpeg)

从设备中拉取的数据库，在 Windows 资源管理器中可见

现在可以使用 SQL 浏览器或其他取证工具来检查数据库，这将在第七章*Android 应用程序的取证分析*中进行讨论。

同样，如果调查人员希望为整个应用程序拉取文件，也可以使用 ADB pull：

![ADB pull](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00310.jpeg)

这一次，ADB pull 命令获取了`com.google.android.gm`目录中的每个文件，这恰好包含了 Gmail 的所有数据。输出非常长，因为它逐个列出了所有`31`个拉取的文件，所以整个输出在下图中没有显示，我们可以看到传输的总大小显示为`1233373`字节：

![ADB pull](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00311.jpeg)

现在，`Case_0002`目录包含了 Gmail 应用程序的所有文件，如下截图所示：

![ADB pull](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00312.jpeg)

在 Windows 资源管理器中看到的从 Gmail 目录中拉取的所有文件

甚至可以做到以下事情：

```kt
adb pull -p /data/data/ \Cases\Case_0003

```

这将从`/data/data`目录中拉取所有可用的逻辑文件，并将它们放在检查员的`Case_0003`文件夹中。这并不等同于物理镜像，因为某些文件会被跳过，已删除的文件不会被复制，但这是拉取用户应用程序数据绝大部分的简单方法。

ADB `pull`命令的另一个优点是它非常适用于脚本目的。一个知识渊博的检查员可以维护一个常见感兴趣文件路径的列表，并编写一个自动从设备中拉取这些文件的脚本，甚至可以让脚本自动拉取整个`/data/data`目录。一个执行此功能的 Python 代码的简单示例是：

```kt
from subprocess import Popen
from os import getcwd

command = "adb pull /data/data " + getcwd() + "\data_from_device"
p = Popen(command)
p.communicate()
```

请注意，代码并不是非常精练；它的唯一目的是说明 ADB 命令可以被脚本化的简易性。至少，正确实现代码应该包括指定输出目录的选项并处理任何错误。然而，前述代码的六行足以逻辑上拉取整个`/data/data`目录，假设**USB 调试**已启用并且设备已 root。

## 恢复模式

为了真正具有法庭取证的可靠性，不应在手机开机时使用 ADB 数据提取。当设备正在运行时，时间戳可能会被修改，应用程序可能在后台运行并更新文件。为了避免这种情况，检查员应该将设备置于自定义恢复模式中，如第二章中所示，*设置 Android 取证环境*，如果可能的话。通过原始 Android 恢复模式无法访问 ADB。通常，rooting 过程的第一步是刷入自定义恢复模式，以便在出现问题时修复设备。已 root 的设备更有可能包含自定义恢复模式，但是也有可能将自定义恢复模式刷入未 root 的设备。这种方法还允许检查员避免在较新版本的 Android 上出现的**安全 USB 调试**提示，尽管我们的测试显示这在 Android Lollipop 上不起作用。恢复模式也可能不需要启用**USB 调试**，这使其成为绕过锁定设备的绝佳选择。

### 注意

这种方法不适用于启用了全盘加密的设备。进入恢复模式将*不*解密数据分区。

进入恢复模式的过程对于每个设备都会有所不同。通常情况下，它涉及一些关机并按住音量和电源键的组合。特定型号的指南可以在线找到。

原始恢复模式通常会显示一个正在操作的 Android 的图片：

![恢复模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00313.jpeg)

原始恢复模式

自定义恢复模式看起来像以下的截图。此外，原始恢复模式将不允许 ADB 通信；运行 adb devices 将只显示没有设备。

### 注意

许多设备的自定义恢复镜像可以在[`www.clockworkmod.com/rommanager`](https://www.clockworkmod.com/rommanager)和[`teamw.in/project/twrp2`](http://teamw.in/project/twrp2)找到。

如果设备处于自定义恢复模式，并且在审查员的计算机上安装了正确的驱动程序，则可以通过 ADB 访问设备，就像它是活动的一样。请注意，使用 adb devices 命令现在显示它处于恢复模式：

![恢复模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00314.jpeg)

在审查员可以开始通过 ADB 提取数据之前，还有最后一步：必须挂载数据分区以访问用户数据。一些自定义恢复可能会自动挂载这个分区，而其他可能不会。如果使用上面的 URL 中的 Clockwork Mod Recovery 或 Team Win Recovery Project（TWRP）映像，可以通过选择 Mounts 然后选择数据分区来挂载数据分区，如下面的屏幕截图所示。恢复菜单通常可以使用音量键上下移动和电源按钮选择，或者根据使用的自定义恢复映像而可能是基于触摸的。

对于 TWRP 恢复，从主恢复屏幕中选择**Mount**：

![恢复模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00315.jpeg)

选择**Mount**后，选择要挂载的分区：

![恢复模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00316.jpeg)

在 Clockwork Mod Recovery 中，选择 mounts and storage：

![恢复模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00317.jpeg)

然后选择要挂载的分区：

![恢复模式](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00318.jpeg)

一旦数据分区（以及审查员想要调查的任何其他分区）被挂载，审查员就可以执行 ADB 数据提取，就像本章前面演示的那样。

如果设备没有自定义恢复，下一节将显示如何启动到自定义恢复。

## 快速启动模式

Fastboot 是 Android SDK 中内置的另一个协议实用程序，用于直接与设备的引导加载程序进行交互。基本上，它是 ADB 的一个更低级别版本，并且经常用于向设备刷入新映像。这对审查员有什么帮助呢？

Fastboot 可以允许审查员从自定义恢复映像启动，并临时获得设备的 root 访问权限，从而访问以其他方式无法访问的数据。Fastboot 不需要启用 USB 调试或 root 访问权限。将自定义引导加载程序加载到设备上通常由商业取证工具使用，以临时获取设备的 root 权限，但是熟练的审查员也可以手动执行该过程。使用此方法，恢复映像加载到 RAM 中；设备上的任何永久数据都不会以任何方式被更改。

使用 fastboot 最重要的要求是解锁引导加载程序；锁定的引导加载程序将不允许设备从制造商专门签名的代码启动。不幸的是，出于取证目的，大多数设备不再出厂时带有解锁的引导加载程序，因为这是一个严重的安全风险，并且手动解锁引导加载程序通常会擦除用户数据。因此，这种方法适用的设备数量有些有限。但是，当它起作用时，对于审查员来说，这是一个绝对无价的工具。

### 注意

此方法不适用于启用了全盘加密的设备。进入恢复模式将*不*解密数据分区。

### 确定引导加载程序状态

与涉及 Android 取证的所有内容一样，确定引导加载程序是否已锁定没有一种保证的方法，因为这取决于制造商。要进入引导加载程序，请使用以下 ADB 命令：

```kt
adb reboot bootloader

```

设备应该启动到显示有关引导加载程序的信息的屏幕。通常，此屏幕将显示引导加载程序状态，如下面的屏幕截图所示。

以下是 Nexus 5 的通用、原始快速启动菜单。请注意，**Lock State**指示引导加载程序已解锁：

![确定引导加载程序状态](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00319.jpeg)

标准的 HTC 快速启动屏幕如下：

![确定引导加载程序状态](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00320.jpeg)

以下是标准的三星**Odin**模式屏幕；Odin 是三星专有的等效快速启动：

![确定引导加载程序状态](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00321.jpeg)

### 引导到自定义恢复映像

确定引导加载程序已解锁后，检查员将需要一个自定义恢复映像来引导。恢复映像的绝佳来源是[`www.clockworkmod.com/rommanager`](https://www.clockworkmod.com/rommanager)或[`teamw.in/twrp_view_all_devices`](http://teamw.in/twrp_view_all_devices)。这两个网站都提供各种设备的覆盖，并且将为此方法提供相同的功能。

### 注意

对于正在检查的设备，选择正确的恢复映像绝对至关重要；它们不能互换，从错误的映像引导可能会砖化设备。

选择并下载恢复映像后，需要将设备放入快速启动模式。可以通过以下两种方式之一完成：

+   ADB

+   物理设备按钮

要通过 ADB 进入快速启动设备，设备必须已启用**USB 调试**。通过 ADB 进入快速启动模式的命令是：

```kt
adb reboot bootloader

```

如果无法启用 USB 调试或无法使用 ADB，通常还有一组按钮组合可在设备启动时按下，类似于进入恢复模式。可以在线找到每个设备特定的确切组合。

设备进入快速启动模式后，运行以下命令将验证设备是否已连接并准备好通信：

```kt
fastboot devices

```

以下命令将加载自定义恢复映像到 RAM 并将设备引导到恢复模式：

```kt
fastboot boot 'path to image'

```

![引导到自定义恢复映像](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00322.jpeg)

设备现在应该重新启动并进入恢复模式。如恢复模式部分所示，可能需要挂载/data 分区以访问用户数据。

进入 ADB shell 将显示检查员现在具有根访问权限。设备将允许根访问权限，直到重新启动。

![引导到自定义恢复映像](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00323.jpeg)

如果快速启动引导命令失败，则很可能表明设备的引导加载程序已锁定，如下面的屏幕截图所示：

![引导到自定义恢复映像](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00324.jpeg)

# ADB 备份提取

Google 在 Android 4.0 冰淇淋三明治中实现了 ADB 备份功能。这允许用户（和取证检查员）通过 ADB 将应用程序数据备份到本地计算机。此过程不需要根权限，因此对于取证目的非常有用。但是，它不会获取设备上安装的每个应用程序。当开发人员创建新应用程序时，默认情况下将其设置为允许备份，但开发人员可以更改此设置。实际上，似乎绝大多数开发人员保留默认设置，这意味着备份可以捕获大多数第三方应用程序。不幸的是，大多数 Google 应用程序禁用备份；来自应用程序（如 Gmail 和 Google Maps）的完整应用程序数据将不包括在内。

### 提示

此方法对于锁定的设备将无效，因为需要用户与屏幕进行交互。

## 通过 ADB 提取备份

ADB 备份命令的格式是：

```kt
adb backup [-f <file>] [-apk|-noapk] [-obb|-noobb] [-shared|-noshared] [-all] [-system|-nosystem] [<packages...>]

```

以下是标志：

+   `-f`：为输出文件命名路径。如果未指定，默认为当前工作目录中的`backup.ab`。

+   `[-apk|noapk]`：选择是否备份`.apk`文件。默认为`-noapk`。

+   `[-obb|-noobb]`：选择是否备份`.obb`（APK 扩展）文件。默认为`-noobb`。

+   `[-shared|-noshared]`：选择是否备份共享存储和 SD 卡中的数据。默认为`-noshared`。

+   `[-all]`：包括启用备份的所有应用程序。

+   `[-system|-nosystem]`：选择是否包括系统应用程序。默认为`-system`。

+   `[<packages>]`：显式命名要备份的应用程序包。如果使用`-all`或`-shared`，则不需要。

捕获所有可能的应用程序数据的示例 ADB 备份命令如下：

```kt
adb backup –f C:/Users/Cases/Case_0001/backup.ab –shared –all

```

或者，捕获特定应用程序数据的示例 ADB 备份命令如下：

```kt
adb backup –f C:/Users/Cases/Case_0001/facebook.ab com.facebook.katana

```

您应该看到类似的东西：

![通过 ADB 提取备份](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00325.jpeg)

在执行备份时，用户必须在设备上批准备份。这意味着不能绕过屏幕锁定进行备份：

![通过 ADB 提取备份](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00326.jpeg)

在设备上接受备份

根据安装的应用程序数量，备份过程可能需要相当长的时间。

## 解析 ADB 备份

生成的备份数据存储为`.ab`文件，但实际上是使用**Deflate**算法压缩的`.tar`文件。如果在创建备份时在设备上输入了密码，文件也将被 AES 加密。还应该提到，这些文件可能存在于嫌疑人的计算机上，并且可以使用相同的方法进行分析。

有许多免费的实用程序可以将`.ab`备份文件转换为可以查看的`.tar`文件。其中一个实用程序是 Android 备份提取工具，位于[`sourceforge.net/projects/adbextractor/`](http://sourceforge.net/projects/adbextractor/)。 

要使用 Android 备份提取工具，只需将其文件提取到备份所在的目录中。运行该实用程序的命令是：

```kt
java -jar abe.jar unpack backup.ab backup.tar

```

如果命令正确运行，命令行将显示如下内容：

![解析 ADB 备份](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00327.jpeg)

输出的第一行通知审查员文件未加密。如果文件已加密，审查员将不得不在命令行的末尾作为参数传递密码。如输出所示，即使备份仍然被压缩，上一节中创建的备份大约为 4GB。`.tar`文件将位于命令行指定的路径或当前工作目录（如果未指定路径）。可以在 Linux 命令行上手动解压缩`.tar`文件，也可以使用许多 Windows 存档实用程序之一，如 WinRAR 或 7Zip：

![解析 ADB 备份](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00328.jpeg)

备份中的目录，在 Windows 资源管理器中查看

## ADB 备份中的数据位置

现在备份已转换为`.tar`文件并进行了提取，审查员可以查看备份中包含的数据。在我们的示例中，在备份的根目录中找到了两个目录：

+   `apps`：此文件夹包含备份中包含的应用程序的`/data/data`中的数据。

+   `shared`：此文件夹包含 SD 卡中的所有数据，仅在命令行传递了`-shared`参数时才存在。

请注意，应用程序目录中的文件存储在其包名称的目录中（就像在 ADB shell 内部的`/data/data`中看到的那样），共享目录正是用户如果将 SD 卡插入计算机中所看到的。

作为从备份中提取的用户数据的良性示例，下面显示了用户的**Pandora**活动。 Pandora 是一个在 Google Play 商店中有数百万次下载的流媒体音乐服务。 Pandora 的应用程序数据将包含在备份的 apps 文件夹中，文件夹名为`com.pandora.android`。

![ADB 备份中的数据位置](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00329.jpeg)

从备份中提取的 Pandora 目录

这是一个相当标准的 Android 应用程序布局，如第二章中所讨论的那样，*设置 Android 取证环境*。应用程序的数据库将在`db`文件夹中：

![ADB 备份中的数据位置](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00330.jpeg)

Pandora 备份的 db 文件夹中的文件

XML 配置设置将在`sp`文件夹中：

![ADB 备份中的数据位置](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00331.jpeg)

Pandora 备份的 sp 文件夹中的文件

使用数据库查看器查看`pandora.db`，可以查看用户创建的站点以及创建时间戳：

![ADB 备份中的数据位置](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00332.jpeg)

从备份中的 pandora.db 的内容

在 XML 首选项文件中，可以在`firstInstallId`下找到应用程序安装的时间戳。请注意，转换时间戳的确切方法显示在第七章中，*Android 应用程序的法医分析*中：

![ADB 备份中的数据位置](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00333.jpeg)

XML 首选项文件的内容

如果由于某种奇怪的原因，用户的 Pandora 使用在调查中是一个重要问题，调查员可以从这两个看似无害的文件中得出什么结论？

首先，`lastTransmission`和`firstInstallID`时间戳相差毫秒，表明该应用程序安装后从未使用过。此外，每个站点的创建日期在某些情况下早于应用程序的安装日期，有些甚至早于几年。这表明用户在其他设备上使用了 Pandora，这可能与调查高度相关。

虽然 Pandora 通常与数字取证调查无关，但它是通过 ADB 进行简单备份的数据的一个例子。更详细的应用程序分析将在第七章中呈现，*Android 应用程序的法医分析*。

# ADB Dumpsys

**Dumpsys**是内置在 Android 操作系统中的工具，通常用于开发目的，以显示设备上运行的服务的状态。但是，它也可能包含法医学上有趣的信息。Dumpsys 不需要 root 访问权限，但与所有 ADB 命令一样，它需要设备上启用 USB 调试和绕过安全 USB 调试。

可以查看的确切服务因设备和 Android 版本而异。要查看可以转储的所有可能服务的列表，请运行以下命令：

```kt
adb shell service list

```

命令的输出将显示为列表，如下所示：

![ADB Dumpsys](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00334.jpeg)

冒号前的服务名称是我们将传递给 dumpsys 的参数。使用前面截图中的服务编号七（`iphonesubinfo`）的有效 dumpsys 命令如下所示：

```kt
adb shell dumpsys iphonesubinfo

```

在下面的截图中，我们看到`iphonesubinfo`服务的输出包括设备的 IMEI：

![ADB Dumpsys](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00335.jpeg)

有许多法医学上有趣的 dumpsys 服务；以下是一些示例。由于 dumpsys 服务可能因操作系统版本和设备而异，此列表并不包括所有内容，仅旨在展示 dumpsys 对法医检查员的有用性：

+   iphonesubinfo

+   batterystats

+   procstats

+   用户

+   appops

+   Wi-Fi

+   通知

## Dumpsys batterystats

Batterystats 用于显示正在运行的应用程序的使用情况。根据使用的应用程序数量，其输出可能非常冗长。在下面的截图中，输出被重定向到文件，因为它无法适应 Windows 命令行：

![Dumpsys batterystats](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00336.jpeg)

这显示了 Google Chrome 的网络使用情况。这些信息可以用来显示该应用程序最近是否被使用，即使 Chrome 在隐身模式下使用并且在其他地方没有留下法医证据，这些信息仍将存在。

### 注意

**唤醒锁**部分对于检测恶意软件非常有用。唤醒锁是一种使设备保持唤醒状态（不进入睡眠模式）的方法，表明应用程序试图在后台保持运行。

## Dumpsys procstats

**procstats**是一种显示运行应用程序的处理器使用情况的服务。与 batterystats 类似，它是可以用来显示应用程序最近在设备上使用的另一种方法，如下截图所示：

![Dumpsys procstats](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00337.jpeg)

## Dumpsys user

从 Android Jelly Bean 开始，Google 为平板设备添加了多用户支持。随着 Lollipop 的发布，Google 将此支持扩展到手机。长期以来，数字取证中最具挑战性的问题之一是在执行可疑操作时证明谁在使用设备；“谁在键盘后面？”

在用户服务上运行 dumpsys 将显示所有用户的最后登录信息：

![Dumpsys user](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00338.jpeg)

由于一次只能有一个用户登录，查看最近登录的用户将确定设备上当前正在使用的帐户。

## Dumpsys App Ops

**App Ops**可能是最有趣的 dumpsys 服务。术语 App Ops 通常用于指代应用程序可以访问的权限。在较早版本的 Android 中，有传言称 Google 将包括用户可以撤消应用程序的特定权限的功能。尽管这从未实现，但这项服务至少仍然存在，并显示了应用程序上次使用每个可以访问的权限的时间。以下是来自 Google Chrome 的另一个示例：

![Dumpsys App Ops](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00339.jpeg)

在上面的输出中，我们可以看到大约在 App Ops 使用 dumpsys 之前 1 小时 7 分钟，Chrome 使用了`TAKE_AUDIO_FOCUS`权限，后来使用了`AUDIO_MEDIA_VOLUME`。这表明 Chrome 用于听音乐的时间和内容。

一个更有趣的例子是以下的手机应用程序：

![Dumpsys App Ops](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00340.jpeg)

`44`分钟前，用户使用了电话应用程序并需要`READ_CONTACTS`权限，然后立即使用了`WRITE_CALL_LOG`权限。我们可以推断用户在`44`分钟前打了电话；即使他们之后从记录中删除了通话。

## Dumpsys Wi-Fi

**Wi-Fi**服务将显示已保存连接的所有 SSID 的列表。例如，这可能对于显示用户曾经在某个位置非常有用。更详细的 Wi-Fi 信息也可以在文件系统上找到，但需要 root 权限才能查看。使用 dumpsys，我们可以在不需要 root 权限的情况下访问这些数据：

![Dumpsys Wi-Fi](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00341.jpeg)

## Dumpsys notification

**通知**服务将提供有关当前活动通知的信息。这对于记录设备被扣押时的状态，或者识别显示特定通知的应用程序非常有用。每个通知可能相当大，并包含大量信息，其中只有一些可能有用。以下示例显示了来自 Gmail 应用程序的一封新邮件，其中包括主题（`这是一封测试邮件`）和正文（`查看测试通知`）：

![Dumpsys notification](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00342.jpeg)

## Dumpsys 结论

在没有服务名称的情况下运行 dumpsys 命令将在所有可用的服务上运行 dumpsys。但是，输出将非常庞大，应将其重定向到文本文件中。在大多数平台上，执行此操作的命令将是：

```kt
adb shell dumpsys > dumpsys.txt

```

这将把输出写入到当前工作目录中的 dumpsys.txt 文件中。然后可以搜索输出，或者运行解析脚本来提取已知的相关字段。

Dumpsys 是一个非常强大的工具，可以用来显示设备上无法在其他地方获取的信息。我们建议在扣押 Android 设备时，在关机之前运行 dumpsys。这将保存各种各样的信息，以后可能会有用，并且不需要 root 权限。

# 绕过 Android 锁屏

锁屏是安卓取证调查中最具挑战性的方面。调查的整个过程经常取决于取证人员获取锁定设备的能力。虽然有绕过锁屏的方法，但这很大程度上取决于操作系统版本、设备设置和取证人员的技术能力。并没有一种可以在每台设备上都有效的神奇解决方案。商业取证工具如 Cellebrite 和 XRY 具有相当强大的绕过能力，但并非万无一失。本章将展示取证人员如何利用免费工具和方法提高绕过锁定设备的成功率。

### 注意

取证人员不应尝试在设备上猜测图案/PIN/密码。许多制造商实施了一个设置，将在一定次数的失败尝试后擦除设备。许多还允许用户降低这个次数。

## 锁屏类型

有许多用于保护设备的方法，以及绕过每种方法的方法都有所不同：

+   无/滑动

+   图案

+   PIN

+   密码

+   智能锁

+   可信面部

+   可信位置

+   可信设备

可能存在其他安全选项；由于安卓是开源的，可能性只受开发者想象力的限制。这些是谷歌发布的安卓棒棒糖原始版本中提供的选项。大多数供应商使用的安全选项通常将这些原始选项作为备用选项，以防用户无法使用他们独特的选项登录。首次使用该设置的版本也指的是原始安卓；各种制造商可能更早地实施了它们。

### 无/滑动锁屏

**滑动解锁**屏幕是大多数安卓设备的默认设置。它提供了零级安全，并且可以通过在屏幕上滑动手指来绕过。

### 图案锁屏

图案锁屏是标志性的安卓安全方法。经常被称为**滑动码**和类似的名称，这些要求用户用手指在设备上划出一个图案。这种锁的常见绕过方法是**指纹攻击**，寻找用户手指在屏幕上留下的图案。

### 密码/PIN 锁屏

熟悉苹果 iOS 的用户会认识到这个选项。它要求用户输入密码或 PIN 码才能解锁设备。它们被归为一类，因为在取证上它们是相同的：它们以相同的方式存储密码。

### 智能锁

**智能锁**是安卓棒棒糖中引入的术语，尽管面部解锁选项以前就已经存在。它们需要特定条件才能解锁设备：用户的脸必须被识别，用户必须在已知位置，或者附近必须有特定的其他设备。

#### 可信面部

面部解锁的工作原理就像它的名字一样：它使用面部识别来确定用户是否已被设置为可信用户。旧版本的面部锁很容易被信任用户的照片欺骗，尽管新版本可能要求用户眨眼才能解锁设备。

#### 可信位置

可信位置在安卓棒棒糖中可用，通常被称为**地理围栏**。如果用户在被标记为可信的位置（比如家或工作地点）上，设备将不会锁定。用户无需输入，但必须启用 GPS。

#### 可信设备

可信设备在安卓棒棒糖中可用，通过蓝牙工作；如果附近有设置为可信设备的设备，锁屏将被禁用。这可以与智能手表、通过蓝牙配对的车辆、蓝牙耳机或任何其他蓝牙设备一起使用。

### 注意

所有智能锁选项都需要图案/PIN/密码作为备用安全方法。这意味着我们只需要学会如何绕过图案/PIN/密码才能破解所有的安全选项。

## 绕过信息

在所有情况下，绕过锁屏将需要从设备中检索文件。图案锁存储为哈希值，位于`/data/system/gesture.key`，PIN/密码锁存储为哈希值，位于`/data/system/password.key`。此外，password.key 哈希值是加盐的；盐值存储在 Android 4.4 之前的设备上的`/data/data/com.android.providers.settings/databases/settings.db`，以及运行 Android 4.4 及更高版本的设备上的`/data/system/locksettings.db`。

如果设备被锁定，调查员应该如何访问这些文件？同样，并没有一个可以每次都有效的魔法解决方案，但有一些选项，如下所示：

+   ADB

+   需要 root 权限

+   需要**USB 调试**

+   需要**安全 USB 调试**配对（取决于操作系统版本）

+   引导到自定义恢复模式

+   不需要 root 权限（通过恢复映像将获得 root 权限）

+   无需 USB 调试（通过 fastboot 完成）

+   不需要**安全 USB 调试**（这完全被绕过）

+   需要解锁的引导加载程序

+   JTAG/Chip-off

+   非常先进

+   不需要任何特定的设备设置或选项

需要拉取的文件以破解 Android 4.4 之前的设备上的 PIN/密码为：

+   /`data/system/password.key`

+   `/data/data/com.android.providers.settings/databases/settings.db`

需要拉取的文件以破解运行 Android 4.4 及更高版本设备上的 PIN/密码为：

+   `/data/system/password.key`

+   `/data/system/locksettings.db`

只需要拉取一个文件即可破解所有版本的 Android 上的图案锁：

+   `/data/system/gesture.key`

### 提示

并不总是需要实际破解 PIN 或密码。它们也可以通过简单地覆盖或删除文件来绕过。然而，这会改变原始证据，可能在您的司法管辖区内并不具备法医学有效性。

请注意，下面的破解部分不适用于棒棒糖设备。图案锁不再是未加盐的，截至撰写时，尚未发布有关如何恢复盐的信息。然而，仍然可以通过删除相关文件来绕过锁屏。

存在许多可以自动绕过锁屏的工具；然而，在本章中，我们将展示手动过程，以解释这些工具在后台的操作。一款适用于执法人员的好工具可以在[`andriller.com/`](https://andriller.com/)找到。

# 破解 Android 图案锁

现在我们有了`gesture.key`，其中包含图案锁信息，让我们来看看文件内容：

![破解 Android 图案锁](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00343.jpeg)

在十六进制编辑器中的 gesture.key 的内容

文件的十六进制内容是滑动图案的未加盐 SHA-1 哈希。由于可能的图案数量有限（因为每个数字只能使用一次，最小为四位数，最大为九位数），破解此哈希的最简单方法是使用字典攻击。调查员可以创建一个包含每种可能图案的字典，但重新发明轮子并不总是必要的。总部位于英国的 CCL Forensics 提供了一个免费的 Python 脚本来创建哈希字典。它可以在[`www.cclgroupltd.com/product/android-pattern-lock-scripts/`](http://www.cclgroupltd.com/product/android-pattern-lock-scripts/)下载。

文件是`GenerateAndroidGestureRainbowTable.py`。要运行它，调查员的系统必须安装 Python 3。Python 3 可以在[`www.python.org/downloads/`](https://www.python.org/downloads/)下载。许多取证工具提供 Python 支持或自己使用它，因此调查员可能已经安装了它。要执行该文件，只需导航到包含它的目录并运行：

![破解 Android 图案锁](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00344.jpeg)

脚本可能需要一段时间才能运行，可能在 20 到 30 分钟之间。完成后，应该会在与`GenerateAndroidGestureRainbowTable.py`脚本相同的目录中有一个名为`AndroidLockScreenRainbow.sqlite`的文件。

现在我们有一个包含每个可能的安卓图案哈希的数据库，我们只需要在`gesture.key`文件中查找我们找到的哈希。这可以通过 SQLite 查看器或者 SQL 命令手动完成。然而，CCL Forensics 还提供了`Android_GestureFinder.py`，这是一个脚本，将在之前创建的数据库中查找哈希。

不幸的是，这个免费脚本并不完全符合我们的目的。它是用来查看物理转储二进制并找到锁定屏幕图案的；我们已经有包含图案的文件了。为了使脚本正常工作，我们需要修改代码。`Android_GestureFinder.py`需要在某种代码友好的编辑器中打开；Notepad++、Sublime Text 或 Python IDLE GUI 都可以。以下截图来自 Sublime Text。复制文件，打开原始文件，找到第 85 行，其中写着：

```kt
if regex.match(chunk) is not None:
```

这一行需要被注释掉。只需在行的开头放一个`#`号：

```kt
#if regex.match(chunk) is not None:
```

由于 Python 的格式，我们现在需要取消注释后面语句的缩进。第 86、89、91 和 92 行需要向左移动，使它们与我们注释掉的语句对齐。最后，第 94 行需要向左移动四个空格，使其与上面的行相齐。最终的代码应该是这样的：

![破解安卓图案锁](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00345.jpeg)

Android_GestureFinder.py 的最终代码

请注意，第 85 行现在以`#`开头，第 86、89、91 和 92 行与第 85 行对齐，第 94 行向右缩进一个制表符（或者从原来的位置向左移动四个空格）。

现在代码已经准备好运行我们的文件；保存对`Android_GestureFinder.py`的更改。确保`AndroidLockScreenRainbow.sqlite`和`gesture.key`文件与`Android_GestureFinder.py`在同一个目录中，并运行以下脚本：

![破解安卓图案锁](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00346.jpeg)

输出应该非常快，因为它只是在哈希数据库中进行简单的查找。`Offset`是负数，因为我们使用脚本对单个文件进行了操作；如果指向一个二进制物理转储，它将显示在 blob 中锁定屏幕哈希的偏移量。`Hash`列显示找到的哈希值，`Pattern`是相应的锁定屏幕图案：

![破解安卓图案锁](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00347.jpeg)

锁定屏幕编号

在这个例子中，图案将从左上角的`0`开始，经过中间的**4**，触摸右下角的**8**，然后穿过底部中间的**7**，最后在左下角的**6**结束。现在可以在设备上使用这个图案来绕过锁定屏幕。

如果脚本遇到错误，文件很可能没有正确修改。以下结果很可能表明脚本没有正确修改；也许运行的是文件的副本而不是修改后的版本：

![破解安卓图案锁](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00348.jpeg)

要解决这个错误，验证脚本是否按照上面显示的方式进行了修改。以下错误表明缩进不正确：

![破解安卓图案锁](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00349.jpeg)

要解决这个错误，导航到指定的行（在上面的例子中是第 86 行），确保对齐方式与前面修改后的代码一样。

如果错误无法解决，或者修改脚本对于检查员来说太困难，哈希值总是可以在哈希数据库中手动查找。一个优秀的免费 SQL 查看器，DB Browser for SQLite，可以在[`sourceforge.net/projects/sqlitebrowser/`](http://sourceforge.net/projects/sqlitebrowser/)找到。

使用 DB Browser for SQLite 打开 AndroidLockScreenRainbow.sqlite，然后选择浏览数据选项卡。然后，只需将在 gesture.key 中找到的哈希值输入到哈希列的搜索字段中。请注意，数据库中的字符是小写的；搜索字段区分大小写：

![破解 Android 图案锁](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00350.jpeg)

在 SQLite 浏览器中的 AndroidLockScreenRainbow.sqlite 文件的内容

结果与运行脚本的结果相同。

## 破解 Android PIN/密码

要破解 PIN/密码锁，我们需要查看之前提取的文件的内容。`Password.key`与`gesture.key`非常相似；它包含密码的哈希值，如下面的截图所示：

![破解 Android PIN/密码](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00351.jpeg)

在十六进制编辑器中的 password.key 的内容

然而，这次哈希是有盐的。为了有机会破解它，必须恢复盐。如上所述，其位置将取决于设备运行的 Android 版本。如果设备运行的是 4.3 或更低版本，则将位于`secure`表中的`settings.db`文件中。在 4.4 或更高版本中，它将位于`locksettings`表中的`locksettings.db`中。下面的示例显示了`locksettings.db`，但该过程对两者都是相同的。

在数据库文件中，我们需要找到`lockscreen.password_salt`键。这可以在 SQL 浏览器中完成，或者只需在十六进制编辑器中打开文件并搜索。盐值如下所示：

![破解 Android PIN/密码](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00352.jpeg)

在十六进制编辑器中的 locksettings.db 的内容

对于图案锁，我们能够使用字典攻击来快速破解图案，因为可能性相对较少。使用盐哈希，字典攻击是不可行的，所以我们将简单地进行暴力破解。

CCL Forensics 再次提供了一个有用的 Python 脚本。也可以使用其他破解工具，如 hashcat。CCL Forensics PIN/密码工具可以免费下载[`www.cclgroupltd.com/product/android-pin-password-lock-tool/`](http://www.cclgroupltd.com/product/android-pin-password-lock-tool/)。将下载两个文件，`BruteForceAndroidPin.py`和`RecoverAndroidPIN.py`。`RecoverAndroidPIN.py`用于在物理图像中定位必要的文件；我们不需要它。

`BruteForceAndroidPIN.py`的格式是：

```kt
python BruteForceAndroidPIN.py <hash> <salt> <max code length (4-16)> t

```

结尾的`t`参数用于指示哈希是密码的哈希；对于破解 PIN 是不需要的，只会增加运行时间。

上面显示的哈希值来自 PIN，所以我们只需要填写`<hash>`、`<salt>`和`<max code length>`字段：

![破解 Android PIN/密码](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00353.jpeg)

此示例中的 PIN 为`2587`，如输出所示。这个 PIN 破解不到一秒，但更长的 PIN 甚至短密码可能需要更长的时间。

# Android SIM 卡提取

传统上，SIM 卡用于在设备之间传输数据。过去，SIM 卡用于存储许多不同类型的数据，例如：

+   用户数据

+   联系人

+   短信

+   拨打电话

+   网络数据

+   **集成电路卡标识符**（**ICCID**）：SIM 卡的序列号

+   **国际移动用户识别码**（**IMSI**）：将 SIM 卡与特定用户账户绑定的标识符

+   **MSISDN**：分配给 SIM 卡的电话号码

+   **位置区域标识**（**LAI**）：标识用户所在的小区

+   **认证密钥**（**Ki**）：用于在移动网络上进行身份验证

+   其他各种特定于网络的信息

随着设备存储容量、SD 卡和云备份的增加，将数据存储在 SIM 卡上的必要性已经减少。因此，大多数现代智能手机通常不会在 SIM 卡上存储太多用户数据，如果有的话。上述所有网络数据仍然存储在 SIM 卡上，因为 SIM 卡是连接所有现代（4G）蜂窝网络的必要条件。

与所有 Android 设备一样，虽然没有明确规定用户数据不能存储在 SIM 卡上，但默认情况下并不会发生。个别设备制造商可以轻松决定将用户数据写入 SIM 卡，个别用户也可以下载应用程序来提供该功能。这意味着在取证调查期间应该始终检查设备的 SIM 卡。这是一个非常快速的过程，不应该被忽视。

## 获取 SIM 卡数据

SIM 卡应该始终从设备中取出并单独检查。虽然有些工具声称可以通过设备接口读取 SIM 卡，但这可能无法恢复已删除的数据或 SIM 卡上的所有数据；取证人员确保已获取所有数据的唯一方法是使用经过测试和验证的独立 SIM 卡读卡器读取 SIM 卡。

SIM 的位置会因设备而异，但通常存放在电池下方或设备侧面的托盘中。一旦 SIM 卡被取出，就应该放入 SIM 卡读卡器中。市场上有数百种 SIM 卡读卡器可供选择，所有主要的移动取证工具都配备了一个可与其软件配合使用的读卡器。通常，取证工具也会支持第三方 SIM 读卡器。

令人惊讶的是，缺乏彻底的免费 SIM 卡读取软件。任何使用的软件都应该在实际取证调查之前经过测试和验证，以确保在 SIM 卡上填充了已知数据。此外，请记住，许多免费软件适用于旧的 2G/3G SIM 卡，但可能无法在现代 4G SIM 卡上正常工作。我们使用了 Mobiledit! Lite，Mobiledit!的免费版本，用于以下截图。它可以在[`www.mobiledit.com/downloads`](http://www.mobiledit.com/downloads)上下载。

以下截图显示了从运行版本为 4.4.4 的 Android 手机中提取的样本 4G SIM 卡；请注意，尽管 SIM 卡在过去一年中一直在使用，但并未获取到可以被视为用户数据的内容，尽管 ICCID、IMSI 和 MSISDN（自己的电话号码）等字段可能对传票/令状或调查的其他方面有用。

![获取 SIM 卡数据](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00354.jpeg)

SIM 卡提取概述

以下截图突出显示了 SIM 卡上的短信：

![获取 SIM 卡数据](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00355.jpeg)

以下图片突出显示了 SIM 卡的电话簿：

![获取 SIM 卡数据](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00356.jpeg)

以下图片突出显示了 SIM 卡的电话号码（也称为 MSISDN）：

![获取 SIM 卡数据](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00357.jpeg)

## SIM 卡安全

由于 SIM 卡符合已建立的国际标准，所有 SIM 卡都提供相同的安全功能：4 到 8 位的 PIN 码。通常，必须通过设备菜单设置此 PIN 码。在 Android 设备上，此设置位于**设置** | **安全** | **设置 SIM 卡锁**。SIM PIN 完全独立于任何锁屏安全设置，只有在设备启动时才需要输入。SIM PIN 仅保护 SIM 卡上的用户数据；即使 SIM 卡被 PIN 锁定，所有网络信息仍然是可恢复的。

SIM 卡将允许三次尝试输入 PIN 码。如果其中一次尝试正确，计数器将重置。另一方面，如果所有这些尝试都不正确，SIM 卡将进入**个人解锁密钥**（**PUK**）模式。PUK 是由运营商分配的 8 位数字，通常在购买 SIM 卡时的文件中找到。使用任何商用取证软件都无法绕过 PUK；因此，检查员不应尝试在设备上输入 PIN 码，因为设备不会指示在激活 PUK 之前还有多少次尝试。检查员可能会无意中将 SIM 卡锁定，无法访问设备。然而，取证工具将显示在激活 PUK 之前还有多少次尝试，如前面的屏幕截图所示。

### 注意

SIM 卡的通用载体默认的 PIN 码是 0000 和 1234。如果在激活 PUK 之前还有 3 次尝试，检查员可以成功地使用这些默认值解锁 SIM 卡。

运营商经常在发放 SIM 卡时保留 PUK 密钥。这些密钥可以通过发给运营商的传票或令状获得。

### SIM 卡克隆

SIM 卡的 PIN 本身几乎没有提供额外的安全性，并且可以很容易地通过 SIM 卡克隆来绕过。SIM 卡克隆是几乎所有商用移动取证软件提供的功能，尽管克隆这个术语有些误导。在移动取证的情况下，SIM 卡克隆是将锁定的 SIM 卡上的网络数据复制到一个没有激活 PIN 的取证无菌 SIM 卡上的过程。手机将根据这些网络数据（通常是 ICCID 和 IMSI）识别克隆的 SIM 卡，并认为它是之前插入的相同 SIM 卡，但这次没有 SIM PIN。这个克隆的 SIM 卡也无法访问蜂窝网络，这使它成为类似飞行模式的有效解决方案。因此，SIM 卡克隆将允许检查员访问设备，但原始 SIM 卡上的用户数据仍然无法访问，因为它仍然受到 PIN 的保护。

我们不知道有任何免费软件可以进行取证 SIM 卡克隆。然而，几乎所有商用移动取证工具都支持这一功能。这些工具通常包括 SIM 卡读卡器、执行克隆的软件，以及多张空白 SIM 卡用于克隆过程。

# Android 棒棒糖的问题和机会

正如本章中多次提到的那样，最近发布的 Android 棒棒糖 5.0 版本引入了许多强大的安全功能，这当然给取证检查员带来了复杂性。最初宣布 Android 棒棒糖设备将默认启用全盘加密，然而，由于许多设备上的性能问题，谷歌后来撤回了这一要求。谷歌只是强烈建议用户在首次创建帐户时启用全盘加密。谷歌还暗示这将成为未来操作系统版本的要求，更多信息可以在[`static.googleusercontent.com/media/source.android.com/en/us/compatibility/android-cdd.pdf`](http://static.googleusercontent.com/media/source.android.com/en/us/compatibility/android-cdd.pdf)的第 9.9 节找到。

启用完整磁盘加密的设备几乎不可能绕过锁定的设备，因为即使可以恢复密钥文件，它们也会被加密；尽管商业工具制造商最终肯定会赶上。在撰写本文时，没有已知的方法可以绕过锁定的、加密的棒棒糖设备，除非它已启用**USB 调试**并且先前记住了计算机的 RSA 密钥以绕过**安全 USB 调试**。在这种情况下，可以从嫌疑人的计算机中拉取`adbkey`和`adbkey.pub`文件，并将其放在检查机器上；然后设备将认为它正在与已知的、批准的计算机通信。`adbkey`和`adbkey.pub`文件可以在 Windows 计算机的`C:\Users\<username>\.android`和苹果计算机的`/Users/<username>/.android`中找到。

对于进行棒棒糖取证的检查员来说，有一个重要的优势：本章前面提到的智能锁。智能锁允许用户设置条件，如果满足条件，设备将无需输入密码即可解锁。如果在启用的受信任位置进行检查，检查员将不需要绕过锁定。如果在检查设备时附近有一个已启用的受信任设备，情况也是如此。但是，设备上没有任何指示表明正在使用受信任的设备；设备看起来只是没有锁屏。因此，从现场保护所有数字证据变得更加关键。以前可能被忽视的设备，如蓝牙耳机，可能会成为让检查员绕过锁定设备的关键。越来越普遍的是设备与车辆配对，因此检查员可能不得不在嫌疑人的车辆中进行提取！棒棒糖的额外安全性意味着检查员可能需要在取证过程中变得更有创造力。

Android 棒棒糖还为所有设备带来了多用户支持，这在以前仅限于平板电脑。在具有多个帐户的设备上，所有用户的数据仍然位于`/data`分区中，但位于稍有不同的位置。如果在设备上设置了多个帐户，则每个帐户的应用数据目录可以在`/data/user`中找到。每个用户都将被分配一个唯一的编号；`0`是设备上设置的第一个帐户。`/data/user/0`目录实际上是一个符号链接到`/data/data`。第二个帐户位于`10`目录中，该目录直接包含了第二个用户的所有应用程序数据。每添加一个用户，都会存储在以`10`递增的目录中；即第三个用户在`/data/user/20`中，第四个用户在`/data/user/30`中，依此类推。

# 摘要

本章涵盖了与 Android 设备的逻辑提取相关的许多主题。简而言之，各种方法及其要求如下：

| 方法 | 要求 |
| --- | --- |
| ADB 拉取 |

+   **USB 调试**已启用

+   4.2.2+上绕过**安全 USB 调试**

+   获取用户数据的根访问权限

|

| 从恢复模式下的 ADB 拉取 |
| --- |

+   必须是自定义恢复以启用 ADB 访问

+   获取用户数据的根访问权限

|

| 从自定义恢复映像中启动的 Fastboot |
| --- |

+   解锁的引导加载程序

+   设备的引导镜像

|

| ADB 备份 |
| --- |

+   **USB 调试**已启用

+   4.2.2+上绕过**安全 USB 调试**

+   必须在运行设备上完成（而不是恢复模式）

|

| ADB dumpsys |
| --- |

+   **USB 调试**已启用

+   4.2.2+上绕过**安全 USB 调试**

+   必须在运行设备上完成（而不是恢复模式）

|

| SIM 卡提取 |
| --- |

+   无，应独立于设备完成

|

此外，有价值的用户数据可以从 SD 卡中恢复，这将在第五章中进行介绍，*从 Android 设备物理提取数据*。

如果屏幕被锁定，检查员可以使用上述列出的方法提取关键文件并破解它们，以绕过锁定。

本章节有大量的数据。为了帮助简化它，下面展示了一个建议的*最佳实践*流程图：

.

![摘要](https://github.com/OpenDocCN/freelearn-android-zh/raw/master/docs/lrn-andr-frns/img/image00358.jpeg)

安卓取证流程图
