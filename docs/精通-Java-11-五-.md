# 精通 Java 11（五）

> 原文：[Mastering Java 11](https://libgen.rs/book/index.php?md5=550A7DE63D6FA28E9423A226A5BBE759)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 十六、未来发展方向

在最后一章中，我们重点介绍了 Java 平台提供的一些激动人心的工具的最佳实践。具体来说，我们介绍了 UTF-8 属性文件、Unicode、Linux/AArch64 端口、多分辨率图像和公共区域设置数据存储库。

本章概述了 Java 平台在 Java11 之外的未来发展。我们将看看 Java19.3（12）和 19.9（13）的计划以及将来可能看到的进一步变化。我们将从一个简短的 JEP 概述开始。

具体而言，本章包括以下内容：

*   JEP 概述
*   候选的 JEP 
*   提交的 JEP 
*   起草的 JEP 
*   正在进行的特别项目

# 技术要求

本章及后续章节主要介绍 Java11。Java 平台的**标准版**（**SE**）可从 [Oracle 官方下载网站](http://www.oracle.com/technetwork/java/javase/downloads/index.html)下载。

IDE 包就足够了。来自 JetBrains 的 IntelliJ IDEA 用于与本章和后续章节相关的所有编码。IntelliJ IDEA 的社区版可从[网站](https://www.jetbrains.com/idea/features/)下载。

# JDK 增强提案概述

**JDK 增强提案**（**JEP**）由 JDK 的建议变更列表组成。这个公开的列表用于通知开发人员并为 Java 平台提供一个长期计划

JEP 的核心是增强功能本身。增强的标准包括：

*   必须表明 JDK 发生了重大变化。
*   必须有广泛的信息吸引力。
*   此外，它必须满足以下附加标准之一：
    *   需要大量的工程工作来实现（至少两周）
    *   涉及对 JDK 或其基础结构的重大更改
    *   是 Java 开发人员或用户的高需求项目

JEP 具有以下顺序状态：

1.  **草案**：这是最早的状态，当 JEP 已经写好，作者正在传阅征求共识时使用
2.  **发布**：一旦作者达成共识，JEP 即可登录 JEP 档案
3.  **提交**：一旦 JEP 被认为准备好进行正式评估，作者即设置此状态
4.  **候选**：一旦 OpenJDK 负责人接受了 JEP，就变为这个状态
5.  **资助**：资助是指某个职能部门领导或某个小组领导判断 JEP 资金充足
6.  **已完成**：此状态表示增强工作已完成并在版本发布中交付

并不是每个 JEP 都能完成整个六阶段的工作流程。其他状态包括**激活**、**拒绝**、**撤销**。

Java 平台的每一个潜在更改都将被描述为有针对性的、提交的或起草的。有针对性是指已指定用于未来 Java 版本的更改，已提交是指已提交但未针对 Java 平台特定版本的更改，并且起草的更改仍在绘图板上，尚未准备好提交或指定为有针对性的更改。

下一节将介绍 **JDK 增强方案**，包括候选、已提交和草稿的状态。

# JEP 候选 

这一部分的特点是五个 JEP，在写这本书的时候，有候选人的地位。这些 JEP 如下：

*   JEP326：原始字符串字面值
*   JEP334：JVM 常量 API
*   JEP337：RDMA 网络套接字
*   JEP338：向量 API
*   JEP339：Edwards 曲线数字签名算法

# JEP326：原始字符串字面值

在未来的版本中，我们可能会看到 Java 平台中添加了原始字符串字面值。原始字符串字面值有两个重要特性：

*   它们可以跨越多行源代码
*   转义序列不被解释

这个增强的目标本质上是让开发人员更容易。此更改将允许开发人员提供包含多行代码的字符串，而不必提供字符来指示新行。

# JEP334：JVM 常量 API

JVM 依赖于一个常量池来确定类布局、实例、接口和数组。每个类都有一个固定的池。当前用于建模这些可加载常量的 Java 数据类型效率低下且不充分。这个 JEP 的目的是为 Java 提供操纵类和方法的能力。

# JEP337：RDMA 网络套接字

**远程直接内存访问**（**RDMA**）允许一台计算机访问另一台计算机的内存，而无需通过操作系统。这个 JEP 希望将 RDMA 添加到 JDK 网络 API 中。至少在最初，这将适用于 Linux 系统。

# JEP338：向量 API

将创建一个新的向量 API，以便向量计算可以可靠地编译成针对特定 CPU 优化的向量硬件指令。这将使开发人员能够提供高效的标量计算。

# JEP339：Edwards 曲线数字签名算法

**Edwards 曲线数字签名算法**（**EdDSA**）是一种密码签名。这个 JEP 计划实现这个算法。

# 已提交的 JEP

在撰写本书时，以下 JEP 的状态为提交：

*   默认情况下，将禁用实验功能
*   默认的 CDS 存档将包含在 JDK 二进制文件中
*   Javadoc 标签的创建是为了区分 API、实现、注释和规范之间的差异
*   新的 JMX 注解将用于注册托管资源
*   GTK3 将在布局方面进行现代化改造
*   将为 JMX 创建新的 REST API

每项建议的详细信息可从[这个页面](http://openjdk.java.net/jeps/0)获得。

# 已起草的 JEP

在撰写本书时，以下 JEP 的起草状态为：

*   G1 的可中止混合集合
*   Java 堆在备用内存设备上的旧一代的分配
*   更好的哈希码
*   并行监视器
*   动态最大内存限制
*   高效数组比较
*   在 GPU 上启用 Java 方法的执行
*   使用值类型增强的`ManderblotSet`演示
*   增强型伪随机数生成器
*   改进的 IPv6 支持
*   孤立的方法
*   Java 线程清理器
*   应用启动时预编译的`JWarmup` Java 热方法
*   密钥派生 API
*   包装工具
*   在 JVM 编译的方法上提供稳定的 USDT 探测点
*   支持映射到非易失性存储器上的`ByteBuffer`
*   及时减少未使用的已提交内存
*   JVM 中的类型运算符表达式
*   方法句柄的未装箱参数列表
*   使用 UTF-8 作为默认字符集

每项建议的详细信息可从[这个页面](http://openjdk.java.net/jeps/0)获得。

# 正在进行的特别项目

Java 增强建议展示了 Java 平台的设计和实现变化。如前所述，正在起草的 JEP 的标准是，工作必须至少满足以下一项：

*   需要大量的工程工作来实现（至少两周）
*   涉及对 JDK 或其基础结构的重大更改
*   是 Java 开发人员或用户的高需求项目

另一方面，项目代表由下列小组之一赞助的合作努力：

*   二维图形
*   采用
*   **抽象窗口工具箱**（**AWT**）
*   建造
*   兼容性和规范审查
*   编译器
*   一致性
*   核心库
*   理事会
*   HotSpot
*   国际化
*   JMX
*   成员
*   网络
*   NetBeans 项目
*   搬运工
*   质量
*   安全
*   适用性
*   声音
*   Swing
*   漏洞
*   Web

小组是正式的，可以提出新的小组。

下面列出的活动项目代表了 Java 平台未来可能的增强领域。本节后面将提供有关每个项目的简要信息，并深入了解未来变化的一般领域：

*   注解管道 2.0
*   音频合成引擎
*   Caciocavallo
*   通用虚拟机接口
*   编译器语法
*   设备 I/O
*   Graal
*   HarfBuzz 集成
*   Kona
*   开放 JFX
*   Panama
*   Shenandoah

# 注解管道 2.0

这个项目探索如何在 Java 编译器管道中处理注解的改进。我们无意提议更改规范，而是将重点放在性能增强上。

# 音频合成引擎

这个项目正在考虑为 JDK 创建一个新的 MIDI 合成器。当前的 MIDI 合成器属于授权库。工作组希望看到新的 MIDI 合成器作为一个开源 JDK 素材。

# Caciocavallo

Caciocavallo 项目旨在改进 OpenJDK AWT 内部接口。这扩展到二维子系统。提议的改进将简化 AWT 移植到新平台的方式。

# 通用虚拟机接口

公共 VM 接口项目的目标是为 OpenJDK 记录 VM 接口。这将使 Classpath VM 和其他 VM 更容易使用 OpenJDK。

# 编译器语法

编译器语法项目正在开发一个基于 ANTLR 语法的实验性 Java 编译器。**另一种语言识别工具**（简称 **ANTLR**），是一种读取、处理和执行结构化文本或二进制文件的解析器。项目组希望这个 Java 编译器能够取代当前的编译器，因为它使用的是手写解析器 **LALR**（缩写为 **Look Ahead Left to Right**）。LALR 解析器已经被项目组确认为脆弱的，难以扩展。

# 设备 I/O

这个项目打算通过 Java 级 API 提供对通用外围设备的访问。项目组希望支持的外围设备的初始列表包括：

*   **GPIO**（简称**通用输入/输出**）
*   **I2C**（简称**集成电路间总线**）
*   **SPI**（简称**串口**）
*   **UART**（简称**通用异步收发机**）

# Graal

Graal 项目的目标是通过 JavaAPI 公开 VM 功能。这将允许开发人员用 Java 为给定的语言运行时编写动态编译器，包括开发多语言解释器框架。

# HarfBuzz 集成

HarfBuzz 集成项目希望将 HarfBuzz 布局引擎集成到 Java 开发工具包中。这是为了用 HarfBuzz 布局引擎替换 ICU 布局引擎。ICU 布局引擎已被弃用，巩固了该项目未来成功的重要性。

# Kona

Kona 项目正在定义和实现 Java API，以支持**物联网**（**IoT**）领域。这包括网络技术和协议。尽管没有说明，但安全和安保对于这项工作的成功实现至关重要。

# 开放 JFX

关于 OpenJFX 项目没有太多可用的细节。这个项目的既定目标是创建下一代 Java 客户端工具包。根据项目名称，可以假设团队希望创建 JavaFX 的 OpenJFX 版本，这是一组用于创建富互联网应用的包。

# Panama

Panama 项目的重点是增强 JVM 和非 JavaAPI 之间的连接。

该项目包括以下选定组件：

*   本机函数调用
*   从 JVM 进行本机数据访问
*   JVM 堆内的本机数据访问
*   JVM 堆中的新数据布局
*   头文件的 API 提取工具

项目团队已经生成了一个与 JDK9 结构匹配的存储库树。这大大增加了项目成功的可能性。

# Shenandoah

Shenandoah 项目的目标是通过垃圾收集操作显著减少暂停时间。这种方法是让更多的垃圾收集操作与 Java 应用同时运行。在第 7 章中，“利用默认的 G1 垃圾收集器”，您了解了 CMS 和 G1。Shenandoah 项目打算将并行压缩添加到可能的垃圾收集方法中。

# 总结

在这一章中，我们概述了 Java 平台在 Java11 之外的未来发展。Java 平台的每一个潜在变化都被描述为候选、提交或起草

在下一章中，您将学习如何为 Java 社区做出贡献以及这样做的好处。

# 问题

1.  什么是 JEP？
2.  一个提案必须有什么样的上诉才能为正义与平等党考虑？
3.  提案必须满足的三个标准是什么？
4.  在哪里可以找到活动 JEP 的列表？
5.  起草的 JEP 状态意味着什么？
6.  发布的 JEP 状态意味着什么？
7.  提交的 JEP 状态意味着什么？
8.  候选的 JEP 状态意味着什么？
9.  受资助的 JEP 状态意味着什么？
10.  完成的 JEP 状态意味着什么？

# 十七、为 Java 平台做贡献

在最后一章中，我们展望了 Java 平台在 Java11 之外的未来发展。我们查看了 Java19.3 和 19.9 的计划，以及将来可能会看到的进一步变化。我们首先简要概述了 JEP，并涵盖了现有的 JEP 和正在进行的特别项目。

Java 平台未来的关键是 Java 社区。这是本章的重点。我们将讨论 Java 社区以及开发人员如何为 Java 平台做出贡献。具体来说，我们将介绍以下与 Java 社区相关的主题：

*   Java 社区
*   参与 Java 用户组
*   **Java 社区流程**（**JCP**）
*   技术网络
*   撰写技术文章

# 技术要求

本章介绍 Java11，Java 平台的**标准版**（**SE**）可从 [Oracle 官网](http://www.oracle.com/technetwork/java/javase/downloads/index.html)下载。

IDE 包就足够了。来自 JetBrains 的 IntelliJ IDEA 用于与本章相关的所有编码。[IntelliJ IDEA 的社区版可从以下网站下载](https://www.jetbrains.com/idea/features/)。

# Java 社区

Java 社区由数以百万计的开发人员组成，他们以一种或多种方式相互支持并为 Java 平台做出贡献。这就是 Java 是如此强大的开发平台的原因之一。社区参与可以包括通过`@java`关注和参与 Twitter，或者在 Facebook 上喜欢`<3 Java`。

还有大量的列表服务、博客和论坛，您可以参与其中，帮助开发人员解答问题。这是一个很好的方法来支持社区并及时了解 Java 平台的变化。并不是所有 Oracle 的博客都是针对 Java 的，但至少是 Java 的附属博客。

您可以在[这个页面](http://blogs.oracle.com)浏览 Oracle 的博客目录。

互联网上有几个 Java 论坛。甲骨文在[这个页面](http://community.oracle.com)开设了一个官方的 Java 社区空间。Java 社区空间组织为以下空间：

| JavaOne | Java 冠军 |
| --- | --- |
| #Java20 | Java 社区流程 |
| Java 本质论 | Java API |
| 数据库连接 | Java SE |
| Java 安全性 | Java HotSpot 虚拟机 |
| Java EE | 嵌入式技术 |
| Java 开发工具 | 文章档案 |
| Java.net Forge Sunset | JavaScript Nashorn |
| Java 新空间的构想 | Java 用户组 |
| NightHacking |  |

一些 Java 开发人员在 YouTube 上创建了 HOWTO 视频播放列表，其中许多被学术机构使用。这些可以是有趣的创造，是一个很好的方式回馈社会。

# 参与 Java 用户组

**Java 用户组**也被称为 **JUGs**，由具有社区意识的 Java 专业人士组成，旨在分享他们的 Java 知识。有超过 200 个用户组，参与是自愿的。与其他专业用户群一样，JUGs 提供以下机会：

*   与其他 Java 专业人士联网
*   分享技巧、技巧和资源
*   向他人学习
*   增加 Java 知识

用户组遍布全球。有些是按国家组织的，有些是按城市组织的。当你探索你所在地理区域的用户组时，你可能会发现他们有定期的见面会

# Java 社区流程

**Java 社区流程™**（**JCP™**）是针对 Java 平台开发技术规范标准的结构化方法。所有开发者均可在[这个页面](http://jcp.org)注册。注册后，用户可以查看 **Java 规范请求**（**JSR**）并提交反馈

此外，您甚至可以提交自己的 JSR 建议并加入 JSR 专家组。

在 JCP 站点，您可以搜索和浏览当前 JSR。

# 技术网络

甲骨文拥有一个**甲骨文技术网络**（**OTN**），其成员资格是免费的。详情请访问[这个页面](https://www.oracle.com/technetwork/community/join/overview/index.html)。

OTN 会员有以下好处：

*   参加论坛的机会
*   自由软件
*   免费在线研讨会
*   访问 Java API 文档
*   社区参与
*   获取技术文章
*   Oracle 员工的博客
*   访问示例代码
*   新闻稿订阅
*   活动、书籍、产品和其他资源的折扣
*   社会参与途径：
*   推特
*   YouTube
*   脸书
*   博客

# 撰写技术文章

如果你是一个学者，专业人士，或只是想发表一篇文章，你可以提交给甲骨文。如果被接受，甲骨文将在 OTN 的保护下发布它们

[以下网站](https://www.oracle.com/technetwork/articles/otn-submit-100481.html)提供了为 Oracle 撰写技术文章的详细信息。

本网站提供以下分类信息：

*   编辑需要
*   文章规范
*   提交和编辑过程
*   发表文章的授权
*   你的文章提交的回复
*   编辑过程
*   委托文章

# 总结

在本章中，我们讨论了 Java 社区以及可以为 Java 平台做出贡献的方法。具体来说，我们讨论了 Java 社区，参与了 Java 用户组 JCP 和 OTN，并为 Oracle 撰写了技术文章。

你做到了书的结尾。谢谢你的阅读。快乐的编码！

# 问题

1.  什么是 JUG？
2.  有多少个 JUG？
3.  JUG 是如何组织的？
4.  OTN 会员资格提供什么样的折扣？
5.  什么是 **Java 社区流程™**？
6.  Java 社区有多大？
7.  列出加入 JUG 的四个好处。
8.  您可以从哪里了解到有关为 Oracle 编写技术文章的更多信息？
9.  向 JSR 提交反馈的先决条件是什么？
10.  谁可以提交 JSR？

# 十八、答案

# 第一章

1.  19.3。
2.  开发人员不再需要等待很长时间才能发布到 Java 平台。更重要的是，没有发布将代表平台的重大变化
3.  Java 平台的模块化。
4.  CORBA。
5.  更快的启动。
6.  低开销垃圾收集器。
7.  标识符。
8.  Java18.3（10）。
9.  Java9、10（18.3）和 11（18.9）。
10.  G1。

# 第二章

1.  当一个线程在一个队列中等待一个当前被锁定的对象时，它就被认为是在争夺这个锁
2.  代码缓存是 **Java 虚拟机**（**JVM**）存储生成的本机代码的内存区域。
3.  `-XX:NonProfiledCodeHeapSize`。
4.  Lint 和 DocLint 是向`javac`报告警告的来源。
5.  `hotspot/test/testlibrary/jit-tester`。
6.  `-Xshare:off`。
7.  FXML。
8.  在 Java9 之前，字符串数据存储为一个数组`chars`
9.  从 Java9 开始，字符串现在在内部使用字节数组和用于编码引用的标志字段来表示。
10.  OpenType 是一个 HTML 格式的字体格式规范。

# 第三章

1.  在 Java 中，栅栏操作是`javac`以屏障指令的形式对内存进行强制约束的操作。这些操作发生在屏障指令之前和之后，本质上是将它们封闭起来。
2.  Coin 项目是 Java7 中引入的一组小改动的特性集。
3.  从 Java9 开始，我们可以对私有实例方法使用`@SafeVarargs`注解。
4.  从 Java9 开始，我们在类和文件中列出`import`语句的顺序将不再影响编译过程。
5.  Java 平台在`cacerts`密钥库中包含一组根证书。
6.  `var`标识符在技术上是一个保留的类型名。
7.  可以通过使用新的`var`标识符来推断声明。
8.  下划线字符（`_`）不能再用作合法的标识符名称。
9.  `java.util.concurrent.atomic`包是 12 个子类的集合，支持对线程安全和无锁的单个变量执行操作。
10.  变量处理器是对变量的类型化引用，由`java.lang.invoke.VarHandle`抽象类控制。

# 第四章

1.  JDK、JRE 和 JAR 都太大了。
2.  模块化系统具有以下要求：
    *   必须有一个公共接口，以允许所有连接模块之间的互操作性
    *   必须支持隔离和连接测试
    *   编译时操作必须能够识别正在使用的模块
    *   对模块的运行时支持

3.  Java 模块是以下内容的集合：
    *   包
    *   类
    *   接口
    *   代码
    *   数据
    *   资源
4.  `java`。
5.  JDK 的主要组件如下：
    *   开发工具
    *   JavaFX 工具
    *   **Java 运行时环境**（**JRE**）
    *   源代码
    *   库
    *   C 头文件
    *   数据库
6.  可维护性、性能和安全性。
7.  `bin`、`conf`和`lib`。
8.  `bin`、`conf`、`lib`、`demo`、`sample`、`man`、`include`。
9.  链接时间。
10.  Java 链接器。

# 第五章

1.  当开发计算机上有多个版本的库时，库信息的特殊性不足，类加载器有问题，类路径过长。
2.  Java9。
3.  模块通过提供强大的封装解决了 Java9JDK 之前的单片问题。
4.  `java.base`。

5.  Java 中的封装是由`module-info.java`文件中的信息驱动的。
6.  `jdk.unsupported`JDK 模块。
7.  `module-info.java`。
8.  Java 网络启动协议（**JNLP**）。
9.  它是一个非法的标识符，从 Java10 开始。
10.  `--add-opens`、`--add-exports`和`--permit-illegal-access`。

# 第六章

1.  读取求值打印循环通常称为 REPL，从短语中的每个单词中提取第一个字母。它也被称为语言 Shell 或交互式顶层。
2.  它是一个交互式读取求值打印循环工具，用于求值以下 Java 编程语言组件声明、语句和表达式。它有自己的 API，因此可以被外部应用使用。
3.  如下所示：

*   制表符补全
*   语句结尾分号的自动补全
*   导入的自动补全
*   定义的自动补全

4.  JShell 是位于`/bin`文件夹中的命令行工具。
5.  退出 Shell 就像进入`/exit`一样简单。
6.  `/vars`。
7.  在 JShell 中输入`/help`或`/?`命令提供了一个完整的命令列表和可以在 Shell 中使用的语法。
8.  在 JShell 中，可以使用`/help`命令，然后使用需要额外帮助的命令来获得额外的帮助。
9.  命令行工具通常提供相对稀疏的反馈，以避免屏幕过度拥挤，或者对开发人员造成麻烦。JShell 有几种反馈模式，除了让开发人员能够创建自己的定制模式之外。
10.  反馈方式有四种：`concise`、`normal`、`silent`、`verbose`。

# 第七章

1.  以下是垃圾收集算法：

*   标记和扫描
*   CMS 垃圾收集
*   串行垃圾收集
*   并行垃圾收集
*   G1 垃圾收集

2.  G1 名称代表“垃圾优先”。
3.  **iCMS**（增量并发标记扫描）、【CPU】、【37327】、【36739】、【35813】、

4.  MiB 代表 Mebibyte，是数字信息字节的倍数。

5.  尽管垃圾收集在 Java 中是自动的，但是您可以显式调用
    方法`java.lang.System.gc()`方法来帮助调试过程。此方法不接受任何参数，也不返回任何值。

6.  因为 Java 中的所有对象，甚至是您自己创建的对象，都是`java.lang.Object`的子类，所以 Java 中的每个对象都有一个`finalize()`方法。

7.  这些组合在 Java9 中已被删除。
8.  `CollectedHeap`类。
9.  对于 Java10，G1Full 垃圾收集器被转换为并行，以减轻对使用完全垃圾收集的开发人员的任何负面影响。

10.  GC。

# 第八章

1.  微基准是用来测试系统性能的。这与宏观基准测试不同，后者在不同的平台上运行测试，以进行效率比较和后续分析。使用微标记，我们通常针对一个系统上的特定代码片段，例如方法或循环。微基准的主要目的是在我们的代码中识别优化机会。

2.  微基准发生在流程设计、实现、执行、分析和增强的几个阶段。
3.  Maven，也称为 ApacheMaven，是一个项目管理和理解工具，我们可以使用它来管理我们的应用项目构建、报告和文档。
4.  `pom.xml`。
5.  它们都是可配置的选项。
6.  All、AverageTime、SampleTime、SingleShotTime 和吞吐量。
7.  纳秒，微秒，毫秒，秒，分钟，小时，天。
8.  对于电源管理陷阱，有两种建议策略：

*   在运行测试之前禁用任何电源管理系统
*   长时间运行基准测试

9.  对于操作系统调度器陷阱，有两种建议策略：

*   优化系统调度策略
*   长时间运行基准测试

10.  对于分时陷阱，有两种建议策略：

*   在运行基准测试之前测试所有代码，以确保一切正常工作
*   只有当所有线程都已启动或停止时，才使用 JMH 进行测量

# 第九章

1.  在 Java 应用编程的上下文中，进程是操作系统中的执行单元。当你启动一个程序，你就启动了一个过程。

2.  Java9 中引入了两个支持处理操作系统进程的新接口：`ProcessHandle`和`ProcessHandle.Info`。

3.  处理完成后，`handle.is.Alive()`方法返回`false`。

4.  我们可以通过句柄访问进程的 PID。
    `handle.getPid()`方法返回`Long`，表示 PID 的数值。

5.  为了得到当前进程的 PID，可以使用调用链`ProcessHandle.current().getPid()`。

6.  `command()`、`arguments()`、`commandLine()`、`startInstant()`、`totalCpuDuration()`、`user()`。
7.  为了得到控制子进程的进程句柄的`Stream`，应该使用静态方法`processHandle.children()`。

8.  `processHandle.descendants()`。

9.  `allProcess()`。

10.  `CompletableFuture`。

# 第十章

1.  Java 运行时有一个名为`Stack`的类，可以使用**后进先出**（**LIFO**）策略来存储对象。

2.  JVM 是用 C 编写的，执行调用 C 函数并从那里返回的操作。
    这个调用返回序列是使用本机方法栈维护的，就像其他 C 程序一样。

3.  Java 虚拟机`Stack`。
4.  在 Java 中，我们使用 API 来获取`Logger`。使用 API，模块可以为服务`LoggerFinder`提供实现，而服务`LoggerFinder`又可以返回实现`getLogger()`方法的`Logger`。

5.  `StackWalker`类。
6.  `RETAIN_CLASS_REFERENCE`、`SHOW_REFLECT_FRAMES`和`SHOW_HIDDEN_FRAMES`。

7.  如果我们指定第一个选项枚举常量，`RETAIN_CLASS_REFERENCE`作为`getInstance()`方法的参数，那么返回的实例将授予我们访问各个栈在遍历期间引用的类的权限。

8.  `SHOW_REFLECT_FRAMES`枚举常量将生成一个遍历器，其中包含来自某个反射调用的帧。

9.  枚举常量选项`SHOW_HIDDEN_FRAMES`将包括所有隐藏帧，其中包含反射调用以及为 Lambda 函数调用生成的调用帧。

10.  `StackWalker`类是最终类，不能扩展。

# 第十一章

1.  易用性。
2.  大约 10% 的 HTTP 协议未被 API 公开：
    *   标准/通用认证机制仅限于基本认证
    *   性能改进可能无法实现
    *   不支持对请求进行过滤
    *   不支持对响应进行过滤
    *   新的 API 不包括可插入的连接缓存
    *   缺乏通用的升级机制

3.  包名、源文件名、访问控制选项。
4.  `languageVersion()`、`optionLength(String option)`、`start(RootDoc root)`、`validOptions(String[][] options, DocErrorReporter reporter)`。
5.  `AttributeTree.ValueKind`和`DocTree.Kind`。

6.  HTML5。
7.  JVM 的 JavaScript 引擎。
8.  欧洲计算机制造商协会 JavaScript 脚本语言规范。
9.  支持 JarFile API 和标准类加载器。

10.  构造器不应接受任何参数。
    *   它必须是可序列化的
    *   它的属性必须包含更改器和访问器方法

# 第十二章

1.  反应式编程是指应用在异步数据流发生时对其作出反应。
2.  数据流是字符串和基本数据类型的二进制输入/输出。
3.  效率。
4.  以下是不需要的数据缓冲、数据转换和转换。
5.  `java.util.concurrent`。
6.  `Flow.Publisher`、`Flow.Subscriber`、`Flow.Subscription`、`Flow.Processor`。
7.  多个进程共享一个处理器。
8.  并发性和并行性经常被用作可互换的术语。并发是指当多个进程重叠时，尽管开始和停止时间可能不同。并行性发生在任务同时启动、运行和停止时。
9.  共享内存系统配置有多个处理器，所有处理器共享一个公共系统内存。
10.  在分布式存储系统中，每个处理器都有自己的内存，每个单独的处理器都与其他处理器完全链接，从而形成一个完全链接的分布式系统。

# 第十三章

1.  **数据报传输层安全**（**DTLS**）是一种通信协议。

2.  **传输层安全**（**TLS**）是最常见的网络安全协议。

3.  在实现握手重新协商时，始终实现`renegotiation_info`扩展。

4.  实现 FS 可以确保过去的会话加密密钥不会在长期加密密钥受损时受损。

5.  它本质上是存储公钥证书和私钥的数据库文件或数据存储库文件。

6.  `KeyStore`将存储在`/jre/lib/security/cacerts`文件夹中。

7.  `KeyStore.Builder`类用于延迟`KeyStore`的实例化。

8.  它具有以下特点：
    *   线程安全的
    *   输入映射不需要同步
    *   快速读取
    *   使用锁来写入
    *   无对象级锁定
    *   在非常精细的级别上锁定
9.  哈希码是一个对象生成的数字，存储在哈希表中，用于快速存储和检索。

10.  **Galois HASH**（**GHASH**）是一种密码系统哈希算法。

# 第十四章

1.  统一日志记录架构。
2.  命令行选项、装饰、级别、输出和标签。
3.  在 Java 日志框架的上下文中，装饰是关于日志消息的元数据。

4.  错误、警告、信息、调试、跟踪和开发。
5.  开发。
6.  错误。
7.  在源代码中。
8.  依赖于方法的编译器标志。
9.  C1 和 C2。
10.  C1。

# 第十五章

1.  **Unicode 转换格式 -8**（**UTF-8**）是一个字符集，它使用一到四个 8 位字节封装所有 Unicode 字符。它是 Unicode 的面向字节的编码形式。
2.  以下是 UTF-8 的一些特点：

    *   可以对所有 1112064 Unicode 代码点进行编码
    *   使用一到四个 8 位字节
    *   占所有网页的近 90%
    *   向后兼容 ASCII
    *   是可逆的
3.  `ResourceBundle`类。
4.  没有什么。
5.  基于给定`baseName`和默认`locale`的资源包
6.  Java18.9（Java11）支持 Unicode 10.0.0，于 2017 年 6 月 20 日发布。
7.  JDK9、10 和 11 已通过以下实现成功移植到 Linux/AArch64：
    *   模板解释器
    *   C1 JIT 编译器
    *   C2 JIT 编译器
8.  多分辨率图像包含同一图像的多个分辨率变体。
9.  `java.awt.Graphics`类用于从多分辨率图像中检索所需的变量。
10.  **CLDR**（简称**公共区域数据仓库**）是许多支持多种语言的软件应用的关键组件，被吹捧为最大的区域数据仓库，被众多大型软件供应商使用，包括苹果、谷歌、IBM 和微软。

# 第十六章

1.  JDK 的提议更改列表。
2.  广泛的信息吸引力。
3.  提案必须符合以下标准之一：
    *   需要大量的工程工作来实现（至少两周）
    *   涉及对 JDK 或其基础结构的重大更改
    *   是 Java 开发人员或用户的高需求项目
4.  草案这是最早的状态，在 JEP 已经写好并由作者分发以取得共识时使用。
5.  一旦作者达成共识，JEP 就可以登录到 JEP 档案中。
6.  一旦 JEP 被认为准备好进行正式评估，提交人就会设置这种状态。
7.  一旦 OpenJDK 负责人接受了 JEP，它就变为这个状态。
8.  “受到资助”表示职能部门领导或集团领导已判断 JEP 获得全额资助。
9.  已完成此状态表示增强工作已在版本发布中完成并交付。
10.  <http://openjdk.java.net/jeps/0>。

# 第十七章

1.  Java 用户组。
2.  有 200 多个。
3.  在地理上。
4.  活动、书籍、产品和其他资源的折扣。
5.  **Java 社区流程™**是针对 Java 平台开发技术规范标准的结构化方法。
6.  Java 社区由数百万开发人员组成。
7.  四大好处如下：

*   与其他 Java 专业人士联网
*   分享技巧、技巧和资源
*   向他人学习
*   增加 Java 知识

8.  <https://www.oracle.com/technetwork/articles/otn-submit-100481.html>。
9.  在 [JCP](http://jcp.org) 登记。
10.  任何注册会员