# C# 面向对象编程实用指南（四）

> 原文：[`zh.annas-archive.org/md5/ADAC00B29224B3ED5BF1EE522FE998CB`](https://zh.annas-archive.org/md5/ADAC00B29224B3ED5BF1EE522FE998CB)
> 
> 译者：[飞龙](https://github.com/wizardforcel)
> 
> 协议：[CC BY-NC-SA 4.0](http://creativecommons.org/licenses/by-nc-sa/4.0/)

# 第十五章：理解设计模式和原则

多年来，软件变得越来越复杂。现在，软件不仅用于数学计算或简单的**创建、读取、更新和删除**（CRUD）操作：我们正在使用它来执行复杂的任务，如控制火箭发动机或每天管理大量数据。来自各个行业的企业已经开始采用软件系统，包括银行、保险公司、研究机构、教育机构和政府机构。对软件的需求越高，越多的人开始在软件开发领域建立职业。从汇编语言编程开始，经过了过程式编程，然后是**面向对象编程**（OOP）时代的介绍，尽管出现了其他类型的编程，如函数式编程，但 OOP 仍然是最受欢迎的模型。OOP 帮助开发人员编写易于维护和扩展的良好模块化软件。在本章中，我们将讨论一些最重要的设计原则和模式，这些原则和模式被成千上万的开发人员遵循，我们将涵盖以下主题：

+   软件开发中的设计原则

+   软件开发中的不同设计模式

+   创建设计模式

+   行为设计模式

+   结构设计模式

+   **模型-视图-控制器**（MVC）模式

# 设计原则

在我们开始讨论设计原则之前，让我们思考一下在软件开发中我们所说的**设计原则**是什么意思。当我们开发软件时，我们首先设计其架构，然后开始编写其代码。我们希望以这样的方式编写我们的代码，即它不会产生错误，或者如果有错误，很容易找到。我们还希望在阅读代码时能够轻松理解它，并且希望它的结构能够在以后需要时进行更改。虽然很难编写最佳代码，但有许多在软件开发中由经验丰富的计算机科学家开发的原则。使用这些原则，开发人员可以编写非常干净的代码。

软件开发人员 Robert C. Martin，也被称为 Uncle Bob，提出了五个软件设计原则。这些原则对开发人员非常有效和有帮助，以至于它们已经成为软件行业的一种规范。它们统称为 SOLID 原则，代表以下不同的定义：

+   **S**代表**单一职责原则**

+   **O**代表**开闭原则**

+   **L**代表**Liskov 替换原则**

+   **I**代表**接口隔离原则**

+   **D**代表**依赖反转原则**

让我们逐一讨论这些原则。

# 单一职责原则

"一个类应该有一个，只有一个更改的原因。"

– *Robert C. Martin*

这意味着当我们编写一个类时，我们应该以只有一个职责的方式设计它。您应该只需要更改类的一个原因。如果您有多个更改类的原因，它就违反了单一职责原则。

如果一个类具有多个职责，并且您对一段代码进行更改，这可能会破坏另一段代码，因为它们位于同一个类中并共享一些依赖关系。您的代码可能不太解耦。

# 开闭原则

代码需要以这样的方式编写，即在软件实体（如类、模块或函数）中添加新内容是好的，但不应允许修改实体本身。这减少了产生错误的可能性。

# Liskov 替换原则

"派生类型必须完全可替代其基本类型。"

– *Barbara Liskov*

该原则规定，当你编写一个类时，如果它是从另一个类派生的，它应该能够被基类替换。否则，你的代码将非常脆弱和耦合。这个原则是由芭芭拉·利斯科夫首次发现的，因此以她的名字命名。

# 接口隔离原则

有时，开发人员会创建包含太多信息的大接口。许多类可能使用这个接口，但它们可能并不需要其中的所有内容。为了遵循这个原则，你应该避免这种情况。这个原则支持小接口而不是大接口，如果必要，一个类可以继承多个适用于该类的小接口。

# 依赖反转原则

“高层模块不应该依赖低层模块；两者都应该依赖抽象。抽象不应该依赖细节。细节应该依赖抽象。”

- *罗伯特·C·马丁*

我们知道，在软件开发中，我们使用层。为了使这些层解耦，我们必须以这样的方式设计这些层的依赖关系，以便这些层不是相互依赖，而是依赖于抽象。因此，如果你改变高层模块或低层模块中的某些内容，它不会损害系统。当我们创建这些抽象时，我们必须以这样的方式设计它们，使它们不依赖于实现细节。这些抽象应该是独立的，实现这些接口或抽象类的类应该依赖于这些抽象。

# 创造性设计模式

在面向对象编程中，一切都被视为对象，因此跟踪对象的创建和管理非常重要。如果开发人员不太关注这个话题，软件的对象可能会使软件变得脆弱和耦合。保持对象适当地维护对于保持应用程序易于扩展非常重要。创造性设计模式是帮助以避免对象创建的最常见问题的方式创建对象的模式。

创造性设计模式中存在两个主要概念：

+   封装系统使用的具体类的知识

+   隐藏具体类的创建和组合实例

创造性设计模式分为对象创建模式和类创建模式，其中**对象创建模式**处理对象的创建，**类创建模式**处理类的发现。

行业中有五种主要的创造性设计模式：

+   抽象工厂模式

+   建造者模式

+   工厂方法模式

+   原型模式

+   单例模式

# 抽象工厂模式

《设计模式：可复用面向对象软件的元素》一书中，四人组提出的这种模式的定义是提供一种组合来构建类似或依赖对象家族，而不指定它们的具体类。

这种模式提供的最重要的东西是对象创建的分离或抽象。如果你不遵循任何模式，当你创建一个对象时，最简单的方法就是在需要的地方使用`new`关键字创建一个对象。例如，如果我在我的`Bank`类中需要一个`Person`对象，最简单的方法就是在`Bank`类中使用`new`关键字实例化一个`Person`对象。然而，使用这种方法有时会使软件变得复杂。为了避免这种情况，我们可以使用抽象工厂模式。

抽象工厂模式主要用于有着相同家族的对象，或者以某种方式相关或依赖的情况。其思想是创建工厂类来执行对象创建的工作。如果一个对象`A`需要另一个对象`B`的实例，对象`A`应该要求对象`B`的工厂创建一个`B`的对象并将其传递给对象`A`。这样，对象`A`独立于对象`B`的创建。现在，在抽象工厂模式中，还有另一层抽象。工厂类也被抽象化了。这意味着对象`A`不会直接调用对象`B`的工厂，而是使用一个抽象。应该有一个机制来确定需要调用哪个`Factory`类。这意味着对象`A`不依赖于另一个对象的任何特定工厂。

# 建造者模式

将复杂对象的计划与其实现分离是建造者模式的主要思想。在面向对象的软件开发中，我们有时需要创建相当复杂的对象。例如，我们可能创建一个使用其他对象的对象，而这些对象又使用其他对象。当你只需要该对象执行另一种工作时，创建或实例化这种对象可能会很困难。这可能使代码变得更加复杂，降低其可读性。

让我们想想一个例子。想象一下，你正在制作一些汉堡，其中一些是鸡肉汉堡，一些是牛肉汉堡。在创建鸡肉汉堡对象时，你必须每次创建一个鸡肉汉堡对象时创建一个鸡肉汉堡肉饼对象、一个番茄酱对象、一个奶酪对象和一个面包对象，这会导致混乱的代码。当创建牛肉汉堡对象时，你也必须遵循相同的流程。这是一种处理和创建这些对象的非常复杂的方式。

建造者模式提供了一种解决这种复杂性的好方法。使用这种模式，我们创建一个名为`Builder`的类，其主要任务是创建复杂对象并返回新创建的对象。使用建造者模式，我们使用另一种类型的类，通常称为`director`类。这个类的任务是调用`Builder`类并从中获取对象。

让我们回到我们的汉堡示例。我们可以有一个`ChickenBurgerBuilder`类和一个`BeefBurgerBuilder`类。这些类将在类中设置项目、汉堡肉饼、面包、番茄酱和奶酪。当`BurgerDirector`类想要创建一个`鸡肉汉堡`时，它将调用`ChickenBurgerBuilder`。要创建一个`牛肉汉堡`，它将调用`BeefBurgerBuilder`。创建`汉堡肉饼`和其他配料的复杂性将由`Builder`类处理。

# 工厂方法模式

工厂方法模式与抽象工厂模式非常相似。不同之处在于，在工厂方法模式中，工厂层不是抽象的。使用这种模式意味着你将创建一个工厂类，该类将处理实现相同抽象的类的创建。这意味着，如果有一个由许多子类定义的接口，`Factory`类可以根据传递给`Factory`的逻辑创建任何这些子类中的任何一个。

让我们来想一个例子。我们将使用工厂方法模式来解决我们在生成器模式示例中提到的制作汉堡的问题。我们将创建一个名为`BurgerFactory`的`Factory`，它将接受一个输入，比如`typeOfBurger`（鸡肉或牛肉）。然后，`BurgerFactory`将决定应该创建哪种`Burger`类型的对象。假设我们有一个名为`Burger`的接口，`ChickenBurger`和`BeefBurger`都实现了这个接口。这意味着`BurgerFactory`将返回一个`Burger`类型的对象。客户端将不知道将创建和返回哪个`Burger`对象。通过使用这种模式，我们将客户端与特定对象隔离开来，从而增加了代码的灵活性。

# 原型模式

当你想要避免使用传统的对象创建机制（如 new 关键字）创建相同类型或子类型的新类时，可以使用这种设计模式。简而言之，这种模式规定我们应该克隆一个对象，然后将克隆的对象作为另一个新创建的对象来处理。这样就避免了传统的对象创建方法。

# 单例模式

单例模式是一个非常简单的设计模式。它涉及在整个应用程序中只创建一个类的对象。**单例对象**是一个不能有多个实例的对象。每当一段代码需要使用这个单例对象时，它不会创建一个新对象，而是使用已经存在的旧对象。

当你只想处理来自一个来源的一些信息时，可以使用这种设计模式。单例模式的最佳示例是数据库连接字符串。在应用程序中，如果使用了多个数据库连接，数据库可能会损坏并导致应用程序异常。在这种情况下，最好将连接字符串作为单例对象，这意味着所有通信都使用同一个实例。这减少了出现差异的机会。

# 结构设计模式

在软件开发中有一些与代码结构相关的设计模式。这些模式可以帮助你以一种能够避免常见结构问题的方式设计你的代码。在《设计模式：可复用面向对象软件的元素》一书中，由四人组成的设计模式一书中有七种结构设计模式。在本节中，我们只讨论其中的四种，分别是：

+   适配器模式

+   装饰器模式

+   外观模式

+   代理模式

如果你想了解其他三种模式的更多信息，请参阅四人组的《设计模式：可复用面向对象软件的元素》一书。起初，开始使用这些模式可能会有点困惑，但随着经验的增加，识别哪种模式适合哪种情况将变得更容易。

# 适配器模式

通常，当我们想到适配器这个词时，我们会想到一个小设备，它可以帮助我们将电子设备插入具有不同接口的电源插座。适配器设计模式实际上在软件代码中做同样的事情。这种设计模式规定，如果软件的两个模块想要相互通信，但一个模块期望的接口与另一个模块具有的接口不同，那么应该使用适配器，而不是改变一个接口以匹配另一个接口。这样做的好处是，将来如果你想让你的代码与另一个接口通信，你不需要改变你的代码，只需要使用另一个适配器。

例如，想象一下，你有一个接口`A`，但你想要与之通信的代码需要另一个接口`B`。你可以使用一个适配器将接口`A`转换为接口`B`，而不是将接口`A`更改为接口`B`。这样，使用接口`A`的代码不会出错，你将能够与要求接口`B`的代码进行通信。

# 装饰者模式

装饰者模式允许我们动态地向对象添加新的行为。当这种新行为被添加到对象时，它不应该影响对象上已经存在的任何其他行为。当你需要在运行时向对象添加新行为时，这种模式提供了一种解决方案。它还消除了创建子类只是为了向任务添加行为的需要。

# 外观模式

有时，如果你有复杂的对象关系，很难将它们全部映射并在代码中使用。外观模式指出，你应该使用一个中间对象来处理对象关系问题，并为客户端提供一个简单的联系点。让我们想想一个例子：当你去餐厅点餐时，你实际上不会去找厨师或厨房里的人收集食物，然后自己做饭；你告诉服务员你想要什么食物。你不知道这个项目将如何准备或者谁会准备它。你无法控制食物的制作，你只知道你会得到你要求的项目。在这里，接受订单的人就是一个外观。他们接受你的订单，并要求不同的人准备你要求的项目。

假设你点了一份牛肉汉堡。你调用一个`GetBeefBurger()`方法，外观实际上会调用以下内容：

```cs
Bread.GetBread()
Sauce.PutSauceOnBread(Bread)
SliceTomato()
PutTomatoOnBread()
Beef.FryBeefPatty()
PutBeefPattyOnBread()
WrapTheBurger()
ServeTheBurger()
```

上述方法并不是真正的方法。我只是想给你一个想法，外观的工作实际上是隐藏客户端的复杂性。

# 代理模式

这种模式与我们讨论过的其他结构设计模式非常相似。如果有一种情况，一个代码片段不应该直接调用另一个代码片段，不管出于什么原因，都可以使用代理模式。代理模式在代码片段没有权限调用另一个代码片段或者直接调用代码片段在资源方面是昂贵的情况下特别有用。如果我们想在应用程序中使用第三方库，但出于安全原因不希望我们的代码直接调用该库，我们可以创建一个代理并让它与第三方代码进行通信。

# 行为设计模式

行为设计模式是处理对象之间通信的设计模式。这些设计模式允许你的对象以一种避免开发人员面临的与对象行为相关的常见问题的方式进行通信。在这个类别中有许多模式：

+   责任链模式

+   命令模式

+   解释器模式

+   迭代器模式

+   中介者模式

+   备忘录模式

+   观察者模式

+   状态模式

+   策略模式

+   模板方法模式

+   访问者模式

然而，在本书中，我们只会讨论以下行为设计模式：

+   命令模式

+   观察者模式

+   策略模式

如果你想了解更多，请参考我们之前提到的四人帮的《设计模式：可复用面向对象软件的元素》一书。

# 命令模式

这种模式规定，当一个对象想要通知另一个对象或调用另一个对象的方法时，它应该使用另一个对象而不是直接这样做。建立通信的对象称为命令对象。命令将封装持有要调用的方法、要调用的方法名称以及要传递的参数（如果有的话）的对象。命令模式有助于解耦调用者和接收者之间的关系。

# 观察者模式

**观察者模式**是解决一个问题的解决方案，即许多对象需要知道特定对象何时发生变化，因为它们可能需要更新其端上的数据。一种方法是所有对象或观察者应该询问对象或可观察对象数据是否已更改。如果可观察对象中的数据已更改，观察者将执行其工作。然而，如果这样做，观察者必须经常询问可观察对象关于数据变化，以避免减慢应用程序的速度。这需要大量资源。

观察者模式表示可观察对象应该知道想要了解主题数据变化的观察者列表，并在主题数据发生变化时通知每个观察者。这可以通过调用观察者的方法来实现。这种模式的一个很好的应用是 C#中的事件和委托。

# 策略模式

让我们来看一下《设计模式：可重用面向对象软件的元素》一书中的策略模式的定义：

例如，一个方法可以根据使用它的类的不同类型的实现而有所不同。因此，这个定义意味着我们需要使这些不同的算法实现一个基类或接口，以便它们属于同一个家族，并可以被客户端互换使用。定义的最后一部分意味着这种模式将允许客户端使用不同的算法而不影响其他客户端。

假设我们有一个名为`Animal`的类，它具有一些常见属性，如`eat`，`walk`和`noise`。现在，假设您想添加另一个属性，如`fly`。您的类中的大多数动物都可以飞，但有一些不能。您可以将`Animal`类分成两个不同的类，如`AnimalWhichCanFly`和`AnimalWhichCantFly`。然而，将`Animal`类分成两个可能会使事情过于复杂，因为这些动物可能还具有其他不同的属性。因此，您可以使用组合而不是继承，这意味着您可以在`Animal`类中添加一个名为`fly`的属性，并使用它来指示此行为。

策略模式规定，我们应该使用接口（例如`IFly`）而不是固定类型（`fly`）作为属性类型，然后创建实现`IFly`并具有不同算法的`子类`。然后，我们可以利用多态性，并在创建`Animal`类的子类时在运行时分配特定的子类。

让我们尝试将这种模式应用于前面的例子。在`Animal`类中，我们将使用`IFly`而不是使用`Fly`属性，然后实现实现`IFly`的不同类。例如，我们创建`CanFly：IFly`和`CannotFly：IFly`类。`CanFly`和`CannotFly`将有`Fly`方法的不同实现。如果我们创建一个实现`Animal`类的`Dog`类，我们将把`Fly`属性设置为`CannotFly`类。如果我们创建一个`Bird`类，我们将创建`CanFly`的实例并将其分配给`Fly`属性。通过应用这种模式，我们实现了一个不那么复杂的对象结构和易于更改的算法。

# MVC 模式

MVC 模式是行业中最流行的设计模式之一。您可能已经听说过它，即使您是行业的新手。这种模式在 Web 开发中被广泛使用。许多流行的 Web 开发框架使用这种设计模式。以下是一些使用 MVC 模式的流行框架：

+   C#: ASP.NET MVC Web Framework

+   **Java:** Spring 框架

+   **PHP:** Laravel 框架，Codeigniter 框架

+   **Ruby:** Rails 框架

MVC 设计模式规定我们应该将 Web 应用程序分为三个部分：

+   模型

+   视图

+   控制器

**模型**是将保存数据模型或对象并将用于数据库事务的部分。**视图**指的是应用程序的前端，用户或客户所看到的部分。最后，**控制器**是处理应用程序所有业务逻辑的部分。所有逻辑和决策部分都将在控制器中。

MVC 模式的好处在于您的应用程序是解耦的。您的视图独立于您的业务逻辑，您的业务逻辑独立于您的数据源。这样，您可以轻松地更改应用程序的一部分，而不会影响应用程序的其他部分。

# 摘要

软件开发之所以有趣，是因为它一直在变化。您可以以许多方式开发、设计或编写代码。这些方式都不能被归类为最佳方式，因为您的代码可能需要根据情况进行更改。然而，由于软件开发是一种工程类型，有各种规则可以使您的软件更加强大和可靠。软件设计原则和设计模式就是这些规则的例子。了解这些概念并将其应用于您自己的情况将使您作为开发人员的生活更加轻松。

本章希望给您一个设计模式基础的概念，并向您展示可以查找更多信息的地方。在下一章中，我们将了解一个非常强大和有趣的软件，叫做 Git。Git 是一个版本控制系统，有助于跟踪软件代码。


# 第十六章：Git - 版本控制系统

如今，软件开发已经达到了一个新的水平。它不再仅仅涉及编写代码——软件开发人员现在还必须熟悉一系列重要的工具。没有这些工具，要在团队中工作或高效工作就变得非常困难。版本控制就是其中之一。在众多可用的版本控制系统中，Git 是最流行和最强大的。Git 版本控制已经在行业中存在了相当长的时间，但最近已经成为几乎所有软件公司的一部分。了解 Git 现在对开发人员来说是必不可少的。在本章中，我们将学习关于 Git 版本控制系统的知识。让我们来看看我们将要涵盖的主题：

+   什么是版本控制系统？

+   Git 的工作原理

+   在 Windows 中安装 Git

+   Git 的基础知识

+   Git 中的分支

# 什么是版本控制？

版本控制系统是在开发过程中跟踪软件代码更改的系统或应用程序。软件开发人员过去会通过将代码复制到另一个文件夹或机器中来保留他们的代码备份。如果开发人员或生产机器崩溃，他们可以从备份中取出代码并运行。然而，手动保留和维护备份是麻烦的，容易出错，并且备份系统容易受损。因此，开发人员开始寻找一个能够保护他们代码的系统或应用程序。

版本控制在多个程序员一起工作的情况下也很有用。过去，程序员必须要么在不同的文件上工作以避免冲突，要么在一段时间后仔细地合并代码。手动合并代码是非常危险和耗时的。

在版本控制系统中，代码文件中的每个更改实际上都是代码的一个新版本。在软件行业中，有许多版本控制系统可用，包括 Git、Subversion、Mercurial 和 Perforce。Git 是最流行的版本控制系统，由软件开发者 Linus Torvalds 开发。它是一个非常出色的应用程序，现在几乎在世界上的每个软件公司中使用。

# Git 的工作原理

Git 的主要任务是跟踪代码版本并允许开发人员在必要时返回到任何以前的状态。这是通过对每个版本进行快照并在本地文件存储系统中维护来完成的。与其他系统不同，Git 使用本地文件存储来存储快照，这意味着即使没有互联网连接，也可以在本地使用 Git。有了本地版本的 Git，你几乎可以做任何你可以在连接互联网的 Git 版本中做的事情。

在你的项目中安装 Git 之后，你可以选择你的文件系统中想要保留在 Git 版本控制下的目录。通常，Git 中的一个项目或目录被称为**仓库**。一个仓库可能包含不同的项目，一个项目，或者只是一些项目文件，这取决于你想要在 Git 版本控制中保留什么。你可以有两种方式在本地机器上拥有一个 Git 仓库。你可以自己初始化一个 Git 仓库，或者你可以从远程服务器克隆一个仓库。无论哪种方式，你都会在创建或克隆仓库的同一个文件夹中创建一个名为`.git`的文件夹。这个`.git`文件是本地存储文件，所有与该仓库相关的信息都将存储在那里。Git 以非常高效的方式存储数据，因此即使有大量的快照，文件也不会变得很大。

Git 中有三种主要状态，我们将在接下来的章节中探讨：

+   修改

+   暂存

+   提交

# 修改

当您初始化了一个 Git 仓库，然后添加一个新文件或编辑一个现有文件时，该特定文件将在 Git 中标记为已修改。这意味着该文件包含了 Git 在其本地存储/数据库中已存储的快照中的一些更改。例如，如果您在 Git 仓库中创建一个 C#控制台应用程序项目，那么该解决方案的所有文件都将被标记为已修改，因为它们都不在 Git 仓库历史记录中。

# 暂存

在 Git 中，暂存指的是准备提交的文件。为了防止不需要的文件意外提交到 Git 存储库中，Git 在已修改和已提交之间引入了这一步骤。当您将文件标记为已暂存时，这意味着您希望在下一次提交中提交这些文件。这也为您提供了编辑文件并不使其处于已暂存状态的选项，以便更改不会保存在存储库中。如果您想在本地机器上应用一些配置，但不希望这些更改出现在存储库中，这个功能非常方便。

# 已提交

已提交状态是指文件的一个版本已保存在本地数据库中。这意味着已经拍摄并存储在 Git 历史记录中以供将来参考。在远程处理存储库时，您将推送的代码实际上只是已提交的代码。

让我们看一下下面的图表，以了解这些状态之间的流程：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/b1dcec2a-3c29-49cb-a6ba-66f479de78ce.png)

# 在 Windows 上安装 Git

Git 最初是为基于 Linux 或 Unix 的操作系统开发的。当它在流行度上升并且 Windows 用户开始要求 Git 时，推出了 Git for Windows。在 Windows 上安装 Git 现在是一个非常简单的过程。要安装 Git，请转到[`git-scm.com/download/win`](https://git-scm.com/download/win)。

您将被带到以下截图所示的页面：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/e9c46f12-f598-401c-b98f-be26af4608c6.png)

Git for Windows 应该会自动开始下载。如果没有开始，您可以点击网站上给出的链接。下载文件将是一个可执行文件，因此要开始安装，请执行可执行文件。在安装过程中，如果您不确定选择什么，这里最好的选择是保持一切默认。

以下截图显示了可以安装哪些组件：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/ad9369d6-e2e5-4c3a-9228-8f271256a146.png)

有一个部分可以选择用于 Git 的默认编辑器。所选择的默认编辑器是 Vim，如下截图所示。如果您不习惯使用 Vim，可以将其更改为您喜欢的编辑器：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/414ae3e5-f6db-4317-88ed-8c6832b39bfb.png)

按照步骤。安装 Git 后，要测试安装是否成功，请转到命令行或 PowerShell 并输入以下内容：

```cs
git --version
```

您应该看到类似以下的输出：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/bcab6f8b-19bd-42a5-8411-ff126aa10c0c.png)

如果您能看到版本号，这意味着安装成功了。

# Git 的基础知识

如前所述，Git 最初是为 Linux 系统开发的，这就是为什么使用这个工具的主要方式是通过命令行。在 Windows 上，我们不像 Linux 或 Unix 用户那样经常使用命令行，但使用它可以让您访问 Git 的所有功能。对于 Windows，有一些 GUI 工具可以用于 Git 操作，但它们通常有一些限制。由于命令行是 Git 的首选方法，因此本书中只涵盖命令行命令。

# Git 配置

`git config`命令是用于配置 Git 设置的命令。Git 的最小设置是设置用户名和电子邮件地址。您可以为每个 Git 仓库单独配置，也可以全局配置设置。如果您全局设置配置，您就不必每次初始化 Git 仓库时都配置电子邮件地址和用户名。如果有必要，您可以在每个仓库中覆盖这些设置。

要配置您的电子邮件地址和用户名，请运行以下命令：

```cs
git config user.name = "john"
git config user.email = "john@example.com"
```

如果您想要全局设置配置，您需要添加`--global`关键字，如下所示：

```cs
git config --global user.name = "john"
git config --global user.email = "john@example.com"
```

如果您想查看其他全局配置设置的可用性，可以使用以下命令：

```cs
git config --list
```

然后您可以更改您想要更改的设置。

# Git 初始化

如果您有一个当前尚未使用 Git 版本控制的项目，可以使用以下命令初始化项目：

```cs
git init
```

当您运行上述命令时，您在计算机上安装的 Git 程序会在项目目录中创建一个`.git`目录，并开始跟踪该项目的源代码。在新项目中初始化 Git 后，所有文件都显示为已修改，您必须将这些文件暂存以提交这些更改。

# Git 克隆

如果您想要使用位于远程服务器上的项目，您必须克隆该项目。要克隆项目，您必须使用以下命令：

```cs
git clone [repo-url]
```

例如，如果您想要克隆 Angular 项目，您必须输入以下内容：

```cs
git clone https://github.com/angular/angular.git
```

当您将存储库克隆到本地环境时，将下载`.git`文件夹。这包括提交历史、分支、标签和远程服务器中包含的所有其他信息。基本上是远程服务器版本的副本。如果您在本地副本中提交更改，然后将其推送到远程存储库，则您的本地副本将与远程副本同步。

# Git 状态

在工作时，您会想要检查当前代码的状态。这意味着找出哪些文件被修改了，哪些文件被暂存了。您可以使用以下命令获取所有这些信息：

```cs
git status
```

让我们来看一个例子。如果我们向项目中添加一个名为`hello.txt`的新文件，并且该文件被 Git 跟踪，并检查其状态，我们将看到如下内容：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/f99a31f5-fdff-4be7-98c6-d58b8ab02b59.png)

在这里，我们可以看到一个名为`hello.txt`的文件位于`未跟踪`文件下，这意味着该文件尚未被 Git 跟踪。`git status`命令还会告诉您当前所在的分支。在这种情况下，我们在`master`分支中。

# Git 添加

`git add`命令是一个将修改的文件/文件夹添加到 Git 跟踪系统的命令。这意味着这些文件和文件夹将被暂存。命令如下：

```cs
git add <file-name/folder-name>
```

让我们继续我们的例子，看看当我们在 Git 中添加`hello.txt`文件时会发生什么。为此，我们将执行以下命令：

```cs
git add hello.txt
```

输出如下：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/8032b4ee-0843-4aeb-b19b-a149a140fa86.png)

在这里，我们看到了关于**换行符**（**LF**）和**回车换行符**（**CR+LF**）的警告，这些是某种格式。替换的原因是我们在这里使用的是 Windows 操作系统，但目前我们不需要担心这个问题。这里的重点是文件已经被正确暂存。现在，如果我们检查状态，我们将看到以下内容：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/1a59cee9-dde1-42e9-a8ce-930e2605be3f.png)

在这里，我们可以看到`hello.txt`文件被放置在`要提交的更改`部分。这意味着该文件已经被暂存。

在一个真实的项目中，您可能会在暂存文件之前同时处理多个不同的文件。逐个添加文件或者用逗号分隔的方式写入文件名可能会非常繁琐。如果您希望将所有修改过的文件都暂存，可以使用以下命令将所有文件添加到暂存区域：

```cs
git add *
```

# Git 提交

`git commit`命令用于将代码提交到 Git 历史记录中。这意味着对代码基础进行快照，并将其存储在 Git 数据库中以供将来参考。要提交文件/文件夹，您必须使用以下命令：

```cs
git commit
```

如果执行上述代码，将打开为 Git 设置的默认编辑器，并要求您输入提交的消息。还有一种更简洁的方法。如果要直接输入提交的消息，可以运行以下命令：

```cs
git commit -m "your message"
```

现在让我们提交我们的`hello.txt`文件到我们的 Git 存储库。为此，我们将运行以下命令：

```cs
git commit -m "committing the hello.txt file with hello message" 
```

输出应如下屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/d6f675f4-c355-4775-9caf-5b231eb7ebee.png)

成功提交后，将看到`1 file changed, 1 insertion(+)`。如果再次检查状态，将看到没有要提交的内容，如下面的屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/06f99414-18c3-4c4d-9563-e8e392f14451.png)

# Git log

要检查存储库中进行了哪些提交，可以使用以下命令：

```cs
git log
```

输出将如下所示：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/91189c17-7afe-4f05-8189-a4e5fc5facaa.png)

从日志中，我们可以看到目前只有一个提交。我们可以看到提交的哈希值，即紧跟在`commit`后面的数字。我们可以看到`commit`是由`Raihan Taher`在`master`分支上进行的。我们还可以在日志中看到`commit`的消息。这是一个非常有用的命令，可以检查已提交了什么。

# Git remote

`git remote`命令用于查看是否与远程存储库建立了连接。如果运行以下命令，将显示远程存储库的名称。通常，远程名称设置为`Origin`。您可以有多个远程存储库。让我们看看这个命令：

```cs
git remote
```

如果我们执行此命令，将看不到任何内容，因为还没有远程存储库，如下面的屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/af4087a5-badb-455e-9239-cc7b52d4179d.png)

让我们添加一个远程存储库。我们将使用 GitHub 作为我们的远程服务器。在 GitHub 上创建存储库后，我复制了该存储库的 URL。我们将把它添加到我们的本地存储库。为此，我们使用以下命令：

```cs
git remote add <remote-name> <repository-link-remote>
```

在我们的示例中，命令如下：

```cs
git remote add origin https://github.com/raihantaher/bookgitexample.git
```

添加了远程存储库后，如果执行`git remote`，将看到`origin`被列为远程存储库，如下面的屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/75dade12-09c0-4fab-9c49-18cc47759a1b.png)

如果要查看有关远程存储库的更多详细信息，可以执行以下命令：

```cs
git remote -v
```

这将显示您添加的远程存储库的 URL，如下面的屏幕截图所示：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/b198c049-5136-47e6-bb2c-2365a95d3337.png)

# Git push

当您想要将本地提交上传或推送到远程服务器时，可以使用以下命令：

```cs
git push <remote-repo-name> <local-branch-name>
```

以下是如何使用此命令的示例：

```cs
git push origin master
```

执行此命令后，如果推送成功，将看到以下消息：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/ed93b671-65e1-4fe7-bc73-be880541f6d1.png)

# Git pull

`git pull`命令用于从远程存储库获取最新的代码。由于 Git 是一个分布式版本控制系统，多人可以在一个项目上工作，所以有可能其他人已经用最新的代码更新了远程服务器。要访问最新的代码，请运行以下命令：

```cs
git pull <remote-repo-name> <local-branch-name>
```

以下是如何使用此代码的示例：

```cs
git pull origin master
```

如果运行此代码，将弹出以下消息：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/e561a54b-2ebf-496b-a114-8ebf58e41f9f.png)

这意味着我们的本地存储库与远程存储库保持同步。如果远程存储库中有新的提交，`git pull`命令将把这些更改拉到我们的本地存储库，并指示已拉取更改。

# Git fetch

`git fetch`命令与`git pull`命令非常相似，但是当您使用`git fetch`时，代码将从远程存储库获取到本地存储库，但不会与您的代码合并。在检查了远程代码后，如果您想要将其与本地代码合并，您必须显式运行`git merge`命令。执行此操作的命令如下：

```cs
git fetch <remote-repo>
```

如果您运行上述命令，远程存储库中的所有分支将被更新。如果您指定一个本地分支，只有该分支将被更新：

```cs
git fetch <remote-repo> <local-branch>
```

让我们尝试在我们的示例代码中执行`git fetch`命令：

```cs
git fetch origin master
```

您将看到以下输出：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/032f5867-815b-48f5-be9d-d4d7a5048c59.png)

# 在 Git 中分支

分支通常被认为是 Git 的最佳功能之一。分支使 Git 与所有其他版本控制系统不同。它非常强大且易于使用。在我们学习不同的分支命令之前，让我简要解释一下 Git 如何处理提交，因为这将帮助您理解 Git 分支。在 Git 中，我们已经知道每个提交都有一个唯一的哈希值，并且该哈希值存储在 Git 数据库中。使用哈希值，每个提交都存储了先前提交的哈希值，这被称为该提交的父提交。除此之外，还存储了另一个哈希值，该哈希值存储了在该提交上暂存的文件，以及提交消息和提交者和作者的信息。对于存储库的第一个提交，父提交为空。

以下图显示了 Git 中哈希的示例：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/3dcb22af-ba87-4a31-a293-9ac6079c582c.png)

我们将提交中的所有信息称为快照。如果我们做了三次提交，我们可以说我们有**快照 A**，**快照 B**和**快照 C**，如下图所示，依次排列：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/3df485a8-2ee2-4921-8b23-a4fde0b38713.png)

默认情况下，当您初始化本地 Git 存储库时，会创建一个名为`master`的分支。这是大多数开发人员将其视为 Git 树中的主要分支的分支。这是可选的；您可以将任何分支视为主分支或生产分支，因为所有分支具有相同的能力和功能。如果您从**快照 C**（**提交 3**或**C3**简称）创建一个名为`feature`的分支，分支将从**C3**（**提交 3**）开始，并且测试分支上的下一个提交将将 C3 视为父提交。

以下图显示了分支：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/ce4743a5-97e8-4c76-aa3f-7a4ec0caaf3e.png)

**HEAD**是一个指向活动提交或分支的指针。这对开发人员以及 Git 版本控制是一个指示器。当您进行新的提交时，HEAD 将移动到最新的提交，因为这是将作为下一个提交的父提交创建的快照。

# 创建分支

现在让我们来看一下在 Git 中创建分支的命令。创建分支非常容易，因为它不会将整个代码库复制到一个新的位置，而是只保持与 Git 树的关系。有几种创建分支的方法，但最常见的方法如下：

```cs
git branch feature
```

在命令行上应该如下所示：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/b2404d53-01bc-4c4d-9803-5381da16d2b9.png)

# 查看可用分支

要查看本地 Git 存储库中有哪些分支可用，可以输入以下命令：

```cs
git branch
```

执行上述代码后，您应该看到以下输出：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/fcca175f-04b5-490c-b504-b81c3b9a8ecc.png)

我们可以看到我们的本地存储库中有两个分支。一个是`master`分支，另一个是`feature`分支。`*`字符表示 HEAD 指向的位置。

# 切换分支

在前面的示例中，我们看到，即使创建了 feature 分支，HEAD 仍然指向 master。切换到另一个分支的命令如下：

```cs
git checkout <branch-name>
```

在我们的示例中，如果我们想从`master`切换到`feature`分支，我们必须输入以下命令：

```cs
git checkout feature
```

输出如下：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/a5034adf-dd2e-4103-afde-9d72df501e53.png)

运行命令后，我们可以看到 Git 已经切换到了`feature`分支。现在我们可以再次运行`git branch`命令来查看 HEAD 指向的位置，如下截图所示：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/a7e605d1-aa7c-48ae-a8a9-4296f745c73f.png)

很可能，当你创建一个分支时，你会想立即在该分支上工作，所以有一个快捷方式可以创建一个分支然后切换到它，如下代码所示：

```cs
git checkout -b newFeature
```

# 删除一个分支

要删除一个分支，你需要执行以下命令：

```cs
git branch -d feature
```

如果分支成功删除，你应该会看到类似下面截图中显示的消息：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/575435ef-b9ac-40f5-b244-bf367d2abe0c.png)

# 在 Git 中合并

合并一个分支到另一个分支，你需要使用`merge`命令。记住，你需要在你要将代码合并的分支上执行该命令，而不是在将要被合并的分支上，或者其他任何分支上。命令如下：

```cs
git merge newFeature
```

输出应该如下：

![](https://github.com/OpenDocCN/freelearn-csharp-zh/raw/master/docs/hsn-oop-cs/img/34f6e505-44e1-4d6d-b5f0-18bf24f25099.png)

# 总结

在本章中，我们学习了一个与 C#编程语言不直接相关，但对 C#开发人员来说仍然是一个必不可少的工具的概念。微软最近收购了 GitHub，这是基于 Git 的最大远程代码仓库网站，并将大多数微软的 IDEs/编辑器与之集成，包括最新的代码编辑器 Visual Code。这显示了 Git 对我们行业有多么重要。我相信每个开发人员，无论是新手还是资深人员，都应该为他们的代码使用版本控制。如果你不使用 Git，你可以使用市场上的任何其他版本控制系统。然而，Git 是最好的，即使你在工作中没有使用 Git，我也建议你在个人项目中使用它。Git 命令非常简单，所以你只需要练习几次就能完全理解它。

下一章有点不同。我们将看一些在面试中常被问到的问题。


# 第十七章：为面试和未来做准备

这是一本**面向对象编程**（**OOP**）书中不同寻常的一章。面试是软件开发人员职业生涯中的重要组成部分。面试就像是对你知识的一次考验。它让你了解自己的知识水平以及你应该学习更多的内容。这也是向其他公司的经验丰富的开发人员学习的一种方式。

本章的主要目的是让你了解在工作面试中会被问到的问题类型，以及如何为此做好准备。请记住，工作面试问题取决于你申请的职位、公司、面试官的知识以及公司正在使用的技术栈。虽然不是所有这些问题都会被问到，但有可能会问到其中一些，因为这些问题决定了你的基本面向对象编程和 C#知识。

让我们回顾一下本章将涵盖的主题：

+   面试问题

+   面试和职业技巧

+   接下来要学习的事情

+   阅读的重要性

# 面试问题

在本节中，我们将讨论初学者到中级开发人员的一些最常见的面试问题。由于本书是关于 C#的，我们还将提出与 C#编程语言直接相关的问题。

# 面向对象编程的基本原则是什么？

面向对象编程有四个基本原则：

+   继承

+   封装

+   抽象

+   多态性

# 什么是继承？

**继承**意味着一个类可以继承另一个类的属性和方法。例如，`Dog`是一个类，但它也是`Animal`的子类。`Animal`类是一个更一般的类，具有所有动物都具有的基本属性和方法。由于狗也是一种动物，`Dog`类可以继承`Animal`类，因此`Animal`类的所有属性和方法也可以在`Dog`类中使用。

# 什么是封装？

**封装**意味着隐藏类的数据。C#中的访问修饰符主要用于封装的目的。如果我们将方法或字段设为私有，那么该方法或字段在类外部是不可访问的。这意味着我们将数据隐藏在外部世界之外。封装的主要原因是我们希望隐藏更复杂的实现，只向外部世界展示简单的接口以便于使用。

# 什么是抽象？

**抽象**是一个概念，不是真实的东西。**抽象**意味着向外部世界提供某个对象的概念，但不提供它的实现。接口和抽象类是抽象的例子。当我们创建一个接口时，我们不实现其中的方法，但当一个类实现接口时，它也必须实现该方法。这意味着接口实际上给出了类的抽象印象。

# 什么是多态性？

**多态性**意味着多种形式。在面向对象编程中，我们应该有创建一种东西的多种形式的选项。例如，你可以有一个`addition`方法，它可能有不同的实现，取决于它接收的输入。一个接收两个整数并返回这些整数的和的`addition`方法可能是一种实现。还可能有另一种形式的`addition`方法，它可能接受两个双精度值并返回这些双精度值的和。

# 什么是接口？

**接口**是 C#编程语言中用于在程序中应用抽象的实体或特性。它就像是类和接口本身之间的合同。合同是继承接口的类必须实现接口本身具有的方法签名。接口不能被实例化，只能由类或结构实现。

# 什么是抽象类？

抽象类是一种特殊类型的类，不能被初始化。无法从抽象类创建对象。抽象类可以有具体方法和非具体方法。如果一个类实现了抽象类，那么这个类必须实现抽象方法。如果需要，它可以重写非抽象方法。

# 什么是密封类？

密封类是一种不能被继承的类。它主要用于阻止 C#中的继承特性。

# 什么是部分类？

部分类是源代码分布在不同文件中的类。通常，一个类的所有字段和方法都在同一个文件中。在部分类中，可以将类代码分开放在不同的文件中。编译时，所有来自不同文件的代码被视为单个类。

# 接口和抽象类之间有哪些区别？

接口和抽象类之间的主要区别如下：

+   一个类可以实现任意数量的接口，但只能实现一个抽象类。

+   抽象类既可以有抽象方法，也可以有非抽象方法，而接口不能有非抽象方法。

+   在抽象类中，数据成员默认为私有，而在接口中，所有数据成员都是公共的，这是无法更改的。

+   在抽象类中，我们需要使用`abstract`关键字使方法成为抽象的，而在接口中不需要这样做。

# 方法重载和方法重写之间有什么区别？

方法重载是指具有相同名称的方法具有不同的输入参数。例如，假设我们有一个名为`Sum`的方法，它接受两个整数类型的输入并返回一个整数类型的输出。`Sum`的重载方法可以接受两个双精度类型的输入并返回一个双精度输出。

方法重写是指在子类中实现具有相同名称、相同参数和相同返回类型的方法，但具有不同的实现方式。例如，假设我们在一个名为`Sales`的类中有一个名为`Discount`的方法，其中折扣是总购买额的 2%。如果我们有`Sales`的另一个子类`NewYearSales`，其中折扣是总购买额的 5%，使用方法重写，`NewYearSales`类可以轻松应用新的实现。

# 访问修饰符是什么？

访问修饰符用于设置编程语言中不同实体的安全级别。通过设置访问修饰符，我们可以隐藏不同级别类的数据。

在 C#中，有六种类型的访问修饰符：

+   公共

+   私有

+   受保护的

+   内部的

+   受保护的内部

+   私有受保护

# 什么是装箱和拆箱？

装箱是将值类型转换为对象的过程。拆箱是从对象中提取值类型的过程。装箱可以隐式进行，但拆箱必须在代码中显式进行。

# 结构体和类之间有哪些区别？

结构体和类是非常相似的概念，但有一些区别：

+   结构体是值类型，而类是引用类型。

+   结构体通常用于少量数据，而类用于大量数据。

+   结构体不能被其他类型继承，而类可以被其他类继承。

+   结构体不能是抽象的，而类可以是抽象的。

# C#中的扩展方法是什么，我们如何使用它？

**扩展方法**是一种在不创建新派生类型或编译或更改现有类型的情况下添加到现有类型的方法。它就像一个扩展。例如，默认情况下，我们从.NET 框架中得到字符串类型。如果我们想要向这个字符串类型添加另一个方法，要么我们必须创建一个派生类型来扩展这个字符串类型并在那里放置方法，要么我们在.NET 框架中添加代码并编译和重建库。然而，使用扩展方法，我们可以轻松地扩展现有类型中的方法。为此，我们必须创建一个静态类，然后创建一个静态的扩展方法。这个方法应该以类型作为参数，但在字符串之前应该放置`this`关键字。现在这个方法将作为该类型的扩展方法工作。

# 托管代码和非托管代码是什么？

在.NET 框架中开发的代码称为托管代码。**公共语言运行时**（**CLR**）可以直接执行这些代码。非托管代码不是在.NET 框架中开发的。

# C#中的虚方法是什么？

**虚方法**是在基类中实现的方法，但也可以在子类中被重写。虚方法不能是抽象的、静态的、私有的或重写的。

# 你对 C#中的值类型和引用类型理解如何？

在 C#中，有两种类型的数据。一种称为值类型，另一种称为引用类型。**值类型**是直接在内存位置中保存值的类型。如果值被复制，一个新的内存位置保存相同的值，两者相互独立。**引用类型**是指值不直接放在内存位置中，而是设置对值的引用。值类型和引用类型之间的另一个主要区别是，值类型位于堆栈中，而引用类型位于堆中。值类型的例子是`int`，而引用类型的例子是`string`。

# 设计原则是什么？

有五个设计原则组成了**SOLID**的首字母缩写：

+   单一责任原则

+   开闭原则

+   里氏替换原则

+   接口隔离原则

+   依赖反转原则

# 单一责任原则

<q>*“一个类应该只有一个改变的理由。”*</q>

- *罗伯特·C·马丁*

这意味着一个类应该只有一个责任。如果一个类做了多件事情，这就违反了**单一责任原则**（**SRP**）。例如，如果我们有一个名为`Student`的类，它应该只负责与学生相关的数据。如果`Student`类在`Teacher`类中的任何更改时需要修改，那么`Student`类就违反了 SRP。

# 开闭原则

软件组件应该对扩展开放，但对修改关闭。这意味着组件应该被设计成这样，如果需要添加新的规则或功能，就不需要修改现有的代码。如果需要修改现有的代码来添加新功能，这意味着组件违反了**开闭原则**。

# 里氏替换原则是什么？

派生类型必须完全可替代其基类型。这意味着如果你有一个基类的实例在某处使用，你应该能够用该基类的子类实例替换基类实例。例如，如果你有一个名为`Animal`的基类和一个名为`Dog`的子类，你应该能够用`Dog`类的实例替换`Animal`类的实例而不会破坏任何功能。

# 接口隔离原则是什么？

客户不应该被迫依赖于他们不使用的接口。有时，接口包含许多可能不被实现它们的类使用的信息。**接口隔离原则**建议你保持接口的小型化。类不应该实现一个大接口，而应该实现多个小接口，其中类中的所有方法都是需要的。

# 什么是依赖反转原则？

高级模块不应该依赖于低级模块；两者都应该依赖于抽象。这意味着，当你开发模块化软件代码时，高级模块不应该直接依赖于低级模块，而应该依赖于低级模块实现的接口或抽象类。通过这样做，系统中的模块是独立的，将来如果你用另一个模块替换低级模块，高级模块不会受到影响。

这个原则的另一个部分是*抽象不应该依赖于细节，细节应该依赖于抽象*。这意味着接口或抽象类不应该依赖于类，而实现接口和抽象类的类应该依赖于接口或抽象类。

# 面试和职业技巧

现在我们已经涵盖了一些你在面试中可能会被问到的最常见问题，我还有一些提示，可以帮助你在面试和职业生涯中表现更好。

# 提高你的沟通技巧

人们普遍认为软件开发人员不合群，沟通能力不强。然而，现实情况却截然不同。所有成功的开发人员*都*必须具备良好的沟通能力。

作为一名软件开发人员，你会有时需要向非技术人员解释技术理念或情况。为了能够做到这一点，你必须以一种使信息对每个人都易于访问和理解的方式进行沟通。这可能包括口头（会议或讨论）和书面沟通（文档或电子邮件）。

在你的职业生涯开始时，你可能并不一定理解沟通的重要性，因为你只是被分配任务来完成。然而，随着你的经验积累和职业发展，你会意识到有效沟通的重要性。

作为一名资深开发人员，你可能需要与初级开发人员沟通，解释问题或解决方案，或者与业务团队沟通，以确保你充分理解业务需求。你可能还需要进行技术培训，以进行知识分享。

因此，请确保你与人们保持互动，并阅读资源，这些资源将帮助你有效沟通，并教你如何与你的听众交流。良好的沟通技巧不仅将帮助你在面试中脱颖而出，而且在整个职业生涯中也将对你非常有价值。

# 继续练习

虽然没有完美的软件开发人员，但通过定期练习，你可以成为一个知识渊博、经验丰富的软件开发人员。

计算机编程是一门艺术。通过犯错误，你会培养出对错与对的感觉。你编写的代码越多，你会经历更多不同的情况。这些情况将帮助你积累经验，因为你很可能在未来的项目中再次遇到它们。

而学习或掌握编程的最佳方法是*实践*。

尝试将你在本书中学到的概念应用到你的实际项目中。如果在你当前的项目中不可能做到这一点，那就创建演示项目并在那里应用它们。技术概念是非常实用的；如果你进行实际的实现，这些概念将变得非常清晰。

# 接下来要学习的事情

阅读完这本书后，你应该对面向对象编程和 C#编程语言有更好的理解。然而，这还不够。你必须努力学习更多关于软件开发的知识。你应该学习 C#的其他语言特性，以及如何使用它们来完成工作。你还应该学习数据结构和算法来应对你的专业工作。在下面的列表中，我建议你研究一些主题和技术：

+   C#编程语言特性，如运算符、控制语句、数组、列表、运算符重载、Lambda 表达式、LINQ、字符串格式化和线程

+   诸如链表、二叉树、排序和搜索算法等数据结构和算法

+   诸如 ASP.NET MVC、ASP.NET Web API、WPF 和 WCF 等 Web/桌面框架

+   诸如 HTML、CSS 和 JavaScript 等前端技术，以及 reactjs/angular 等 JavaScript 框架

+   诸如 MS SQL Server、Oracle 和 MySQL 等数据库技术

+   设计模式及其影响

+   软件架构和设计

+   清晰的代码、代码重构和代码优化

还有许多其他需要学习的东西，但我已经涵盖了我认为每个软件开发人员都应该了解的主题。这个列表相当长，主题也相当技术化，所以要仔细规划你的学习。

# 养成阅读的习惯

我最后的建议是成为一个热心的读者。阅读对软件开发人员非常重要。信息通常通过文本或语音分发给人们。虽然视频教程是学习的好方法，但阅读可以给你时间思考，并为你提供数百万资源的访问。

以下是我必读的一些书籍：

+   Andrew Hunt 和 David Thomas 的《实用程序员：从学徒到大师》

+   Robert Cecil Martin 的《代码整洁之道》

+   Steve McConnell 的《代码大全 2》

+   Martin Fowler 和 Kent Beck 的《重构》

+   Charles E. Leiserson、Clifford Stein、Ronald Rivest 和 Thomas H. Cormen 的《算法导论》

+   《设计模式：可复用面向对象软件的元素》

+   Joseph Albahari 的《C# 7.0 权威参考》

+   Jon Skeet 的《深入理解 C#》

# 总结

软件开发是一个非常有趣的领域。你可以开发出可以改变世界的惊人应用。像 Facebook 和地图这样的应用，以及谷歌和 Windows 等数字巨头的众多产品，对我们的生活产生了重大影响。程序可以通过提高生产力来让人们的生活变得更加轻松。

作为一名软件开发人员，我请求你写出优秀的代码，开发出令人惊叹的应用。如果你有正确的意图、对软件开发的热情和强烈的职业道德，你一定会在你的职业生涯中取得成功。

让我们通过创建能够促进人类文明进步的惊人软件，让这个世界变得更美好。
